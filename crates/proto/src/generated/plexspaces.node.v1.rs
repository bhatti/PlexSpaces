// @generated
// This file is @generated by prost-build.
/// Release specification (Erlang/OTP-inspired)
///
/// ## Purpose
/// Complete system definition for a PlexSpaces node. Analogous to
/// Erlang .rel files, defines which applications to include and
/// how to configure the runtime.
///
/// ## Why This Exists
/// - Single source of truth for node configuration
/// - Supports multiple applications per node (Erlang model)
/// - Enables declarative deployment (Docker, k8s)
/// - Provides graceful shutdown specifications
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseSpec {
    /// Release metadata
    ///
    /// e.g., "plexspaces-cluster"
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Semantic version (e.g., "1.0.0")
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    /// Human-readable description
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Node configuration
    #[prost(message, optional, tag="4")]
    pub node: ::core::option::Option<NodeConfig>,
    /// Runtime configuration (gRPC, middleware, health)
    #[prost(message, optional, tag="5")]
    pub runtime: ::core::option::Option<RuntimeConfig>,
    /// System applications (always included)
    #[prost(string, repeated, tag="6")]
    pub system_applications: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// User applications (business logic)
    #[prost(message, repeated, tag="7")]
    pub applications: ::prost::alloc::vec::Vec<ApplicationConfig>,
    /// Environment variables for all applications
    #[prost(map="string, string", tag="8")]
    pub env: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Shutdown configuration (Erlang/OTP-inspired)
    #[prost(message, optional, tag="9")]
    pub shutdown: ::core::option::Option<ShutdownConfig>,
}
/// Node configuration
///
/// ## Purpose
/// Defines node identity and cluster membership settings.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeConfig {
    /// Node ID (unique in cluster)
    /// Can be environment variable like "${NODE_ID}"
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Address this node listens on (e.g., "0.0.0.0:9001")
    #[prost(string, tag="2")]
    pub listen_address: ::prost::alloc::string::String,
    /// Cluster seed nodes for discovery
    /// e.g., \["node1.cluster.local:9001", "node2.cluster.local:9001"\]
    #[prost(string, repeated, tag="3")]
    pub cluster_seed_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default tenant ID for this node
    ///
    /// Used when auth is disabled or when creating actors from embedded applications.
    /// If not set and auth is disabled, will use "default".
    /// If auth is enabled and tenant_id is not provided, will error.
    #[prost(string, tag="4")]
    pub default_tenant_id: ::prost::alloc::string::String,
    /// Default namespace for this node
    ///
    /// Used when namespace is not specified in requests.
    /// Defaults to "default" if not set.
    #[prost(string, tag="5")]
    pub default_namespace: ::prost::alloc::string::String,
    /// Cluster name for grouping nodes that share UDP/ZeroMQ channels
    ///
    /// Nodes with the same cluster_name can communicate via UDP multicast
    /// or ZeroMQ channels. Used for service discovery and channel configuration.
    /// If empty, node is not part of any cluster.
    #[prost(string, tag="6")]
    pub cluster_name: ::prost::alloc::string::String,
}
/// Runtime configuration
///
/// ## Purpose
/// Defines runtime services (gRPC, middleware, health monitoring, security, blob storage,
/// and unified storage backends).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeConfig {
    /// gRPC server configuration
    #[prost(message, optional, tag="1")]
    pub grpc: ::core::option::Option<GrpcConfig>,
    /// Health monitoring configuration
    #[prost(message, optional, tag="2")]
    pub health: ::core::option::Option<HealthConfig>,
    /// Security configuration (authentication/authorization)
    #[prost(message, optional, tag="3")]
    pub security: ::core::option::Option<SecurityConfig>,
    /// Blob storage configuration (S3-compatible object storage)
    #[prost(message, optional, tag="4")]
    pub blob: ::core::option::Option<super::super::storage::v1::BlobConfig>,
    /// Shared relational database configuration
    ///
    /// Used by components that always use relational database:
    /// - scheduler (crates/scheduler/migrations)
    /// - workflow (crates/workflow/migrations)
    /// - journaling (crates/journaling/migrations)
    /// - blob (crates/blob/migrations)
    /// - keyvalue (crates/keyvalue/migrations) - now always SQL
    ///
    /// Convention: All these components share the same database by default.
    /// Can be overridden per-component if needed.
    #[prost(message, optional, tag="5")]
    pub shared_database: ::core::option::Option<super::super::storage::v1::SharedRelationalDbConfig>,
    /// Locks storage provider configuration
    ///
    /// Supports: postgres, sqlite, redis, dynamodb
    /// Default: redis (if available), else postgres
    #[prost(message, optional, tag="6")]
    pub locks_provider: ::core::option::Option<super::super::storage::v1::StorageProviderConfig>,
    /// Channel storage provider configuration
    ///
    /// Supports: redis, kafka, nats, sqlite, memory
    /// Default: redis (if available), else memory
    #[prost(message, optional, tag="7")]
    pub channel_provider: ::core::option::Option<super::super::storage::v1::StorageProviderConfig>,
    /// TupleSpace storage provider configuration
    ///
    /// Supports: postgres, sqlite, redis, dynamodb
    /// Default: postgres (if available), else memory
    #[prost(message, optional, tag="8")]
    pub tuplespace_provider: ::core::option::Option<super::super::storage::v1::StorageProviderConfig>,
    /// Mailbox storage provider configuration
    ///
    /// Supports: memory, redis, sqlite, postgres
    /// Default: memory
    #[prost(message, optional, tag="9")]
    pub mailbox_provider: ::core::option::Option<super::super::storage::v1::StorageProviderConfig>,
    /// Framework version information (auto-populated at build time)
    #[prost(message, optional, tag="10")]
    pub framework_info: ::core::option::Option<super::super::storage::v1::FrameworkInfo>,
}
/// gRPC server configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrpcConfig {
    /// Enable gRPC server
    #[prost(bool, tag="1")]
    pub enabled: bool,
    /// gRPC listen address (e.g., "0.0.0.0:9001")
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// Maximum concurrent connections
    #[prost(uint32, tag="3")]
    pub max_connections: u32,
    /// Keepalive interval (seconds)
    #[prost(uint64, tag="4")]
    pub keepalive_interval_seconds: u64,
    /// Middleware stack (order matters!)
    #[prost(message, repeated, tag="5")]
    pub middleware: ::prost::alloc::vec::Vec<MiddlewareConfig>,
}
/// Middleware configuration
///
/// ## Purpose
/// Declarative middleware configuration for gRPC server.
/// Middleware executes in the order specified.
///
/// ## Supported Middleware Types
/// - "metrics": Prometheus metrics collection
/// - "tracing": OpenTelemetry distributed tracing
/// - "mtls": Mutual TLS authentication
/// - "compression": gzip/brotli compression
/// - "rate_limiting": Request rate limiting
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiddlewareConfig {
    /// Middleware type (e.g., "metrics", "tracing", "mtls")
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    /// Enable this middleware
    #[prost(bool, tag="2")]
    pub enabled: bool,
    /// Middleware-specific configuration (JSON or map)
    #[prost(map="string, string", tag="3")]
    pub config: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Health monitoring configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthConfig {
    /// Heartbeat interval (seconds)
    #[prost(uint64, tag="1")]
    pub heartbeat_interval_seconds: u64,
    /// Heartbeat timeout (seconds)
    #[prost(uint64, tag="2")]
    pub heartbeat_timeout_seconds: u64,
    /// Registry URL for heartbeat reporting
    #[prost(string, tag="3")]
    pub registry_url: ::prost::alloc::string::String,
}
/// Security configuration
///
/// ## Purpose
/// Defines authentication and authorization settings for the node.
/// Each node can have its own security configuration (secrets/keys).
///
/// ## Design
/// - Service-to-service: mTLS with X.509 certificates
/// - Public APIs: JWT authentication
/// - Service credentials: API keys
///
/// ## Security Best Practices
/// - Store secrets in environment variables or secret management systems
/// - Use file paths for certificates (not inline in config)
/// - Rotate certificates regularly
/// - Auth enabled by default (can disable for local testing)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityConfig {
    /// Service identity for this node (mTLS)
    ///
    /// Used for service-to-service authentication.
    /// Each node should have its own service identity.
    #[prost(message, optional, tag="1")]
    pub service_identity: ::core::option::Option<super::super::security::v1::ServiceIdentity>,
    /// mTLS configuration
    ///
    /// Configures mutual TLS for service-to-service communication.
    /// Required if mTLS is enabled in middleware.
    #[prost(message, optional, tag="2")]
    pub mtls: ::core::option::Option<super::super::security::v1::MtlsConfig>,
    /// JWT configuration for public APIs
    ///
    /// Configures JWT authentication for external/public APIs.
    /// Required if JWT authentication is enabled in middleware.
    #[prost(message, optional, tag="3")]
    pub jwt: ::core::option::Option<super::super::security::v1::JwtConfig>,
    /// API keys for service authentication
    ///
    /// List of API keys this node can use for authentication.
    /// Keys are service-scoped (not user-scoped).
    #[prost(message, repeated, tag="4")]
    pub api_keys: ::prost::alloc::vec::Vec<super::super::security::v1::ApiKey>,
    /// Allow disabling auth for local testing (default: false)
    ///
    /// Security: Only set to true in development/test environments.
    /// Production should always have auth enabled.
    #[prost(bool, tag="5")]
    pub allow_disable_auth: bool,
    /// Disable authentication (only if allow_disable_auth = true)
    ///
    /// Security: Only for integration tests. Never use in production.
    #[prost(bool, tag="6")]
    pub disable_auth: bool,
}
/// Application configuration (in release)
///
/// ## Purpose
/// Defines which applications to load and their startup/shutdown behavior.
///
/// ## Dependency Resolution
/// Applications with dependencies will start AFTER their dependencies.
/// Uses topological sort (Kahn's algorithm) to determine startup order.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationConfig {
    /// Application name (must match .app.toml)
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Application version
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    /// Path to application config file (e.g., "apps/byzantine/byzantine.app.toml")
    #[prost(string, tag="3")]
    pub config_path: ::prost::alloc::string::String,
    /// Enable this application
    #[prost(bool, tag="4")]
    pub enabled: bool,
    /// Auto-start on node boot
    #[prost(bool, tag="5")]
    pub auto_start: bool,
    /// Shutdown timeout (seconds)
    /// 0 = immediate (brutal_kill)
    /// >0 = graceful with timeout
    /// Special value -1 = infinity (wait forever)
    #[prost(int64, tag="6")]
    pub shutdown_timeout_seconds: i64,
    /// Shutdown strategy
    #[prost(enumeration="ShutdownStrategy", tag="7")]
    pub shutdown_strategy: i32,
    /// Dependencies (other application names)
    /// This application will start AFTER all dependencies have started.
    /// Used for topological sort during node startup.
    ///
    /// ## Examples
    /// - \["tuplespace-service"\] - Requires TupleSpace to be running first
    /// - \["actor-registry", "node-registry"\] - Requires both registries
    #[prost(string, repeated, tag="8")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Shutdown configuration (node-level)
///
/// ## Purpose
/// Global shutdown settings for the entire node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownConfig {
    /// Global shutdown timeout (seconds)
    /// If node shutdown exceeds this, force-kill all remaining processes
    #[prost(uint64, tag="1")]
    pub global_timeout_seconds: u64,
    /// Grace period after deregistration (seconds)
    /// Allows time for cluster to route work away from this node
    #[prost(uint64, tag="2")]
    pub grace_period_seconds: u64,
    /// gRPC drain timeout (seconds)
    /// How long to wait for in-flight gRPC requests to complete
    #[prost(uint64, tag="3")]
    pub grpc_drain_timeout_seconds: u64,
}
/// Release error message
///
/// ## Purpose
/// Structured error information for release operations.
/// Used in gRPC responses and internal error handling.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseError {
    /// Error code
    #[prost(enumeration="ReleaseErrorCode", tag="1")]
    pub code: i32,
    /// Human-readable error message
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Additional context (e.g., application name, dependency name)
    #[prost(map="string, string", tag="3")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Shutdown strategy (Erlang/OTP-inspired)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShutdownStrategy {
    /// Unspecified (default to graceful)
    ShutdownStrategyUnspecified = 0,
    /// Graceful shutdown with cleanup
    /// Equivalent to Erlang's `shutdown: Timeout`
    ShutdownStrategyGraceful = 1,
    /// Immediate termination (no cleanup)
    /// Equivalent to Erlang's `shutdown: brutal_kill`
    ShutdownStrategyBrutalKill = 2,
    /// Wait indefinitely for graceful shutdown
    /// Equivalent to Erlang's `shutdown: infinity`
    ShutdownStrategyInfinity = 3,
}
impl ShutdownStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ShutdownStrategy::ShutdownStrategyUnspecified => "SHUTDOWN_STRATEGY_UNSPECIFIED",
            ShutdownStrategy::ShutdownStrategyGraceful => "SHUTDOWN_STRATEGY_GRACEFUL",
            ShutdownStrategy::ShutdownStrategyBrutalKill => "SHUTDOWN_STRATEGY_BRUTAL_KILL",
            ShutdownStrategy::ShutdownStrategyInfinity => "SHUTDOWN_STRATEGY_INFINITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHUTDOWN_STRATEGY_UNSPECIFIED" => Some(Self::ShutdownStrategyUnspecified),
            "SHUTDOWN_STRATEGY_GRACEFUL" => Some(Self::ShutdownStrategyGraceful),
            "SHUTDOWN_STRATEGY_BRUTAL_KILL" => Some(Self::ShutdownStrategyBrutalKill),
            "SHUTDOWN_STRATEGY_INFINITY" => Some(Self::ShutdownStrategyInfinity),
            _ => None,
        }
    }
}
/// Release error types
///
/// ## Purpose
/// Defines all error conditions that can occur during release
/// loading, dependency resolution, and application lifecycle.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReleaseErrorCode {
    /// Unknown error
    ReleaseErrorCodeUnspecified = 0,
    /// IO error reading release file
    ReleaseErrorCodeIoError = 1,
    /// TOML parsing error
    ReleaseErrorCodeTomlParseError = 2,
    /// Circular dependency detected in application dependencies
    /// e.g., app-a depends on app-b, app-b depends on app-a
    ReleaseErrorCodeCircularDependency = 3,
    /// Missing dependency: application depends on another application
    /// that is not included in the release
    ReleaseErrorCodeMissingDependency = 4,
    /// Application not found in release
    ReleaseErrorCodeApplicationNotFound = 5,
    /// Invalid configuration (malformed or conflicting settings)
    ReleaseErrorCodeInvalidConfig = 6,
}
impl ReleaseErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReleaseErrorCode::ReleaseErrorCodeUnspecified => "RELEASE_ERROR_CODE_UNSPECIFIED",
            ReleaseErrorCode::ReleaseErrorCodeIoError => "RELEASE_ERROR_CODE_IO_ERROR",
            ReleaseErrorCode::ReleaseErrorCodeTomlParseError => "RELEASE_ERROR_CODE_TOML_PARSE_ERROR",
            ReleaseErrorCode::ReleaseErrorCodeCircularDependency => "RELEASE_ERROR_CODE_CIRCULAR_DEPENDENCY",
            ReleaseErrorCode::ReleaseErrorCodeMissingDependency => "RELEASE_ERROR_CODE_MISSING_DEPENDENCY",
            ReleaseErrorCode::ReleaseErrorCodeApplicationNotFound => "RELEASE_ERROR_CODE_APPLICATION_NOT_FOUND",
            ReleaseErrorCode::ReleaseErrorCodeInvalidConfig => "RELEASE_ERROR_CODE_INVALID_CONFIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELEASE_ERROR_CODE_UNSPECIFIED" => Some(Self::ReleaseErrorCodeUnspecified),
            "RELEASE_ERROR_CODE_IO_ERROR" => Some(Self::ReleaseErrorCodeIoError),
            "RELEASE_ERROR_CODE_TOML_PARSE_ERROR" => Some(Self::ReleaseErrorCodeTomlParseError),
            "RELEASE_ERROR_CODE_CIRCULAR_DEPENDENCY" => Some(Self::ReleaseErrorCodeCircularDependency),
            "RELEASE_ERROR_CODE_MISSING_DEPENDENCY" => Some(Self::ReleaseErrorCodeMissingDependency),
            "RELEASE_ERROR_CODE_APPLICATION_NOT_FOUND" => Some(Self::ReleaseErrorCodeApplicationNotFound),
            "RELEASE_ERROR_CODE_INVALID_CONFIG" => Some(Self::ReleaseErrorCodeInvalidConfig),
            _ => None,
        }
    }
}
/// Node represents a runtime host for actors
/// Can be a simple process, Kubernetes pod, or Firecracker VM
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration="NodeType", tag="2")]
    pub node_type: i32,
    #[prost(enumeration="NodeStatus", tag="3")]
    pub status: i32,
    #[prost(message, optional, tag="4")]
    pub capabilities: ::core::option::Option<NodeCapabilities>,
    #[prost(message, optional, tag="5")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    #[prost(message, optional, tag="6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="7")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    /// Current actors hosted on this node
    #[prost(string, repeated, tag="20")]
    pub actor_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Resource metrics
    #[prost(message, optional, tag="21")]
    pub metrics: ::core::option::Option<NodeMetrics>,
    /// mTLS identity for node-to-node communication
    ///
    /// Used for service-to-service authentication.
    /// Nodes register their public certificate in object-registry.
    #[prost(message, optional, tag="22")]
    pub mtls_identity: ::core::option::Option<super::super::security::v1::ServiceIdentity>,
    /// Public certificate (PEM format) for object-registry registration
    ///
    /// Other nodes can fetch this certificate for mTLS verification.
    /// Stored in object-registry for service discovery.
    #[prost(bytes="vec", tag="23")]
    pub public_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Auto-generate certificates if not provided (for local dev/testing)
    ///
    /// Security: Only for local development. Production should use proper cert management.
    #[prost(bool, tag="24")]
    pub auto_generate_certs: bool,
    /// Cluster name for grouping nodes that share UDP/ZeroMQ channels
    ///
    /// Nodes with the same cluster_name can communicate via UDP multicast
    /// or ZeroMQ channels. Used for service discovery and channel configuration.
    /// If empty, node is not part of any cluster.
    #[prost(string, tag="25")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Type-specific configuration
    #[prost(oneof="node::Config", tags="10, 11, 12")]
    pub config: ::core::option::Option<node::Config>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    /// Type-specific configuration
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag="10")]
        ProcessConfig(super::ProcessConfig),
        #[prost(message, tag="11")]
        KubernetesConfig(super::KubernetesConfig),
        #[prost(message, tag="12")]
        FirecrackerConfig(super::FirecrackerConfig),
    }
}
/// Node capabilities
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeCapabilities {
    #[prost(uint32, tag="1")]
    pub max_actors: u32,
    #[prost(uint64, tag="2")]
    pub memory_bytes: u64,
    #[prost(uint32, tag="3")]
    pub cpu_millicores: u32,
    #[prost(bool, tag="4")]
    pub supports_wasm: bool,
    #[prost(bool, tag="5")]
    pub supports_isolation: bool,
    #[prost(string, repeated, tag="6")]
    pub supported_runtimes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Node runtime configuration
///
/// ## Purpose
/// Runtime configuration for a PlexSpaces node, including network settings,
/// clustering options, and operational parameters.
///
/// ## Design
/// Proto-first design: All node configuration is defined in proto for:
/// - Wire compatibility (gRPC configuration APIs)
/// - Language-agnostic configuration
/// - Consistent configuration semantics across implementations
///
/// ## Note
/// This is different from NodeConfig in release.proto which is for release/deployment.
/// This NodeRuntimeConfig is for runtime operational settings.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeRuntimeConfig {
    /// Listen address for gRPC server (e.g., "0.0.0.0:9000")
    #[prost(string, tag="1")]
    pub listen_addr: ::prost::alloc::string::String,
    /// Maximum number of concurrent connections
    #[prost(uint32, tag="2")]
    pub max_connections: u32,
    /// Heartbeat interval in milliseconds
    #[prost(uint64, tag="3")]
    pub heartbeat_interval_ms: u64,
    /// Enable clustering (multi-node coordination)
    #[prost(bool, tag="4")]
    pub clustering_enabled: bool,
    /// Node metadata (key-value pairs for extensibility)
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Process-based node configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessConfig {
    #[prost(string, tag="1")]
    pub pid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub working_directory: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub environment: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Kubernetes-based node configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KubernetesConfig {
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub pod_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="4")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(map="string, string", tag="5")]
    pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Firecracker-based node configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirecrackerConfig {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub socket_path: ::prost::alloc::string::String,
    #[prost(uint64, tag="3")]
    pub memory_size_mib: u64,
    #[prost(uint32, tag="4")]
    pub vcpu_count: u32,
    #[prost(string, tag="5")]
    pub kernel_image_path: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub rootfs_path: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="7")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
}
/// Network interface for Firecracker VM
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    #[prost(string, tag="1")]
    pub iface_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub host_dev_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub guest_mac: ::prost::alloc::string::String,
}
/// Node metrics (combined resource usage and operational metrics)
///
/// ## Purpose
/// Comprehensive metrics for a PlexSpaces node, including both resource usage
/// (CPU, memory) and operational metrics (messages, actors, connections).
///
/// ## Design
/// Proto-first design: All node metrics are defined in proto for:
/// - Wire compatibility (gRPC metrics APIs)
/// - Language-agnostic observability
/// - Consistent metrics semantics across implementations
///
/// ## Metrics Categories
/// - Resource metrics: CPU, memory, uptime
/// - Operational metrics: Messages routed, actors, connections
/// - All combined in one message for efficient querying
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMetrics {
    /// Resource usage metrics
    #[prost(uint64, tag="1")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag="2")]
    pub memory_available_bytes: u64,
    #[prost(double, tag="3")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag="4")]
    pub uptime_seconds: u64,
    /// Operational metrics
    /// Total messages routed through this node
    #[prost(uint64, tag="5")]
    pub messages_routed: u64,
    /// Local message deliveries (same node)
    #[prost(uint64, tag="6")]
    pub local_deliveries: u64,
    /// Remote message deliveries (different node)
    #[prost(uint64, tag="7")]
    pub remote_deliveries: u64,
    /// Failed message deliveries
    #[prost(uint64, tag="8")]
    pub failed_deliveries: u64,
    /// Total messages processed (legacy field, kept for compatibility)
    #[prost(uint64, tag="9")]
    pub messages_processed: u64,
    /// Actor and connection metrics
    /// Active actors on this node
    #[prost(uint32, tag="10")]
    pub active_actors: u32,
    /// Total actor count (legacy field, kept for compatibility)
    #[prost(uint32, tag="11")]
    pub actor_count: u32,
    /// Connected nodes in cluster
    #[prost(uint32, tag="12")]
    pub connected_nodes: u32,
    /// Node identity (for components that need node info without depending on Node type)
    /// Node ID for this metrics instance
    #[prost(string, tag="13")]
    pub node_id: ::prost::alloc::string::String,
    /// Cluster name for this node (from node config)
    #[prost(string, tag="14")]
    pub cluster_name: ::prost::alloc::string::String,
}
/// Request to register a node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterNodeRequest {
    #[prost(message, optional, tag="1")]
    pub node: ::core::option::Option<Node>,
}
/// Response for node registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterNodeResponse {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub registered_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request to unregister a node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterNodeRequest {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// Request to get node status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeRequest {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
}
/// Request to list nodes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesRequest {
    #[prost(enumeration="NodeType", tag="1")]
    pub node_type: i32,
    #[prost(enumeration="NodeStatus", tag="2")]
    pub status: i32,
    #[prost(int32, tag="3")]
    pub page_size: i32,
    #[prost(string, tag="4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for list nodes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesResponse {
    #[prost(message, repeated, tag="1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub total_count: i32,
}
/// Request to assign an actor to a node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignActorRequest {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<super::super::actor::v1::ActorConfig>,
}
/// Response for actor assignment
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignActorResponse {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub assigned_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request to remove an actor from a node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveActorRequest {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub graceful: bool,
}
// ============================================================================
// ORBIT-INSPIRED: DISTRIBUTED ACTOR LOCK
// ============================================================================
// Ensures single activation guarantee across cluster

/// Distributed actor lock (Orbit-inspired)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorLock {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Node that holds the lock
    #[prost(string, tag="2")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub acquired_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="4")]
    pub lease_duration: ::core::option::Option<::prost_types::Duration>,
    /// Unique token for this lock
    #[prost(string, tag="5")]
    pub lock_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcquireActorLockRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub requesting_node_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub lease_duration: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcquireActorLockResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, optional, tag="2")]
    pub lock: ::core::option::Option<ActorLock>,
    /// If failed, who has it
    #[prost(string, tag="3")]
    pub conflict_node_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseActorLockRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub lock_token: ::prost::alloc::string::String,
}
// ============================================================================
// WASMCLOUD-INSPIRED: LATTICE MESH NETWORKING
// ============================================================================
// Self-forming, self-healing node discovery

/// Node discovery and mesh (wasmCloud-inspired)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeDiscovery {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub capabilities: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub health: ::core::option::Option<NodeHealth>,
    #[prost(message, optional, tag="5")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
}
/// Node health information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeHealth {
    #[prost(double, tag="1")]
    pub cpu_usage: f64,
    #[prost(uint64, tag="2")]
    pub memory_usage_mb: u64,
    #[prost(uint32, tag="3")]
    pub active_actors: u32,
    #[prost(bool, tag="4")]
    pub is_available: bool,
}
/// Node registration for distributed node discovery
/// Used by NodeRegistry for node lookup and health tracking
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeRegistration {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    /// gRPC address (e.g., "<http://localhost:9001">)
    #[prost(string, tag="2")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub capabilities: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(enumeration="NodeStatus", tag="4")]
    pub status: i32,
    #[prost(message, optional, tag="5")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="6")]
    pub actor_count: u64,
    #[prost(uint64, tag="7")]
    pub message_count: u64,
    #[prost(uint64, tag="8")]
    pub error_count: u64,
    #[prost(message, optional, tag="9")]
    pub registered_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Node capacity for resource-aware scheduling
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeCapacity {
    /// Total resources available on node
    #[prost(message, optional, tag="1")]
    pub total: ::core::option::Option<super::super::common::v1::ResourceSpec>,
    /// Allocated resources (currently in use)
    #[prost(message, optional, tag="2")]
    pub allocated: ::core::option::Option<super::super::common::v1::ResourceSpec>,
    /// Available resources (total - allocated)
    #[prost(message, optional, tag="3")]
    pub available: ::core::option::Option<super::super::common::v1::ResourceSpec>,
    /// Node labels (for label-based matching)
    #[prost(map="string, string", tag="4")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Node metadata for scheduling
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMetadata {
    /// Node labels (for label-based matching)
    #[prost(map="string, string", tag="1")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Node annotations (for extensibility)
    #[prost(map="string, string", tag="2")]
    pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Heartbeat message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Heartbeat {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub health: ::core::option::Option<NodeHealth>,
    /// Node capacity for resource-aware scheduling
    #[prost(message, optional, tag="4")]
    pub capacity: ::core::option::Option<NodeCapacity>,
}
/// Lattice service requests
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinLatticeRequest {
    #[prost(message, optional, tag="1")]
    pub node: ::core::option::Option<NodeDiscovery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinLatticeResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, repeated, tag="2")]
    pub existing_nodes: ::prost::alloc::vec::Vec<NodeDiscovery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaveLatticeRequest {
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoverNodesRequest {
    #[prost(map="string, string", tag="1")]
    pub capability_filters: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoverNodesResponse {
    #[prost(message, repeated, tag="1")]
    pub nodes: ::prost::alloc::vec::Vec<NodeDiscovery>,
}
/// Node type enumeration
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeType {
    NodeTypeUnspecified = 0,
    /// Simple OS process
    NodeTypeProcess = 1,
    /// Kubernetes pod
    NodeTypeKubernetes = 2,
    /// Firecracker microVM
    NodeTypeFirecracker = 3,
}
impl NodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NodeType::NodeTypeUnspecified => "NODE_TYPE_UNSPECIFIED",
            NodeType::NodeTypeProcess => "NODE_TYPE_PROCESS",
            NodeType::NodeTypeKubernetes => "NODE_TYPE_KUBERNETES",
            NodeType::NodeTypeFirecracker => "NODE_TYPE_FIRECRACKER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_TYPE_UNSPECIFIED" => Some(Self::NodeTypeUnspecified),
            "NODE_TYPE_PROCESS" => Some(Self::NodeTypeProcess),
            "NODE_TYPE_KUBERNETES" => Some(Self::NodeTypeKubernetes),
            "NODE_TYPE_FIRECRACKER" => Some(Self::NodeTypeFirecracker),
            _ => None,
        }
    }
}
/// Node status
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeStatus {
    NodeStatusUnspecified = 0,
    NodeStatusStarting = 1,
    NodeStatusReady = 2,
    NodeStatusBusy = 3,
    NodeStatusDraining = 4,
    NodeStatusStopped = 5,
    NodeStatusFailed = 6,
}
impl NodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NodeStatus::NodeStatusUnspecified => "NODE_STATUS_UNSPECIFIED",
            NodeStatus::NodeStatusStarting => "NODE_STATUS_STARTING",
            NodeStatus::NodeStatusReady => "NODE_STATUS_READY",
            NodeStatus::NodeStatusBusy => "NODE_STATUS_BUSY",
            NodeStatus::NodeStatusDraining => "NODE_STATUS_DRAINING",
            NodeStatus::NodeStatusStopped => "NODE_STATUS_STOPPED",
            NodeStatus::NodeStatusFailed => "NODE_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_STATUS_UNSPECIFIED" => Some(Self::NodeStatusUnspecified),
            "NODE_STATUS_STARTING" => Some(Self::NodeStatusStarting),
            "NODE_STATUS_READY" => Some(Self::NodeStatusReady),
            "NODE_STATUS_BUSY" => Some(Self::NodeStatusBusy),
            "NODE_STATUS_DRAINING" => Some(Self::NodeStatusDraining),
            "NODE_STATUS_STOPPED" => Some(Self::NodeStatusStopped),
            "NODE_STATUS_FAILED" => Some(Self::NodeStatusFailed),
            _ => None,
        }
    }
}
/// Node health status
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeHealthStatus {
    NodeHealthStatusUnspecified = 0,
    NodeHealthStatusHealthy = 1,
    NodeHealthStatusDegraded = 2,
    NodeHealthStatusUnhealthy = 3,
}
impl NodeHealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NodeHealthStatus::NodeHealthStatusUnspecified => "NODE_HEALTH_STATUS_UNSPECIFIED",
            NodeHealthStatus::NodeHealthStatusHealthy => "NODE_HEALTH_STATUS_HEALTHY",
            NodeHealthStatus::NodeHealthStatusDegraded => "NODE_HEALTH_STATUS_DEGRADED",
            NodeHealthStatus::NodeHealthStatusUnhealthy => "NODE_HEALTH_STATUS_UNHEALTHY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_HEALTH_STATUS_UNSPECIFIED" => Some(Self::NodeHealthStatusUnspecified),
            "NODE_HEALTH_STATUS_HEALTHY" => Some(Self::NodeHealthStatusHealthy),
            "NODE_HEALTH_STATUS_DEGRADED" => Some(Self::NodeHealthStatusDegraded),
            "NODE_HEALTH_STATUS_UNHEALTHY" => Some(Self::NodeHealthStatusUnhealthy),
            _ => None,
        }
    }
}
include!("plexspaces.node.v1.tonic.rs");
// @@protoc_insertion_point(module)