// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2025 Shahzad A. Bhatti <bhatti@plexobject.com>
//
// This file is part of PlexSpaces.
//
// PlexSpaces is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 2.1 of the License, or
// (at your option) any later version.
//
// PlexSpaces is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with PlexSpaces. If not, see <https://www.gnu.org/licenses/>.

// PlexSpaces Process Groups API (Actor Groups - Pub/Sub Pattern)
//
// ## Purpose
// Implements distributed pub/sub and broadcast messaging (Erlang pg/pg2 pattern) for actor
// coordination across nodes. Enables named groups where actors can subscribe to topics and
// receive broadcast messages.
//
// ## Terminology
// **In PlexSpaces, we use "actor" terminology consistently:**
// - Erlang's "process" = PlexSpaces "actor"
// - Process Groups are named for historical reasons (Erlang pg/pg2 compatibility)
// - Conceptually: Process Groups = Actor Groups (Pub/Sub pattern)
// - Both are collections of actors, just different coordination patterns
// - **Note**: This file uses "process" in names for Erlang compatibility, but conceptually these are "actor groups"
//
// ## CRITICAL: Process Groups vs Actor Groups (Sharding) - DIFFERENT CONCEPTS
//
// PlexSpaces has TWO distinct group abstractions - they serve different purposes:
//
// ### 1. Process Groups (THIS FILE) - Actor Groups (Pub/Sub)
// - **Purpose**: Pub/sub, broadcast, multi-actor coordination (Erlang pg/pg2)
// - **Pattern**: Named group → all members receive message (1-to-many)
// - **Use Cases**: Event broadcasting, topic subscriptions, cluster notifications
// - **Communication**: Publish to group (all members receive)
// - **State**: No shared state (each actor independent)
// - **Example**: All actors subscribed to "config-updates" receive new config
// - **When to Use**: Need broadcast/coordination, not horizontal scaling
//
// ### 2. Actor Groups (Sharding) - actor_groups.proto
// - **Purpose**: Data-parallel horizontal scaling (NSDI'22 lattice actors)
// - **Pattern**: Partition key → specific shard (1-to-one routing)
// - **Use Cases**: Sharded counters, distributed cache, time-series indexes
// - **Communication**: Scatter-gather (query all shards, merge results)
// - **State**: Lattice-based (CRDT) for coordination-free merging
// - **Example**: 100K user sessions sharded across 10 actor instances
// - **When to Use**: Need horizontal scaling for high-throughput data
//
// **Key Difference**:
// - **Process Groups (Pub/Sub)**: Coordination via broadcast (all members receive)
// - **Actor Groups (Sharding)**: Horizontal scaling via sharding (partition-based routing)
//
// **See**: `docs/GROUPS_COMPARISON.md` for detailed comparison and decision guide
//
// ## Erlang pg/pg2 Compatibility
//
// This API is inspired by Erlang's pg2 module with PlexSpaces enhancements:
//
// | Feature | Erlang pg2 | PlexSpaces ProcessGroups |
// |---------|-----------|-------------------------|
// | Named groups | ✅ | ✅ |
// | create/delete groups | ✅ | ✅ |
// | join/leave groups | ✅ | ✅ |
// | Multiple joins | ✅ (must leave equally) | ✅ (join_count tracking) |
// | get_members | ✅ | ✅ (cluster-wide) |
// | get_local_members | ✅ | ✅ (this node only) |
// | which_groups | ✅ | ✅ (ListGroups) |
// | Built-in broadcast | ❌ (user implements) | ✅ (PublishToGroup RPC) |
// | Multi-tenancy | ❌ | ✅ (tenant_id + namespace) |
// | Health monitoring | ✅ (auto-cleanup) | ✅ (via ActorRegistry) |
// | Proto-defined | ❌ | ✅ (type-safe contract) |
//
// ## Architecture Context
//
// Process groups integrate with core PlexSpaces components:
//
// - **ActorRegistry**: Groups validate actor IDs via registry, use same KeyValueStore backend
// - **Multi-Tenancy**: Groups scoped by tenant_id + namespace (prevents cross-tenant access)
// - **Distributed Storage**: Group membership stored in KeyValueStore (Redis, PostgreSQL, etc.)
// - **Messaging**: PublishToGroup broadcasts using existing Message type from actor_runtime.proto
// - **Health Monitoring**: Dead actors automatically removed from groups via heartbeat tracking
//
// ## Integration with Other Services
//
// - **Used by**: Actors (pub/sub), Supervisors (cluster notifications), Workflows (event fanout)
// - **Depends on**: ActorRegistry (actor lookup), KeyValueStore (distributed membership)
// - **Provides**: Pub/sub abstraction for all PlexSpaces actors
//
// ## Use Cases
//
// ### 1. Configuration Updates (Broadcast Pattern)
// ```rust
// // All actors subscribe to "config-updates" group
// group_service.join_group("config-updates", my_actor_id).await?;
//
// // Admin publishes new config
// group_service.publish_to_group("config-updates", ConfigUpdateMsg).await?;
//
// // All subscribed actors receive the update
// ```
//
// ### 2. Event Notification (Pub/Sub Pattern)
// ```rust
// // Actors interested in user events join group
// group_service.join_group("user-events", actor_id).await?;
//
// // When user action occurs, publish to group
// group_service.publish_to_group("user-events", UserLoggedInEvent).await?;
// ```
//
// ### 3. Cluster-Wide Coordination (All-Nodes Pattern)
// ```rust
// // Node startup: join "cluster-nodes" group
// group_service.join_group("cluster-nodes", node_supervisor_id).await?;
//
// // Cluster-wide operation (e.g., config reload)
// let nodes = group_service.get_members("cluster-nodes").await?;
// for node in nodes {
//     node.tell(ReloadConfigMsg).await?;
// }
// ```
//
// ### 4. Local-Only Notification (Same-Node Pattern)
// ```rust
// // Get actors on this node only
// let local_actors = group_service.get_local_members("metrics-reporters").await?;
//
// // Send metrics flush command to local actors only (no network overhead)
// for actor in local_actors {
//     actor.tell(FlushMetricsMsg).await?;
// }
// ```
//
// ## Design Decisions
//
// ### Why Separate ProcessGroupService (Not Extend ActorRegistry)?
// - **Cohesion**: Group operations distinct from individual actor registration
// - **Clarity**: Separates pub/sub concerns from actor discovery
// - **Reusability**: Actors, supervisors, workflows can all use groups
// - **Future**: Easier to add group-specific features (quotas, filtering, batching)
//
// ### Why Reuse ActorRegistry Types?
// - **Consistency**: Same ActorId format, tenant_id, namespace across all services
// - **Integration**: Groups can validate actor existence via ActorRegistry
// - **Multi-Tenancy**: Reuses proven tenant isolation patterns
// - **Documentation**: Leverages existing type documentation
//
// ### Why Built-in PublishToGroup (Unlike Erlang pg2)?
// - **Convenience**: Framework handles broadcast routing and batching
// - **Optimization**: Batch messages to same remote node (reduces gRPC overhead)
// - **Observability**: Track broadcast metrics (latency, fan-out, failures)
// - **Reliability**: Retry failed deliveries per message TTL
//
// ### Why get_local_members Separate from get_members?
// - **Performance**: Local-only queries avoid network round-trips
// - **Common Pattern**: Many use cases only need local members (metrics, logs)
// - **Erlang Compatibility**: Matches pg2 API semantics
// - **Optimization**: Local broadcast skips gRPC layer entirely
//
// ### Why Multiple Joins Allowed?
// - **Erlang Compatibility**: pg2 allows multiple joins (must leave equally)
// - **Use Case**: Actor can join same group with different roles/priorities
// - **Tracking**: join_count field ensures balanced join/leave operations
//
// ### Why No Scatter-Gather?
// - **Purpose Mismatch**: Scatter-gather belongs in actor_groups.proto (sharding)
// - **Process Groups**: Focus is pub/sub, not distributed aggregation
// - **User Control**: Users implement custom aggregation if needed
// - **Simplicity**: Keep process groups simple and focused

syntax = "proto3";

package plexspaces.processgroups.v1;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "plexspaces/v1/common.proto";
import "plexspaces/v1/actors/actor_runtime.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option go_package = "github.com/bhatti/plexspaces/gen/go/plexspaces/processgroups/v1;processgroupsv1";
option java_multiple_files = true;
option java_package = "com.bhatti.plexspaces.processgroups.v1";
option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "PlexSpaces Process Groups API"
    version: "1.0"
    description: "Erlang pg/pg2-inspired distributed pub/sub and broadcast messaging"
  }
  schemes: HTTPS
  consumes: "application/json"
  produces: "application/json"
};

// ============================================================================
// PROCESS GROUP SERVICE
// ============================================================================
// Distributed pub/sub and broadcast messaging for actor coordination.
// Inspired by Erlang pg/pg2 with PlexSpaces enhancements (multi-tenancy, built-in broadcast).

service ProcessGroupService {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag) = {description: "Process group management and pub/sub service"};

  // Create named process group
  //
  // ## Purpose
  // Creates an empty, globally visible process group that actors can join.
  //
  // ## Semantics
  // - Group name must be unique within tenant + namespace
  // - Group is visible across all nodes in cluster
  // - Group persists until explicitly deleted
  // - Empty groups are allowed (actors join later)
  //
  // ## Errors
  // - ALREADY_EXISTS: Group with this name already exists
  // - PERMISSION_DENIED: Tenant not allowed to create groups
  rpc CreateGroup(CreateGroupRequest) returns (CreateGroupResponse) {
    option (google.api.http) = {
      post: "/v1/process-groups"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Create Process Group"
      description: "Create empty named group for pub/sub coordination"
      tags: "ProcessGroups"
    };
  }

  // Delete process group
  //
  // ## Purpose
  // Removes a process group and all its members.
  //
  // ## Semantics
  // - All actors automatically leave the group
  // - Group disappears from all nodes
  // - Idempotent (deleting non-existent group is no-op)
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist
  // - PERMISSION_DENIED: Tenant not allowed to delete this group
  rpc DeleteGroup(DeleteGroupRequest) returns (plexspaces.common.v1.Empty) {
    option (google.api.http) = {delete: "/v1/process-groups/{group_name}"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Delete Process Group"
      description: "Remove group and all members"
      tags: "ProcessGroups"
    };
  }

  // Join process group
  //
  // ## Purpose
  // Adds an actor to a process group (subscribes to group messages).
  //
  // ## Semantics (Erlang pg2-compatible)
  // - Actor can join multiple groups
  // - Actor can join same group multiple times (must leave equally)
  // - join_count tracked internally (join increments, leave decrements)
  // - Actor must exist in ActorRegistry (validated)
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist (must CreateGroup first)
  // - NOT_FOUND: Actor not in ActorRegistry
  // - PERMISSION_DENIED: Actor and group in different tenants
  rpc JoinGroup(JoinGroupRequest) returns (plexspaces.common.v1.Empty) {
    option (google.api.http) = {
      post: "/v1/process-groups/{group_name}/members"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Join Process Group"
      description: "Subscribe actor to group (can join multiple times)"
      tags: "ProcessGroups"
    };
  }

  // Leave process group
  //
  // ## Purpose
  // Removes an actor from a process group (unsubscribes from group messages).
  //
  // ## Semantics (Erlang pg2-compatible)
  // - Decrements join_count for this actor
  // - Actor fully removed when join_count reaches 0
  // - Idempotent if join_count already 0
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist
  // - NOT_FOUND: Actor not in this group
  rpc LeaveGroup(LeaveGroupRequest) returns (plexspaces.common.v1.Empty) {
    option (google.api.http) = {delete: "/v1/process-groups/{group_name}/members/{actor_id}"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Leave Process Group"
      description: "Unsubscribe actor from group (decrements join_count)"
      tags: "ProcessGroups"
    };
  }

  // Get all group members (cluster-wide)
  //
  // ## Purpose
  // Returns all actors in the group across all nodes.
  //
  // ## Semantics
  // - Queries distributed KeyValueStore for membership
  // - Returns actors from all nodes in cluster
  // - Useful for cluster-wide broadcast or coordination
  //
  // ## Performance
  // - O(n) where n = total members across cluster
  // - May involve network round-trips for distributed storage
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist
  rpc GetMembers(GetMembersRequest) returns (GetMembersResponse) {
    option (google.api.http) = {get: "/v1/process-groups/{group_name}/members"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get All Group Members"
      description: "Retrieve all actors in group (cluster-wide)"
      tags: "ProcessGroups"
    };
  }

  // Get local group members (this node only)
  //
  // ## Purpose
  // Returns actors in the group on this node only (faster than GetMembers).
  //
  // ## Semantics
  // - Queries local cache/registry only (no network)
  // - Returns subset of members on current node
  // - Useful for local-only operations (metrics, logs)
  //
  // ## Performance
  // - O(n) where n = local members only
  // - No network overhead (local query)
  //
  // ## Use Cases
  // - Local metrics collection
  // - Node-specific notifications
  // - Avoiding network latency for local operations
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist
  rpc GetLocalMembers(GetLocalMembersRequest) returns (GetLocalMembersResponse) {
    option (google.api.http) = {get: "/v1/process-groups/{group_name}/local-members"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get Local Group Members"
      description: "Retrieve actors in group on this node only (fast)"
      tags: "ProcessGroups"
    };
  }

  // List all process groups
  //
  // ## Purpose
  // Lists all groups, optionally filtered by tenant/namespace.
  //
  // ## Semantics
  // - Returns group metadata (not members)
  // - Supports pagination for large number of groups
  // - Tenant filter enforced (can't see other tenants' groups)
  //
  // ## Use Cases
  // - Group discovery
  // - Admin dashboards
  // - Debugging (what groups exist?)
  //
  // ## Errors
  // - PERMISSION_DENIED: Trying to list other tenant's groups
  rpc ListGroups(ListGroupsRequest) returns (ListGroupsResponse) {
    option (google.api.http) = {get: "/v1/process-groups"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "List Process Groups"
      description: "List all groups (optionally filtered by tenant/namespace)"
      tags: "ProcessGroups"
    };
  }

  // Publish message to all group members (broadcast)
  //
  // ## Purpose
  // Sends a message to ALL actors in the group (pub/sub broadcast).
  //
  // ## Semantics
  // - Message delivered to all current members
  // - Best-effort delivery (no ordering guarantees)
  // - Local members: Direct mailbox delivery
  // - Remote members: Batched gRPC sends per node
  // - Retries based on message TTL
  //
  // ## Performance
  // - Fan-out: O(n) where n = total members
  // - Batching: Messages to same node sent together
  // - Async: Does not wait for all deliveries to complete
  //
  // ## Errors
  // - NOT_FOUND: Group doesn't exist
  // - PERMISSION_DENIED: Publisher and group in different tenants
  //
  // ## Metrics Tracked
  // - process_group_publish_total (counter)
  // - process_group_publish_duration_seconds (histogram)
  // - process_group_fanout_size (histogram - how many members)
  // - process_group_delivery_failures_total (counter)
  rpc PublishToGroup(PublishToGroupRequest) returns (PublishToGroupResponse) {
    option (google.api.http) = {
      post: "/v1/process-groups/{group_name}/publish"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Publish to Group"
      description: "Broadcast message to all group members"
      tags: "ProcessGroups"
    };
  }
}

// ============================================================================
// PROCESS GROUP MESSAGES
// ============================================================================

// Process group metadata
//
// ## Purpose
// Represents a named group of actors for pub/sub coordination.
//
// ## Why This Exists
// - Groups are the fundamental unit for broadcast messaging
// - Enables discovery (what groups exist?)
// - Tracks group metadata (creation time, member count)
//
// ## Storage
// Stored in KeyValueStore with key format: `tenant:{tenant_id}:group:{group_name}`
message ProcessGroup {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "ProcessGroup"
      description: "Named group of actors for pub/sub coordination"
      required: [
        "group_name",
        "tenant_id"
      ]
    }
  };

  // Unique group name (within tenant + namespace)
  //
  // Format: lowercase alphanumeric + hyphens + underscores
  // Example: "config-updates", "user_events", "cluster-nodes"
  string group_name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Group identifier"
      example: "\"config-updates\""
    }
  ];

  // Tenant ID for multi-tenancy isolation
  string tenant_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Tenant identifier"
      example: "\"customer-acme\""
    }
  ];

  // Namespace for hierarchical isolation within tenant
  string namespace = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Namespace within tenant"
    example: "\"production\""
  }];

  // Actor IDs currently in this group
  //
  // NOTE: Not populated in ListGroups response (use GetMembers for member list)
  repeated string member_ids = 4 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {description: "Current group members"}
  ];

  // Number of members in group (across all nodes)
  uint32 member_count = 5 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {description: "Total member count"}
  ];

  // Group metadata (labels, annotations, creation time)
  plexspaces.common.v1.Metadata metadata = 6;

  // When group was created
  google.protobuf.Timestamp created_at = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Group membership entry (internal storage representation)
//
// ## Purpose
// Tracks individual actor membership in a group with join_count for multiple joins.
//
// ## Why This Exists
// - Erlang pg2 allows multiple joins (must leave equally)
// - Tracks which node hosts each member (for routing optimization)
// - Enables fast local vs remote member filtering
//
// ## Storage
// Stored in KeyValueStore with key format:
// `tenant:{tenant_id}:group:{group_name}:member:{actor_id}`
message GroupMembership {
  // Group name
  string group_name = 1;

  // Tenant ID
  string tenant_id = 2;

  // Actor ID in this group
  string actor_id = 3;

  // Node hosting this actor (for routing optimization)
  string node_id = 4;

  // How many times actor joined this group
  //
  // Semantics:
  // - Incremented on each JoinGroup call
  // - Decremented on each LeaveGroup call
  // - Actor fully removed when join_count reaches 0
  int32 join_count = 5;

  // Topics this actor is subscribed to within the group (Erlang pg2 pub/sub pattern)
  //
  // ## Purpose
  // Enables topic-based filtering within a group.
  // Actor only receives messages published to topics they're subscribed to.
  //
  // ## Semantics
  // - Empty list means actor receives all messages (no topic filtering)
  // - Non-empty list means actor only receives messages for subscribed topics
  // - Topics are hierarchical (e.g., "config.database", "events.user.login")
  // - Actor can subscribe to multiple topics within same group
  //
  // ## Examples
  // - ["config.database", "config.cache"] → receives database and cache config updates
  // - ["events.user.*"] → receives all user events (wildcard support, future)
  // - [] → receives all messages regardless of topic
  repeated string topics = 8;

  // When actor first joined this group
  google.protobuf.Timestamp joined_at = 6;

  // When actor last renewed membership (future: heartbeat tracking)
  google.protobuf.Timestamp last_heartbeat = 7;
}

// ============================================================================
// REQUEST/RESPONSE MESSAGES
// ============================================================================

message CreateGroupRequest {
  // Group name (required)
  string group_name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Unique group name within tenant"
      example: "\"config-updates\""
    }
  ];

  // Tenant ID (required for multi-tenancy isolation)
  string tenant_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      description: "Tenant identifier"
      example: "\"customer-acme\""
    }
  ];

  // Namespace (optional hierarchical isolation)
  string namespace = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Namespace within tenant"
    example: "\"production\""
  }];

  // Metadata (labels, annotations)
  plexspaces.common.v1.Metadata metadata = 4;
}

message CreateGroupResponse {
  // Created group
  ProcessGroup group = 1;
}

message DeleteGroupRequest {
  // Group name to delete
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID (for security - prevent cross-tenant deletion)
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];
}

message JoinGroupRequest {
  // Group to join
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];

  // Actor ID to add to group
  string actor_id = 3 [(google.api.field_behavior) = REQUIRED];

  // Node hosting this actor (optional - can be looked up via ActorRegistry)
  string node_id = 4;

  // Topics to subscribe to within the group (optional - empty = all topics)
  //
  // ## Purpose
  // Enables topic-based pub/sub filtering (Erlang pg2 pattern).
  // Actor only receives messages published to subscribed topics.
  //
  // ## Semantics
  // - Empty list: Actor receives all messages (no filtering)
  // - Non-empty list: Actor only receives messages for specified topics
  // - Topics are hierarchical (e.g., "config.database", "events.user.login")
  // - Actor can subscribe to multiple topics in single join call
  //
  // ## Examples
  // - ["config.database"] → only database config updates
  // - ["events.user.login", "events.user.logout"] → only user login/logout events
  // - [] → all messages (default)
  repeated string topics = 5;
}

message LeaveGroupRequest {
  // Group to leave
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];

  // Actor ID to remove from group
  string actor_id = 3 [(google.api.field_behavior) = REQUIRED];
}

message GetMembersRequest {
  // Group name
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];

  // Pagination (optional)
  int32 page_size = 3;
  string page_token = 4;
}

message GetMembersResponse {
  // All members (cluster-wide)
  repeated string member_ids = 1;

  // Pagination
  string next_page_token = 2;
  int32 total_count = 3;
}

message GetLocalMembersRequest {
  // Group name
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];
}

message GetLocalMembersResponse {
  // Local members only (this node)
  repeated string member_ids = 1;

  // Total count (local only)
  int32 local_count = 2;
}

message ListGroupsRequest {
  // Filter by tenant (required - prevents cross-tenant access)
  string tenant_id = 1 [(google.api.field_behavior) = REQUIRED];

  // Filter by namespace (optional)
  string namespace = 2;

  // Filter by group name pattern (optional, e.g., "config-*")
  string name_pattern = 3;

  // Pagination
  int32 page_size = 4;
  string page_token = 5;
}

message ListGroupsResponse {
  // Groups matching filter
  repeated ProcessGroup groups = 1;

  // Pagination
  string next_page_token = 2;
  int32 total_count = 3;
}

message PublishToGroupRequest {
  // Group to publish to
  string group_name = 1 [(google.api.field_behavior) = REQUIRED];

  // Tenant ID (for security - prevent cross-tenant publishing)
  string tenant_id = 2 [(google.api.field_behavior) = REQUIRED];

  // Topic within the group (optional - if not specified, publishes to all members)
  //
  // ## Purpose
  // Enables topic-based pub/sub within a group (Erlang pg2 pattern).
  // Actors can subscribe to specific topics within a group.
  //
  // ## Semantics
  // - If topic is empty, message is broadcast to all group members
  // - If topic is specified, only members subscribed to that topic receive the message
  // - Topics are hierarchical (e.g., "config.database", "events.user.login")
  // - Topic matching supports wildcards (future: "*", "config.*")
  //
  // ## Examples
  // - group_name="config-updates", topic="database" → only database config subscribers
  // - group_name="events", topic="user.login" → only user login event subscribers
  // - group_name="events", topic="" → all event subscribers
  string topic = 4 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
    description: "Topic within group (optional - empty = all members)"
    example: "\"config.database\""
  }];

  // Message to broadcast to all members
  //
  // Uses existing Message type from actor_runtime.proto:
  // - sender_id: Actor publishing the message
  // - receiver_id: Will be set to each member's actor_id
  // - message_type: Type of broadcast (e.g., "config_update", "event")
  // - payload: Message content
  // - priority: Message priority (system=75, high=50, normal=25, low=0)
  // - ttl: How long to retry failed deliveries
  plexspaces.actor.v1.Message message = 3 [(google.api.field_behavior) = REQUIRED];
}

message PublishToGroupResponse {
  // How many members received the message
  //
  // NOTE: This is best-effort count (async delivery)
  // - Local members: Counted immediately
  // - Remote members: May still be in-flight
  uint32 recipients_count = 1;

  // How many members were unreachable
  uint32 failures_count = 2;

  // Breakdown by node (for debugging)
  map<string, uint32> recipients_per_node = 3;
}
