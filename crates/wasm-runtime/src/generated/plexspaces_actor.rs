// Generated by `wit-bindgen` 0.24.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod plexspaces {
  #[allow(dead_code)]
  pub mod actor {
    #[allow(dead_code, clippy::all)]
    pub mod logging {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// Log levels following standard severity
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum LogLevel {
        /// Finest-grained information
        Trace,
        /// Debugging information
        Debug,
        /// Informational messages
        Info,
        /// Warning conditions
        Warn,
        /// Error conditions
        Error,
      }
      impl ::core::fmt::Debug for LogLevel {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            LogLevel::Trace => {
              f.debug_tuple("LogLevel::Trace").finish()
            }
            LogLevel::Debug => {
              f.debug_tuple("LogLevel::Debug").finish()
            }
            LogLevel::Info => {
              f.debug_tuple("LogLevel::Info").finish()
            }
            LogLevel::Warn => {
              f.debug_tuple("LogLevel::Warn").finish()
            }
            LogLevel::Error => {
              f.debug_tuple("LogLevel::Error").finish()
            }
          }
        }
      }

      impl LogLevel{
        pub(crate) unsafe fn _lift(val: u8) -> LogLevel{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => LogLevel::Trace,
            1 => LogLevel::Debug,
            2 => LogLevel::Info,
            3 => LogLevel::Warn,
            4 => LogLevel::Error,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Log a message at specified level
      ///
      /// # Arguments
      /// - `level`: Severity level
      /// - `message`: Log message (may contain structured data)
      ///
      /// # Example
      /// ```
      /// logging::log(LogLevel::Info, "Processing order");
      /// logging::log(LogLevel::Error, &format!("Failed: {}", err));
      /// ```
      pub fn log(level: LogLevel,message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "log"]
            fn wit_import(_: i32, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(level.clone() as i32, ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Log with structured fields
      ///
      /// # Arguments
      /// - `level`: Severity level
      /// - `message`: Log message
      /// - `fields`: Key-value pairs for structured logging
      ///
      /// # Example
      /// ```
      /// logging::log_with_fields(
      /// LogLevel::Info,
      /// "Order processed",
      /// vec![("order_id", "12345"), ("amount", "99.99")]
      /// );
      /// ```
      pub fn log_with_fields(level: LogLevel,message: &str,fields: &[(_rt::String,_rt::String,)],){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec4 = fields;
          let len4 = vec4.len();
          let layout4 = _rt::alloc::Layout::from_size_align_unchecked(vec4.len() * 16, 4);
          let result4 = if layout4.size() != 0 {
            let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout4);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec4.into_iter().enumerate() {
            let base = result4.add(i * 16);
            {
              let (t1_0, t1_1, ) = e;
              let vec2 = t1_0;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(4).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let vec3 = t1_1;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *base.add(12).cast::<usize>() = len3;
              *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
            }
          }

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "log-with-fields"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(level.clone() as i32, ptr0.cast_mut(), len0, result4, len4);
          if layout4.size() != 0 {
            _rt::alloc::dealloc(result4.cast(), layout4);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Convenience: Log at TRACE level
      pub fn trace(message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "trace"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Convenience: Log at DEBUG level
      pub fn debug(message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "debug"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Convenience: Log at INFO level
      pub fn info(message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "info"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Convenience: Log at WARN level
      pub fn warn(message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "warn"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Convenience: Log at ERROR level
      pub fn error(message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "error"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Create a span for distributed tracing
      ///
      /// # Arguments
      /// - `name`: Span name
      ///
      /// # Returns
      /// Span ID that should be passed to `end-span`
      ///
      /// # Example
      /// ```
      /// let span = logging::start_span("process_payment");
      /// // ... do work ...
      /// logging::end_span(span);
      /// ```
      pub fn start_span(name: &str,) -> u64{
        unsafe {
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "start-span"]
            fn wit_import(_: *mut u8, _: usize, ) -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ) -> i64{ unreachable!() }
          let ret = wit_import(ptr0.cast_mut(), len0);
          ret as u64
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// End a tracing span
      ///
      /// # Arguments
      /// - `span-id`: ID returned from `start-span`
      pub fn end_span(span_id: u64,){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "end-span"]
            fn wit_import(_: i64, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, ){ unreachable!() }
          wit_import(_rt::as_i64(&span_id));
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Add event to current span
      ///
      /// # Arguments
      /// - `name`: Event name
      /// - `attributes`: Event attributes
      pub fn add_span_event(name: &str,attributes: &[(_rt::String,_rt::String,)],){
        unsafe {
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec4 = attributes;
          let len4 = vec4.len();
          let layout4 = _rt::alloc::Layout::from_size_align_unchecked(vec4.len() * 16, 4);
          let result4 = if layout4.size() != 0 {
            let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout4);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec4.into_iter().enumerate() {
            let base = result4.add(i * 16);
            {
              let (t1_0, t1_1, ) = e;
              let vec2 = t1_0;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(4).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let vec3 = t1_1;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *base.add(12).cast::<usize>() = len3;
              *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
            }
          }

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/logging@0.1.0")]
          extern "C" {
            #[link_name = "add-span-event"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result4, len4);
          if layout4.size() != 0 {
            _rt::alloc::dealloc(result4.cast(), layout4);
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// Actor identifier - format: "name@node" or ULID
      /// Examples: "counter@node-1", "01ARZ3NDEKTSV4RRFFQ69G5FAV"
      pub type ActorId = _rt::String;
      /// Message payload - opaque bytes for maximum flexibility
      /// Actors choose their own serialization (JSON, protobuf, msgpack, etc.)
      pub type Payload = _rt::Vec::<u8>;
      /// Correlation ID for request-reply patterns
      pub type CorrelationId = _rt::String;
      /// Message ID for tracking and deduplication
      pub type MessageId = _rt::String;
      /// Duration in milliseconds
      pub type DurationMs = u64;
      /// Tuple field - heterogeneous value type for tuplespace
      #[derive(Clone)]
      pub enum TupleField {
        /// String value
        StringVal(_rt::String),
        /// 64-bit signed integer
        IntVal(i64),
        /// 64-bit floating point
        FloatVal(f64),
        /// Raw bytes
        BytesVal(_rt::Vec::<u8>),
        /// Boolean
        BoolVal(bool),
        /// Null/None value
        NullVal,
      }
      impl ::core::fmt::Debug for TupleField {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            TupleField::StringVal(e) => {
              f.debug_tuple("TupleField::StringVal").field(e).finish()
            }
            TupleField::IntVal(e) => {
              f.debug_tuple("TupleField::IntVal").field(e).finish()
            }
            TupleField::FloatVal(e) => {
              f.debug_tuple("TupleField::FloatVal").field(e).finish()
            }
            TupleField::BytesVal(e) => {
              f.debug_tuple("TupleField::BytesVal").field(e).finish()
            }
            TupleField::BoolVal(e) => {
              f.debug_tuple("TupleField::BoolVal").field(e).finish()
            }
            TupleField::NullVal => {
              f.debug_tuple("TupleField::NullVal").finish()
            }
          }
        }
      }
      /// Tuple - ordered collection of fields
      pub type TupleData = _rt::Vec::<TupleField>;
      /// Field type enumeration for type-based matching
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum FieldType {
        StringType,
        IntType,
        FloatType,
        BytesType,
        BoolType,
        NullType,
        TupleType,
      }
      impl ::core::fmt::Debug for FieldType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            FieldType::StringType => {
              f.debug_tuple("FieldType::StringType").finish()
            }
            FieldType::IntType => {
              f.debug_tuple("FieldType::IntType").finish()
            }
            FieldType::FloatType => {
              f.debug_tuple("FieldType::FloatType").finish()
            }
            FieldType::BytesType => {
              f.debug_tuple("FieldType::BytesType").finish()
            }
            FieldType::BoolType => {
              f.debug_tuple("FieldType::BoolType").finish()
            }
            FieldType::NullType => {
              f.debug_tuple("FieldType::NullType").finish()
            }
            FieldType::TupleType => {
              f.debug_tuple("FieldType::TupleType").finish()
            }
          }
        }
      }

      impl FieldType{
        pub(crate) unsafe fn _lift(val: u8) -> FieldType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => FieldType::StringType,
            1 => FieldType::IntType,
            2 => FieldType::FloatType,
            3 => FieldType::BytesType,
            4 => FieldType::BoolType,
            5 => FieldType::NullType,
            6 => FieldType::TupleType,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Pattern field for tuple matching
      #[derive(Clone)]
      pub enum PatternField {
        /// Match exact value
        Exact(TupleField),
        /// Match any value (wildcard)
        Any,
        /// Match by type constraint
        Typed(FieldType),
        /// Match with predicate (encoded as string, e.g., ">10", "startsWith:foo")
        Predicate(_rt::String),
      }
      impl ::core::fmt::Debug for PatternField {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PatternField::Exact(e) => {
              f.debug_tuple("PatternField::Exact").field(e).finish()
            }
            PatternField::Any => {
              f.debug_tuple("PatternField::Any").finish()
            }
            PatternField::Typed(e) => {
              f.debug_tuple("PatternField::Typed").field(e).finish()
            }
            PatternField::Predicate(e) => {
              f.debug_tuple("PatternField::Predicate").field(e).finish()
            }
          }
        }
      }
      /// Pattern for tuple matching
      pub type Pattern = _rt::Vec::<PatternField>;
      /// Standard error codes
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum ErrorCode {
        /// Unknown/unspecified error
        Unknown,
        /// Actor not found
        ActorNotFound,
        /// Message delivery failed
        DeliveryFailed,
        /// Timeout waiting for response
        Timeout,
        /// Invalid message format
        InvalidMessage,
        /// Operation not permitted
        NotPermitted,
        /// Resource exhausted (mailbox full, memory limit, etc.)
        ResourceExhausted,
        /// Internal error
        Internal,
        /// Not implemented
        NotImplemented,
      }
      impl ::core::fmt::Debug for ErrorCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ErrorCode::Unknown => {
              f.debug_tuple("ErrorCode::Unknown").finish()
            }
            ErrorCode::ActorNotFound => {
              f.debug_tuple("ErrorCode::ActorNotFound").finish()
            }
            ErrorCode::DeliveryFailed => {
              f.debug_tuple("ErrorCode::DeliveryFailed").finish()
            }
            ErrorCode::Timeout => {
              f.debug_tuple("ErrorCode::Timeout").finish()
            }
            ErrorCode::InvalidMessage => {
              f.debug_tuple("ErrorCode::InvalidMessage").finish()
            }
            ErrorCode::NotPermitted => {
              f.debug_tuple("ErrorCode::NotPermitted").finish()
            }
            ErrorCode::ResourceExhausted => {
              f.debug_tuple("ErrorCode::ResourceExhausted").finish()
            }
            ErrorCode::Internal => {
              f.debug_tuple("ErrorCode::Internal").finish()
            }
            ErrorCode::NotImplemented => {
              f.debug_tuple("ErrorCode::NotImplemented").finish()
            }
          }
        }
      }

      impl ErrorCode{
        pub(crate) unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => ErrorCode::Unknown,
            1 => ErrorCode::ActorNotFound,
            2 => ErrorCode::DeliveryFailed,
            3 => ErrorCode::Timeout,
            4 => ErrorCode::InvalidMessage,
            5 => ErrorCode::NotPermitted,
            6 => ErrorCode::ResourceExhausted,
            7 => ErrorCode::Internal,
            8 => ErrorCode::NotImplemented,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Structured error type
      #[derive(Clone)]
      pub struct ActorError {
        /// Error code for programmatic handling
        pub code: ErrorCode,
        /// Human-readable message
        pub message: _rt::String,
        /// Optional details (JSON-encoded)
        pub details: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for ActorError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ActorError").field("code", &self.code).field("message", &self.message).field("details", &self.details).finish()
        }
      }
      impl ::core::fmt::Display for ActorError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl std::error::Error for ActorError {}
      /// Generic result with payload
      #[derive(Clone)]
      pub enum ActorResult {
        Ok(Payload),
        Err(ActorError),
      }
      impl ::core::fmt::Debug for ActorResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ActorResult::Ok(e) => {
              f.debug_tuple("ActorResult::Ok").field(e).finish()
            }
            ActorResult::Err(e) => {
              f.debug_tuple("ActorResult::Err").field(e).finish()
            }
          }
        }
      }
      /// Actor spawn options
      #[derive(Clone)]
      pub struct SpawnOptions {
        /// Custom actor ID (optional, will be generated if not provided)
        pub actor_id: Option<ActorId>,
        /// Labels for actor discovery
        pub labels: _rt::Vec::<(_rt::String,_rt::String,)>,
        /// Maximum mailbox size
        pub mailbox_size: Option<u32>,
        /// Enable durability (journaling)
        pub durable: bool,
        /// Supervisor ID (for supervision tree)
        pub supervisor: Option<ActorId>,
      }
      impl ::core::fmt::Debug for SpawnOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SpawnOptions").field("actor-id", &self.actor_id).field("labels", &self.labels).field("mailbox-size", &self.mailbox_size).field("durable", &self.durable).field("supervisor", &self.supervisor).finish()
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod messaging {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type ActorId = super::super::super::plexspaces::actor::types::ActorId;
      pub type Payload = super::super::super::plexspaces::actor::types::Payload;
      pub type MessageId = super::super::super::plexspaces::actor::types::MessageId;
      pub type CorrelationId = super::super::super::plexspaces::actor::types::CorrelationId;
      pub type DurationMs = super::super::super::plexspaces::actor::types::DurationMs;
      pub type SpawnOptions = super::super::super::plexspaces::actor::types::SpawnOptions;
      pub type ActorError = super::super::super::plexspaces::actor::types::ActorError;
      #[allow(unused_unsafe, clippy::all)]
      /// Send message to actor (fire-and-forget)
      ///
      /// Message is delivered asynchronously. No guarantee of delivery
      /// unless durability is enabled on the target actor.
      ///
      /// # Arguments
      /// - `to`: Target actor ID
      /// - `msg-type`: Message type for behavior routing
      /// - `payload`: Message payload bytes
      ///
      /// # Returns
      /// - `ok(message-id)`: Message accepted for delivery
      /// - `err`: Delivery failed (actor not found, mailbox full)
      ///
      /// # Example (Rust)
      /// ```rust
      /// // Fire-and-forget notification
      /// messaging::tell("logger@node-1", "log", b"User logged in")?;
      /// ```
      pub fn tell(to: &ActorId,msg_type: &str,payload: &Payload,) -> Result<MessageId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = to;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "tell"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(4).cast::<*mut u8>();
                let l6 = *ptr3.add(8).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr3.add(4).cast::<u8>());
                let l9 = *ptr3.add(8).cast::<*mut u8>();
                let l10 = *ptr3.add(12).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                let l12 = i32::from(*ptr3.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l8 as u8),
                  message: _rt::string_lift(bytes11),
                  details: match l12 {
                    0 => None,
                    1 => {
                      let e = {
                        let l13 = *ptr3.add(20).cast::<*mut u8>();
                        let l14 = *ptr3.add(24).cast::<usize>();
                        let len15 = l14;
                        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                        _rt::string_lift(bytes15)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send message and wait for reply (request-reply)
      ///
      /// Blocks until response received or timeout expires.
      /// Target actor's `handle-request` or `handle-message` must return response.
      ///
      /// # Arguments
      /// - `to`: Target actor ID
      /// - `msg-type`: Message type for behavior routing
      /// - `payload`: Request payload bytes
      /// - `timeout-ms`: Maximum time to wait (0 = default timeout)
      ///
      /// # Returns
      /// - `ok(payload)`: Response from target actor
      /// - `err`: Request failed (timeout, actor error, etc.)
      ///
      /// # Example (Rust)
      /// ```rust
      /// // Request current count from counter actor
      /// let response = messaging::ask("counter@node-1", "get", &[], 5000)?;
      /// let count = i64::from_le_bytes(response.try_into().unwrap());
      /// ```
      pub fn ask(to: &ActorId,msg_type: &str,payload: &Payload,timeout_ms: DurationMs,) -> Result<Payload,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = to;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "ask"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, _rt::as_i64(timeout_ms), ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(4).cast::<*mut u8>();
                let l6 = *ptr3.add(8).cast::<usize>();
                let len7 = l6;

                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr3.add(4).cast::<u8>());
                let l9 = *ptr3.add(8).cast::<*mut u8>();
                let l10 = *ptr3.add(12).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                let l12 = i32::from(*ptr3.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l8 as u8),
                  message: _rt::string_lift(bytes11),
                  details: match l12 {
                    0 => None,
                    1 => {
                      let e = {
                        let l13 = *ptr3.add(20).cast::<*mut u8>();
                        let l14 = *ptr3.add(24).cast::<usize>();
                        let len15 = l14;
                        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                        _rt::string_lift(bytes15)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Reply to a request (used inside handle-request)
      ///
      /// Sends response back to the actor that called `ask`.
      /// Only valid when processing a "call" message.
      ///
      /// # Arguments
      /// - `correlation-id`: From the incoming message
      /// - `payload`: Response payload bytes
      ///
      /// # Returns
      /// - `ok`: Reply sent
      /// - `err`: Reply failed (invalid correlation, requester gone)
      pub fn reply(correlation_id: &CorrelationId,payload: &Payload,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = correlation_id;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = payload;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "reply"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr2.add(4).cast::<u8>());
                let l5 = *ptr2.add(8).cast::<*mut u8>();
                let l6 = *ptr2.add(12).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = i32::from(*ptr2.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l4 as u8),
                  message: _rt::string_lift(bytes7),
                  details: match l8 {
                    0 => None,
                    1 => {
                      let e = {
                        let l9 = *ptr2.add(20).cast::<*mut u8>();
                        let l10 = *ptr2.add(24).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Forward message to another actor
      ///
      /// Preserves original sender and correlation ID.
      /// Useful for router/proxy actors.
      ///
      /// # Arguments
      /// - `to`: Target actor ID
      /// - `msg-type`: Message type (can be changed)
      /// - `payload`: Message payload
      /// - `original-sender`: Original sender to preserve
      /// - `correlation-id`: Original correlation ID to preserve
      pub fn forward(to: &ActorId,msg_type: &str,payload: &Payload,original_sender: &ActorId,correlation_id: Option<&CorrelationId>,) -> Result<MessageId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = to;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let vec3 = original_sender;
          let ptr3 = vec3.as_ptr().cast::<u8>();
          let len3 = vec3.len();
          let (result5_0,result5_1,result5_2,) = match correlation_id {
            Some(e) => {
              let vec4 = e;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();

              (1i32, ptr4.cast_mut(), len4)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "forward"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, ptr3.cast_mut(), len3, result5_0, result5_1, result5_2, ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          match l7 {
            0 => {
              let e = {
                let l8 = *ptr6.add(4).cast::<*mut u8>();
                let l9 = *ptr6.add(8).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                _rt::string_lift(bytes10)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l11 = i32::from(*ptr6.add(4).cast::<u8>());
                let l12 = *ptr6.add(8).cast::<*mut u8>();
                let l13 = *ptr6.add(12).cast::<usize>();
                let len14 = l13;
                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                let l15 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l11 as u8),
                  message: _rt::string_lift(bytes14),
                  details: match l15 {
                    0 => None,
                    1 => {
                      let e = {
                        let l16 = *ptr6.add(20).cast::<*mut u8>();
                        let l17 = *ptr6.add(24).cast::<usize>();
                        let len18 = l17;
                        let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                        _rt::string_lift(bytes18)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Spawn a new actor
      ///
      /// Creates new actor instance from WASM module.
      /// Module must be deployed to the node.
      ///
      /// # Arguments
      /// - `module-ref`: Module reference (name@version or hash)
      /// - `initial-state`: State bytes passed to actor's init()
      /// - `options`: Spawn configuration
      ///
      /// # Returns
      /// - `ok(actor-id)`: New actor's ID
      /// - `err`: Spawn failed (module not found, resource limit)
      ///
      /// # Example (Rust)
      /// ```rust
      /// let opts = SpawnOptions {
      /// actor_id: Some("worker-1".into()),
      /// labels: vec![("role".into(), "worker".into())],
      /// durable: true,
      /// ..Default::default()
      /// };
      /// let worker = messaging::spawn("worker@1.0.0", &[], opts)?;
      /// ```
      pub fn spawn(module_ref: &str,initial_state: &Payload,options: &SpawnOptions,) -> Result<ActorId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = module_ref;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = initial_state;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let super::super::super::plexspaces::actor::types::SpawnOptions{ actor_id:actor_id2, labels:labels2, mailbox_size:mailbox_size2, durable:durable2, supervisor:supervisor2, } = options;
          let (result4_0,result4_1,result4_2,) = match actor_id2 {
            Some(e) => {
              let vec3 = e;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();

              (1i32, ptr3.cast_mut(), len3)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let vec8 = labels2;
          let len8 = vec8.len();
          let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 16, 4);
          let result8 = if layout8.size() != 0 {
            let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout8);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec8.into_iter().enumerate() {
            let base = result8.add(i * 16);
            {
              let (t5_0, t5_1, ) = e;
              let vec6 = t5_0;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(4).cast::<usize>() = len6;
              *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
              let vec7 = t5_1;
              let ptr7 = vec7.as_ptr().cast::<u8>();
              let len7 = vec7.len();
              *base.add(12).cast::<usize>() = len7;
              *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
            }
          }
          let (result9_0,result9_1,) = match mailbox_size2 {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let (result11_0,result11_1,result11_2,) = match supervisor2 {
            Some(e) => {
              let vec10 = e;
              let ptr10 = vec10.as_ptr().cast::<u8>();
              let len10 = vec10.len();

              (1i32, ptr10.cast_mut(), len10)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr12 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "spawn"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, result4_0, result4_1, result4_2, result8, len8, result9_0, result9_1, match durable2 { true => 1, false => 0 }, result11_0, result11_1, result11_2, ptr12);
          let l13 = i32::from(*ptr12.add(0).cast::<u8>());
          if layout8.size() != 0 {
            _rt::alloc::dealloc(result8.cast(), layout8);
          }
          match l13 {
            0 => {
              let e = {
                let l14 = *ptr12.add(4).cast::<*mut u8>();
                let l15 = *ptr12.add(8).cast::<usize>();
                let len16 = l15;
                let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                _rt::string_lift(bytes16)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l17 = i32::from(*ptr12.add(4).cast::<u8>());
                let l18 = *ptr12.add(8).cast::<*mut u8>();
                let l19 = *ptr12.add(12).cast::<usize>();
                let len20 = l19;
                let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);
                let l21 = i32::from(*ptr12.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l17 as u8),
                  message: _rt::string_lift(bytes20),
                  details: match l21 {
                    0 => None,
                    1 => {
                      let e = {
                        let l22 = *ptr12.add(20).cast::<*mut u8>();
                        let l23 = *ptr12.add(24).cast::<usize>();
                        let len24 = l23;
                        let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                        _rt::string_lift(bytes24)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Stop an actor gracefully
      ///
      /// Sends shutdown signal to actor. Actor's `shutdown` function is called.
      /// Waits for actor to terminate up to timeout.
      ///
      /// # Arguments
      /// - `actor-id`: Actor to stop
      /// - `timeout-ms`: Maximum time to wait for graceful shutdown
      ///
      /// # Returns
      /// - `ok`: Actor stopped
      /// - `err`: Stop failed (actor not found, timeout)
      pub fn stop(actor_id: &ActorId,timeout_ms: DurationMs,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = actor_id;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "stop"]
            fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, _rt::as_i64(timeout_ms), ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                let l4 = *ptr1.add(8).cast::<*mut u8>();
                let l5 = *ptr1.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr1.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr1.add(20).cast::<*mut u8>();
                        let l9 = *ptr1.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Link to another actor (Erlang-style)
      ///
      /// When linked actor terminates, this actor receives EXIT message.
      /// Links are bidirectional.
      ///
      /// # Arguments
      /// - `actor-id`: Actor to link with
      pub fn link(actor_id: &ActorId,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = actor_id;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "link"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                let l4 = *ptr1.add(8).cast::<*mut u8>();
                let l5 = *ptr1.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr1.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr1.add(20).cast::<*mut u8>();
                        let l9 = *ptr1.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Unlink from another actor
      pub fn unlink(actor_id: &ActorId,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = actor_id;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "unlink"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                let l4 = *ptr1.add(8).cast::<*mut u8>();
                let l5 = *ptr1.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr1.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr1.add(20).cast::<*mut u8>();
                        let l9 = *ptr1.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Monitor another actor (one-way)
      ///
      /// When monitored actor terminates, this actor receives DOWN message.
      /// Monitors are unidirectional (unlike links).
      ///
      /// # Arguments
      /// - `actor-id`: Actor to monitor
      ///
      /// # Returns
      /// - `ok(monitor-ref)`: Reference to cancel monitor
      /// - `err`: Monitor failed
      pub fn monitor(actor_id: &ActorId,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec0 = actor_id;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "monitor"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(8).cast::<i64>();

                l3 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(8).cast::<u8>());
                let l5 = *ptr1.add(12).cast::<*mut u8>();
                let l6 = *ptr1.add(16).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = i32::from(*ptr1.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l4 as u8),
                  message: _rt::string_lift(bytes7),
                  details: match l8 {
                    0 => None,
                    1 => {
                      let e = {
                        let l9 = *ptr1.add(24).cast::<*mut u8>();
                        let l10 = *ptr1.add(28).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Cancel a monitor
      pub fn demonitor(monitor_ref: u64,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "demonitor"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&monitor_ref), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l3 = *ptr0.add(8).cast::<*mut u8>();
                let l4 = *ptr0.add(12).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l2 as u8),
                  message: _rt::string_lift(bytes5),
                  details: match l6 {
                    0 => None,
                    1 => {
                      let e = {
                        let l7 = *ptr0.add(20).cast::<*mut u8>();
                        let l8 = *ptr0.add(24).cast::<usize>();
                        let len9 = l8;
                        let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                        _rt::string_lift(bytes9)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get current actor's ID
      pub fn self_id() -> ActorId{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "self-id"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let len3 = l2;
          let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
          _rt::string_lift(bytes3)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get parent/supervisor actor ID (if any)
      pub fn parent_id() -> Option<ActorId>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "parent-id"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let len4 = l3;
                let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                _rt::string_lift(bytes4)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get current timestamp (milliseconds since epoch)
      pub fn now() -> u64{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "now"]
            fn wit_import() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i64{ unreachable!() }
          let ret = wit_import();
          ret as u64
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Sleep for duration
      ///
      /// Yields control to runtime. Actor will be resumed after duration.
      /// Other messages may be processed during sleep.
      pub fn sleep(duration_ms: DurationMs,){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "sleep"]
            fn wit_import(_: i64, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, ){ unreachable!() }
          wit_import(_rt::as_i64(duration_ms));
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Schedule message to self after delay
      ///
      /// # Arguments
      /// - `delay-ms`: Delay before message is delivered
      /// - `msg-type`: Message type
      /// - `payload`: Message payload
      ///
      /// # Returns
      /// Timer ID that can be used to cancel
      pub fn send_after(delay_ms: DurationMs,msg_type: &str,payload: &Payload,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec0 = msg_type;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = payload;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "send-after"]
            fn wit_import(_: i64, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(delay_ms), ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(8).cast::<i64>();

                l4 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*ptr2.add(8).cast::<u8>());
                let l6 = *ptr2.add(12).cast::<*mut u8>();
                let l7 = *ptr2.add(16).cast::<usize>();
                let len8 = l7;
                let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                let l9 = i32::from(*ptr2.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l5 as u8),
                  message: _rt::string_lift(bytes8),
                  details: match l9 {
                    0 => None,
                    1 => {
                      let e = {
                        let l10 = *ptr2.add(24).cast::<*mut u8>();
                        let l11 = *ptr2.add(28).cast::<usize>();
                        let len12 = l11;
                        let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                        _rt::string_lift(bytes12)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Cancel a scheduled message
      pub fn cancel_timer(timer_id: u64,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/messaging@0.1.0")]
          extern "C" {
            #[link_name = "cancel-timer"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&timer_id), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l3 = *ptr0.add(8).cast::<*mut u8>();
                let l4 = *ptr0.add(12).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l2 as u8),
                  message: _rt::string_lift(bytes5),
                  details: match l6 {
                    0 => None,
                    1 => {
                      let e = {
                        let l7 = *ptr0.add(20).cast::<*mut u8>();
                        let l8 = *ptr0.add(24).cast::<usize>();
                        let len9 = l8;
                        let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                        _rt::string_lift(bytes9)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod tuplespace {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type TupleData = super::super::super::plexspaces::actor::types::TupleData;
      pub type Pattern = super::super::super::plexspaces::actor::types::Pattern;
      pub type DurationMs = super::super::super::plexspaces::actor::types::DurationMs;
      pub type ActorError = super::super::super::plexspaces::actor::types::ActorError;
      #[allow(unused_unsafe, clippy::all)]
      /// Write tuple to space
      ///
      /// Tuple is stored until taken or TTL expires.
      /// Multiple identical tuples can exist.
      ///
      /// # Arguments
      /// - `tuple`: Tuple to write
      ///
      /// # Returns
      /// - `ok`: Tuple written successfully
      /// - `err`: Write failed
      ///
      /// # Example (Rust)
      /// ```rust
      /// // Write a configuration tuple
      /// let tuple = vec![
      /// TupleField::StringVal("config".into()),
      /// TupleField::StringVal("timeout".into()),
      /// TupleField::IntVal(30),
      /// ];
      /// tuplespace::write(tuple)?;
      /// ```
      pub fn write(tuple_data: &TupleData,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec3 = tuple_data;
          let len3 = vec3.len();
          let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 16, 8);
          let result3 = if layout3.size() != 0 {
            let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3.add(i * 16);
            {
              use super::super::super::plexspaces::actor::types::TupleField as V2;
              match e {
                V2::StringVal(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  let vec0 = e;
                  let ptr0 = vec0.as_ptr().cast::<u8>();
                  let len0 = vec0.len();
                  *base.add(12).cast::<usize>() = len0;
                  *base.add(8).cast::<*mut u8>() = ptr0.cast_mut();
                },
                V2::IntVal(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(8).cast::<i64>() = _rt::as_i64(e);
                },
                V2::FloatVal(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<f64>() = _rt::as_f64(e);
                },
                V2::BytesVal(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();
                  *base.add(12).cast::<usize>() = len1;
                  *base.add(8).cast::<*mut u8>() = ptr1.cast_mut();
                },
                V2::BoolVal(e) => {
                  *base.add(0).cast::<u8>() = (4i32) as u8;
                  *base.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                },
                V2::NullVal=> {
                  {
                    *base.add(0).cast::<u8>() = (5i32) as u8;
                  }
                }
              }
            }
          }
          let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "write"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result3, len3, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          if layout3.size() != 0 {
            _rt::alloc::dealloc(result3.cast(), layout3);
          }
          match l5 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr4.add(4).cast::<u8>());
                let l7 = *ptr4.add(8).cast::<*mut u8>();
                let l8 = *ptr4.add(12).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                let l10 = i32::from(*ptr4.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l6 as u8),
                  message: _rt::string_lift(bytes9),
                  details: match l10 {
                    0 => None,
                    1 => {
                      let e = {
                        let l11 = *ptr4.add(20).cast::<*mut u8>();
                        let l12 = *ptr4.add(24).cast::<usize>();
                        let len13 = l12;
                        let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                        _rt::string_lift(bytes13)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Write tuple with time-to-live
      ///
      /// # Arguments
      /// - `tuple`: Tuple to write
      /// - `ttl-ms`: Time-to-live in milliseconds (0 = infinite)
      pub fn write_with_ttl(tuple_data: &TupleData,ttl_ms: DurationMs,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec3 = tuple_data;
          let len3 = vec3.len();
          let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 16, 8);
          let result3 = if layout3.size() != 0 {
            let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3.add(i * 16);
            {
              use super::super::super::plexspaces::actor::types::TupleField as V2;
              match e {
                V2::StringVal(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  let vec0 = e;
                  let ptr0 = vec0.as_ptr().cast::<u8>();
                  let len0 = vec0.len();
                  *base.add(12).cast::<usize>() = len0;
                  *base.add(8).cast::<*mut u8>() = ptr0.cast_mut();
                },
                V2::IntVal(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(8).cast::<i64>() = _rt::as_i64(e);
                },
                V2::FloatVal(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<f64>() = _rt::as_f64(e);
                },
                V2::BytesVal(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();
                  *base.add(12).cast::<usize>() = len1;
                  *base.add(8).cast::<*mut u8>() = ptr1.cast_mut();
                },
                V2::BoolVal(e) => {
                  *base.add(0).cast::<u8>() = (4i32) as u8;
                  *base.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                },
                V2::NullVal=> {
                  {
                    *base.add(0).cast::<u8>() = (5i32) as u8;
                  }
                }
              }
            }
          }
          let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "write-with-ttl"]
            fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(result3, len3, _rt::as_i64(ttl_ms), ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          if layout3.size() != 0 {
            _rt::alloc::dealloc(result3.cast(), layout3);
          }
          match l5 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr4.add(4).cast::<u8>());
                let l7 = *ptr4.add(8).cast::<*mut u8>();
                let l8 = *ptr4.add(12).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                let l10 = i32::from(*ptr4.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l6 as u8),
                  message: _rt::string_lift(bytes9),
                  details: match l10 {
                    0 => None,
                    1 => {
                      let e = {
                        let l11 = *ptr4.add(20).cast::<*mut u8>();
                        let l12 = *ptr4.add(24).cast::<usize>();
                        let len13 = l12;
                        let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                        _rt::string_lift(bytes13)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read tuple matching pattern (non-destructive)
      ///
      /// Returns first matching tuple without removing it.
      /// Returns immediately if no match found.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      ///
      /// # Returns
      /// - `ok(some(tuple))`: Matching tuple found
      /// - `ok(none)`: No matching tuple
      /// - `err`: Read failed
      ///
      /// # Example (Rust)
      /// ```rust
      /// // Read config tuple
      /// let pattern = vec![
      /// PatternField::Exact(TupleField::StringVal("config".into())),
      /// PatternField::Any,  // Any key
      /// PatternField::Any,  // Any value
      /// ];
      /// if let Some(tuple) = tuplespace::read(pattern)? {
      /// // Process tuple
      /// }
      /// ```
      pub fn read(pattern_data: &Pattern,) -> Result<Option<TupleData>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "read"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = i32::from(*ptr6.add(4).cast::<u8>());

                match l8 {
                  0 => None,
                  1 => {
                    let e = {
                      let l9 = *ptr6.add(8).cast::<*mut u8>();
                      let l10 = *ptr6.add(12).cast::<usize>();
                      let base22 = l9;
                      let len22 = l10;
                      let mut result22 = _rt::Vec::with_capacity(len22);
                      for i in 0..len22 {
                        let base = base22.add(i * 16);
                        let e22 = {
                          let l11 = i32::from(*base.add(0).cast::<u8>());
                          use super::super::super::plexspaces::actor::types::TupleField as V21;
                          let v21 = match l11 {
                            0 => {
                              let e21 = {
                                let l12 = *base.add(8).cast::<*mut u8>();
                                let l13 = *base.add(12).cast::<usize>();
                                let len14 = l13;
                                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                                _rt::string_lift(bytes14)
                              };
                              V21::StringVal(e21)
                            }
                            1 => {
                              let e21 = {
                                let l15 = *base.add(8).cast::<i64>();

                                l15
                              };
                              V21::IntVal(e21)
                            }
                            2 => {
                              let e21 = {
                                let l16 = *base.add(8).cast::<f64>();

                                l16
                              };
                              V21::FloatVal(e21)
                            }
                            3 => {
                              let e21 = {
                                let l17 = *base.add(8).cast::<*mut u8>();
                                let l18 = *base.add(12).cast::<usize>();
                                let len19 = l18;

                                _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                              };
                              V21::BytesVal(e21)
                            }
                            4 => {
                              let e21 = {
                                let l20 = i32::from(*base.add(8).cast::<u8>());

                                _rt::bool_lift(l20 as u8)
                              };
                              V21::BoolVal(e21)
                            }
                            n => {
                              debug_assert_eq!(n, 5, "invalid enum discriminant");
                              V21::NullVal
                            }
                          };

                          v21
                        };
                        result22.push(e22);
                      }
                      _rt::cabi_dealloc(base22, len22 * 16, 8);

                      result22
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l23 = i32::from(*ptr6.add(4).cast::<u8>());
                let l24 = *ptr6.add(8).cast::<*mut u8>();
                let l25 = *ptr6.add(12).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l23 as u8),
                  message: _rt::string_lift(bytes26),
                  details: match l27 {
                    0 => None,
                    1 => {
                      let e = {
                        let l28 = *ptr6.add(20).cast::<*mut u8>();
                        let l29 = *ptr6.add(24).cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                        _rt::string_lift(bytes30)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read tuple with blocking wait
      ///
      /// Blocks until matching tuple found or timeout expires.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      /// - `timeout-ms`: Maximum time to wait (0 = no timeout, wait forever)
      pub fn read_blocking(pattern_data: &Pattern,timeout_ms: DurationMs,) -> Result<Option<TupleData>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "read-blocking"]
            fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, _rt::as_i64(timeout_ms), ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = i32::from(*ptr6.add(4).cast::<u8>());

                match l8 {
                  0 => None,
                  1 => {
                    let e = {
                      let l9 = *ptr6.add(8).cast::<*mut u8>();
                      let l10 = *ptr6.add(12).cast::<usize>();
                      let base22 = l9;
                      let len22 = l10;
                      let mut result22 = _rt::Vec::with_capacity(len22);
                      for i in 0..len22 {
                        let base = base22.add(i * 16);
                        let e22 = {
                          let l11 = i32::from(*base.add(0).cast::<u8>());
                          use super::super::super::plexspaces::actor::types::TupleField as V21;
                          let v21 = match l11 {
                            0 => {
                              let e21 = {
                                let l12 = *base.add(8).cast::<*mut u8>();
                                let l13 = *base.add(12).cast::<usize>();
                                let len14 = l13;
                                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                                _rt::string_lift(bytes14)
                              };
                              V21::StringVal(e21)
                            }
                            1 => {
                              let e21 = {
                                let l15 = *base.add(8).cast::<i64>();

                                l15
                              };
                              V21::IntVal(e21)
                            }
                            2 => {
                              let e21 = {
                                let l16 = *base.add(8).cast::<f64>();

                                l16
                              };
                              V21::FloatVal(e21)
                            }
                            3 => {
                              let e21 = {
                                let l17 = *base.add(8).cast::<*mut u8>();
                                let l18 = *base.add(12).cast::<usize>();
                                let len19 = l18;

                                _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                              };
                              V21::BytesVal(e21)
                            }
                            4 => {
                              let e21 = {
                                let l20 = i32::from(*base.add(8).cast::<u8>());

                                _rt::bool_lift(l20 as u8)
                              };
                              V21::BoolVal(e21)
                            }
                            n => {
                              debug_assert_eq!(n, 5, "invalid enum discriminant");
                              V21::NullVal
                            }
                          };

                          v21
                        };
                        result22.push(e22);
                      }
                      _rt::cabi_dealloc(base22, len22 * 16, 8);

                      result22
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l23 = i32::from(*ptr6.add(4).cast::<u8>());
                let l24 = *ptr6.add(8).cast::<*mut u8>();
                let l25 = *ptr6.add(12).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l23 as u8),
                  message: _rt::string_lift(bytes26),
                  details: match l27 {
                    0 => None,
                    1 => {
                      let e = {
                        let l28 = *ptr6.add(20).cast::<*mut u8>();
                        let l29 = *ptr6.add(24).cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                        _rt::string_lift(bytes30)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read all matching tuples (non-destructive)
      ///
      /// Returns all tuples matching pattern without removing them.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      /// - `limit`: Maximum number of tuples to return (0 = no limit)
      pub fn read_all(pattern_data: &Pattern,limit: u32,) -> Result<_rt::Vec::<TupleData>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "read-all"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, _rt::as_i32(&limit), ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *ptr6.add(4).cast::<*mut u8>();
                let l9 = *ptr6.add(8).cast::<usize>();
                let base24 = l8;
                let len24 = l9;
                let mut result24 = _rt::Vec::with_capacity(len24);
                for i in 0..len24 {
                  let base = base24.add(i * 8);
                  let e24 = {
                    let l10 = *base.add(0).cast::<*mut u8>();
                    let l11 = *base.add(4).cast::<usize>();
                    let base23 = l10;
                    let len23 = l11;
                    let mut result23 = _rt::Vec::with_capacity(len23);
                    for i in 0..len23 {
                      let base = base23.add(i * 16);
                      let e23 = {
                        let l12 = i32::from(*base.add(0).cast::<u8>());
                        use super::super::super::plexspaces::actor::types::TupleField as V22;
                        let v22 = match l12 {
                          0 => {
                            let e22 = {
                              let l13 = *base.add(8).cast::<*mut u8>();
                              let l14 = *base.add(12).cast::<usize>();
                              let len15 = l14;
                              let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                              _rt::string_lift(bytes15)
                            };
                            V22::StringVal(e22)
                          }
                          1 => {
                            let e22 = {
                              let l16 = *base.add(8).cast::<i64>();

                              l16
                            };
                            V22::IntVal(e22)
                          }
                          2 => {
                            let e22 = {
                              let l17 = *base.add(8).cast::<f64>();

                              l17
                            };
                            V22::FloatVal(e22)
                          }
                          3 => {
                            let e22 = {
                              let l18 = *base.add(8).cast::<*mut u8>();
                              let l19 = *base.add(12).cast::<usize>();
                              let len20 = l19;

                              _rt::Vec::from_raw_parts(l18.cast(), len20, len20)
                            };
                            V22::BytesVal(e22)
                          }
                          4 => {
                            let e22 = {
                              let l21 = i32::from(*base.add(8).cast::<u8>());

                              _rt::bool_lift(l21 as u8)
                            };
                            V22::BoolVal(e22)
                          }
                          n => {
                            debug_assert_eq!(n, 5, "invalid enum discriminant");
                            V22::NullVal
                          }
                        };

                        v22
                      };
                      result23.push(e23);
                    }
                    _rt::cabi_dealloc(base23, len23 * 16, 8);

                    result23
                  };
                  result24.push(e24);
                }
                _rt::cabi_dealloc(base24, len24 * 8, 4);

                result24
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l25 = i32::from(*ptr6.add(4).cast::<u8>());
                let l26 = *ptr6.add(8).cast::<*mut u8>();
                let l27 = *ptr6.add(12).cast::<usize>();
                let len28 = l27;
                let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);
                let l29 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l25 as u8),
                  message: _rt::string_lift(bytes28),
                  details: match l29 {
                    0 => None,
                    1 => {
                      let e = {
                        let l30 = *ptr6.add(20).cast::<*mut u8>();
                        let l31 = *ptr6.add(24).cast::<usize>();
                        let len32 = l31;
                        let bytes32 = _rt::Vec::from_raw_parts(l30.cast(), len32, len32);

                        _rt::string_lift(bytes32)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Take tuple matching pattern (destructive)
      ///
      /// Removes and returns first matching tuple.
      /// Returns immediately if no match found.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      ///
      /// # Returns
      /// - `ok(some(tuple))`: Tuple taken
      /// - `ok(none)`: No matching tuple
      /// - `err`: Take failed
      pub fn take(pattern_data: &Pattern,) -> Result<Option<TupleData>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "take"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = i32::from(*ptr6.add(4).cast::<u8>());

                match l8 {
                  0 => None,
                  1 => {
                    let e = {
                      let l9 = *ptr6.add(8).cast::<*mut u8>();
                      let l10 = *ptr6.add(12).cast::<usize>();
                      let base22 = l9;
                      let len22 = l10;
                      let mut result22 = _rt::Vec::with_capacity(len22);
                      for i in 0..len22 {
                        let base = base22.add(i * 16);
                        let e22 = {
                          let l11 = i32::from(*base.add(0).cast::<u8>());
                          use super::super::super::plexspaces::actor::types::TupleField as V21;
                          let v21 = match l11 {
                            0 => {
                              let e21 = {
                                let l12 = *base.add(8).cast::<*mut u8>();
                                let l13 = *base.add(12).cast::<usize>();
                                let len14 = l13;
                                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                                _rt::string_lift(bytes14)
                              };
                              V21::StringVal(e21)
                            }
                            1 => {
                              let e21 = {
                                let l15 = *base.add(8).cast::<i64>();

                                l15
                              };
                              V21::IntVal(e21)
                            }
                            2 => {
                              let e21 = {
                                let l16 = *base.add(8).cast::<f64>();

                                l16
                              };
                              V21::FloatVal(e21)
                            }
                            3 => {
                              let e21 = {
                                let l17 = *base.add(8).cast::<*mut u8>();
                                let l18 = *base.add(12).cast::<usize>();
                                let len19 = l18;

                                _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                              };
                              V21::BytesVal(e21)
                            }
                            4 => {
                              let e21 = {
                                let l20 = i32::from(*base.add(8).cast::<u8>());

                                _rt::bool_lift(l20 as u8)
                              };
                              V21::BoolVal(e21)
                            }
                            n => {
                              debug_assert_eq!(n, 5, "invalid enum discriminant");
                              V21::NullVal
                            }
                          };

                          v21
                        };
                        result22.push(e22);
                      }
                      _rt::cabi_dealloc(base22, len22 * 16, 8);

                      result22
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l23 = i32::from(*ptr6.add(4).cast::<u8>());
                let l24 = *ptr6.add(8).cast::<*mut u8>();
                let l25 = *ptr6.add(12).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l23 as u8),
                  message: _rt::string_lift(bytes26),
                  details: match l27 {
                    0 => None,
                    1 => {
                      let e = {
                        let l28 = *ptr6.add(20).cast::<*mut u8>();
                        let l29 = *ptr6.add(24).cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                        _rt::string_lift(bytes30)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Take tuple with blocking wait
      ///
      /// Blocks until matching tuple found or timeout expires.
      /// Atomically removes the tuple.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      /// - `timeout-ms`: Maximum time to wait (0 = wait forever)
      pub fn take_blocking(pattern_data: &Pattern,timeout_ms: DurationMs,) -> Result<Option<TupleData>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "take-blocking"]
            fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, _rt::as_i64(timeout_ms), ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = i32::from(*ptr6.add(4).cast::<u8>());

                match l8 {
                  0 => None,
                  1 => {
                    let e = {
                      let l9 = *ptr6.add(8).cast::<*mut u8>();
                      let l10 = *ptr6.add(12).cast::<usize>();
                      let base22 = l9;
                      let len22 = l10;
                      let mut result22 = _rt::Vec::with_capacity(len22);
                      for i in 0..len22 {
                        let base = base22.add(i * 16);
                        let e22 = {
                          let l11 = i32::from(*base.add(0).cast::<u8>());
                          use super::super::super::plexspaces::actor::types::TupleField as V21;
                          let v21 = match l11 {
                            0 => {
                              let e21 = {
                                let l12 = *base.add(8).cast::<*mut u8>();
                                let l13 = *base.add(12).cast::<usize>();
                                let len14 = l13;
                                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                                _rt::string_lift(bytes14)
                              };
                              V21::StringVal(e21)
                            }
                            1 => {
                              let e21 = {
                                let l15 = *base.add(8).cast::<i64>();

                                l15
                              };
                              V21::IntVal(e21)
                            }
                            2 => {
                              let e21 = {
                                let l16 = *base.add(8).cast::<f64>();

                                l16
                              };
                              V21::FloatVal(e21)
                            }
                            3 => {
                              let e21 = {
                                let l17 = *base.add(8).cast::<*mut u8>();
                                let l18 = *base.add(12).cast::<usize>();
                                let len19 = l18;

                                _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                              };
                              V21::BytesVal(e21)
                            }
                            4 => {
                              let e21 = {
                                let l20 = i32::from(*base.add(8).cast::<u8>());

                                _rt::bool_lift(l20 as u8)
                              };
                              V21::BoolVal(e21)
                            }
                            n => {
                              debug_assert_eq!(n, 5, "invalid enum discriminant");
                              V21::NullVal
                            }
                          };

                          v21
                        };
                        result22.push(e22);
                      }
                      _rt::cabi_dealloc(base22, len22 * 16, 8);

                      result22
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l23 = i32::from(*ptr6.add(4).cast::<u8>());
                let l24 = *ptr6.add(8).cast::<*mut u8>();
                let l25 = *ptr6.add(12).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = i32::from(*ptr6.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l23 as u8),
                  message: _rt::string_lift(bytes26),
                  details: match l27 {
                    0 => None,
                    1 => {
                      let e = {
                        let l28 = *ptr6.add(20).cast::<*mut u8>();
                        let l29 = *ptr6.add(24).cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                        _rt::string_lift(bytes30)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Count tuples matching pattern
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match
      ///
      /// # Returns
      /// Number of matching tuples
      pub fn count(pattern_data: &Pattern,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "count"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *ptr6.add(8).cast::<i64>();

                l8 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l9 = i32::from(*ptr6.add(8).cast::<u8>());
                let l10 = *ptr6.add(12).cast::<*mut u8>();
                let l11 = *ptr6.add(16).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                let l13 = i32::from(*ptr6.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l9 as u8),
                  message: _rt::string_lift(bytes12),
                  details: match l13 {
                    0 => None,
                    1 => {
                      let e = {
                        let l14 = *ptr6.add(24).cast::<*mut u8>();
                        let l15 = *ptr6.add(28).cast::<usize>();
                        let len16 = l15;
                        let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                        _rt::string_lift(bytes16)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to tuple events
      ///
      /// Receive notifications when tuples matching pattern are written.
      /// Useful for reactive patterns.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to watch
      ///
      /// # Returns
      /// Subscription ID for unsubscribe
      pub fn subscribe(pattern_data: &Pattern,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "subscribe"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, ptr6);
          let l7 = i32::from(*ptr6.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *ptr6.add(8).cast::<i64>();

                l8 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l9 = i32::from(*ptr6.add(8).cast::<u8>());
                let l10 = *ptr6.add(12).cast::<*mut u8>();
                let l11 = *ptr6.add(16).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                let l13 = i32::from(*ptr6.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l9 as u8),
                  message: _rt::string_lift(bytes12),
                  details: match l13 {
                    0 => None,
                    1 => {
                      let e = {
                        let l14 = *ptr6.add(24).cast::<*mut u8>();
                        let l15 = *ptr6.add(28).cast::<usize>();
                        let len16 = l15;
                        let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                        _rt::string_lift(bytes16)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Unsubscribe from tuple events
      pub fn unsubscribe(subscription_id: u64,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "unsubscribe"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&subscription_id), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l3 = *ptr0.add(8).cast::<*mut u8>();
                let l4 = *ptr0.add(12).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l2 as u8),
                  message: _rt::string_lift(bytes5),
                  details: match l6 {
                    0 => None,
                    1 => {
                      let e = {
                        let l7 = *ptr0.add(20).cast::<*mut u8>();
                        let l8 = *ptr0.add(24).cast::<usize>();
                        let len9 = l8;
                        let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                        _rt::string_lift(bytes9)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Atomic compare-and-swap
      ///
      /// Atomically replaces tuple if current value matches expected.
      /// Useful for optimistic concurrency control.
      ///
      /// # Arguments
      /// - `pattern`: Pattern to match current tuple
      /// - `expected`: Expected current tuple (for comparison)
      /// - `new-tuple`: New tuple to write if match succeeds
      ///
      /// # Returns
      /// - `ok(true)`: Swap succeeded
      /// - `ok(false)`: Current value didn't match expected
      /// - `err`: Operation failed
      pub fn compare_and_swap(pattern_data: &Pattern,expected: &TupleData,new_tuple: &TupleData,) -> Result<bool,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec5 = pattern_data;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 24, 8);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 24);
            {
              use super::super::super::plexspaces::actor::types::PatternField as V4;
              match e {
                V4::Exact(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  use super::super::super::plexspaces::actor::types::TupleField as V2;
                  match e {
                    V2::StringVal(e) => {
                      *base.add(8).cast::<u8>() = (0i32) as u8;
                      let vec0 = e;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      *base.add(20).cast::<usize>() = len0;
                      *base.add(16).cast::<*mut u8>() = ptr0.cast_mut();
                    },
                    V2::IntVal(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      *base.add(16).cast::<i64>() = _rt::as_i64(e);
                    },
                    V2::FloatVal(e) => {
                      *base.add(8).cast::<u8>() = (2i32) as u8;
                      *base.add(16).cast::<f64>() = _rt::as_f64(e);
                    },
                    V2::BytesVal(e) => {
                      *base.add(8).cast::<u8>() = (3i32) as u8;
                      let vec1 = e;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      *base.add(20).cast::<usize>() = len1;
                      *base.add(16).cast::<*mut u8>() = ptr1.cast_mut();
                    },
                    V2::BoolVal(e) => {
                      *base.add(8).cast::<u8>() = (4i32) as u8;
                      *base.add(16).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    V2::NullVal=> {
                      {
                        *base.add(8).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                },
                V4::Any=> {
                  {
                    *base.add(0).cast::<u8>() = (1i32) as u8;
                  }
                }
                V4::Typed(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                },
                V4::Predicate(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();
                  *base.add(12).cast::<usize>() = len3;
                  *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                },
              }
            }
          }
          let vec9 = expected;
          let len9 = vec9.len();
          let layout9 = _rt::alloc::Layout::from_size_align_unchecked(vec9.len() * 16, 8);
          let result9 = if layout9.size() != 0 {
            let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout9);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec9.into_iter().enumerate() {
            let base = result9.add(i * 16);
            {
              use super::super::super::plexspaces::actor::types::TupleField as V8;
              match e {
                V8::StringVal(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  let vec6 = e;
                  let ptr6 = vec6.as_ptr().cast::<u8>();
                  let len6 = vec6.len();
                  *base.add(12).cast::<usize>() = len6;
                  *base.add(8).cast::<*mut u8>() = ptr6.cast_mut();
                },
                V8::IntVal(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(8).cast::<i64>() = _rt::as_i64(e);
                },
                V8::FloatVal(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<f64>() = _rt::as_f64(e);
                },
                V8::BytesVal(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *base.add(12).cast::<usize>() = len7;
                  *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                },
                V8::BoolVal(e) => {
                  *base.add(0).cast::<u8>() = (4i32) as u8;
                  *base.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                },
                V8::NullVal=> {
                  {
                    *base.add(0).cast::<u8>() = (5i32) as u8;
                  }
                }
              }
            }
          }
          let vec13 = new_tuple;
          let len13 = vec13.len();
          let layout13 = _rt::alloc::Layout::from_size_align_unchecked(vec13.len() * 16, 8);
          let result13 = if layout13.size() != 0 {
            let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout13);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec13.into_iter().enumerate() {
            let base = result13.add(i * 16);
            {
              use super::super::super::plexspaces::actor::types::TupleField as V12;
              match e {
                V12::StringVal(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  let vec10 = e;
                  let ptr10 = vec10.as_ptr().cast::<u8>();
                  let len10 = vec10.len();
                  *base.add(12).cast::<usize>() = len10;
                  *base.add(8).cast::<*mut u8>() = ptr10.cast_mut();
                },
                V12::IntVal(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(8).cast::<i64>() = _rt::as_i64(e);
                },
                V12::FloatVal(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<f64>() = _rt::as_f64(e);
                },
                V12::BytesVal(e) => {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                  let vec11 = e;
                  let ptr11 = vec11.as_ptr().cast::<u8>();
                  let len11 = vec11.len();
                  *base.add(12).cast::<usize>() = len11;
                  *base.add(8).cast::<*mut u8>() = ptr11.cast_mut();
                },
                V12::BoolVal(e) => {
                  *base.add(0).cast::<u8>() = (4i32) as u8;
                  *base.add(8).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                },
                V12::NullVal=> {
                  {
                    *base.add(0).cast::<u8>() = (5i32) as u8;
                  }
                }
              }
            }
          }
          let ptr14 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/tuplespace@0.1.0")]
          extern "C" {
            #[link_name = "compare-and-swap"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result5, len5, result9, len9, result13, len13, ptr14);
          let l15 = i32::from(*ptr14.add(0).cast::<u8>());
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          if layout9.size() != 0 {
            _rt::alloc::dealloc(result9.cast(), layout9);
          }
          if layout13.size() != 0 {
            _rt::alloc::dealloc(result13.cast(), layout13);
          }
          match l15 {
            0 => {
              let e = {
                let l16 = i32::from(*ptr14.add(4).cast::<u8>());

                _rt::bool_lift(l16 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l17 = i32::from(*ptr14.add(4).cast::<u8>());
                let l18 = *ptr14.add(8).cast::<*mut u8>();
                let l19 = *ptr14.add(12).cast::<usize>();
                let len20 = l19;
                let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);
                let l21 = i32::from(*ptr14.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l17 as u8),
                  message: _rt::string_lift(bytes20),
                  details: match l21 {
                    0 => None,
                    1 => {
                      let e = {
                        let l22 = *ptr14.add(20).cast::<*mut u8>();
                        let l23 = *ptr14.add(24).cast::<usize>();
                        let len24 = l23;
                        let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                        _rt::string_lift(bytes24)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod channels {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Payload = super::super::super::plexspaces::actor::types::Payload;
      pub type MessageId = super::super::super::plexspaces::actor::types::MessageId;
      pub type DurationMs = super::super::super::plexspaces::actor::types::DurationMs;
      pub type ActorError = super::super::super::plexspaces::actor::types::ActorError;
      /// Queue message with metadata
      #[derive(Clone)]
      pub struct QueueMessage {
        /// Unique message ID
        pub id: MessageId,
        /// Message type for routing
        pub msg_type: _rt::String,
        /// Message payload
        pub payload: Payload,
        /// Timestamp when enqueued
        pub timestamp: u64,
        /// Delivery attempt count
        pub delivery_count: u32,
        /// Custom headers
        pub headers: _rt::Vec::<(_rt::String,_rt::String,)>,
      }
      impl ::core::fmt::Debug for QueueMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("QueueMessage").field("id", &self.id).field("msg-type", &self.msg_type).field("payload", &self.payload).field("timestamp", &self.timestamp).field("delivery-count", &self.delivery_count).field("headers", &self.headers).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send message to queue
      ///
      /// Message is delivered to ONE consumer (load-balanced).
      /// If no consumers are available, message is queued.
      ///
      /// # Arguments
      /// - `queue-name`: Name of the queue
      /// - `msg-type`: Message type for routing/filtering
      /// - `payload`: Message payload
      ///
      /// # Returns
      /// - `ok(message-id)`: Message enqueued
      /// - `err`: Send failed
      ///
      /// # Example
      /// ```rust
      /// channels::send_to_queue("orders", "order.created", order_bytes)?;
      /// ```
      pub fn send_to_queue(queue_name: &str,msg_type: &str,payload: &Payload,) -> Result<MessageId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "send-to-queue"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(4).cast::<*mut u8>();
                let l6 = *ptr3.add(8).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr3.add(4).cast::<u8>());
                let l9 = *ptr3.add(8).cast::<*mut u8>();
                let l10 = *ptr3.add(12).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                let l12 = i32::from(*ptr3.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l8 as u8),
                  message: _rt::string_lift(bytes11),
                  details: match l12 {
                    0 => None,
                    1 => {
                      let e = {
                        let l13 = *ptr3.add(20).cast::<*mut u8>();
                        let l14 = *ptr3.add(24).cast::<usize>();
                        let len15 = l14;
                        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                        _rt::string_lift(bytes15)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send with options
      ///
      /// # Arguments
      /// - `queue-name`: Queue name
      /// - `msg-type`: Message type
      /// - `payload`: Message payload
      /// - `delay-ms`: Delay before message becomes visible
      /// - `ttl-ms`: Time-to-live (0 = infinite)
      /// - `headers`: Custom headers
      pub fn send_to_queue_with_options(queue_name: &str,msg_type: &str,payload: &Payload,delay_ms: DurationMs,ttl_ms: DurationMs,headers: &[(_rt::String,_rt::String,)],) -> Result<MessageId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let vec6 = headers;
          let len6 = vec6.len();
          let layout6 = _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 16, 4);
          let result6 = if layout6.size() != 0 {
            let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout6);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec6.into_iter().enumerate() {
            let base = result6.add(i * 16);
            {
              let (t3_0, t3_1, ) = e;
              let vec4 = t3_0;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              *base.add(4).cast::<usize>() = len4;
              *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
              let vec5 = t3_1;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *base.add(12).cast::<usize>() = len5;
              *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
            }
          }
          let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "send-to-queue-with-options"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i64, _: i64, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i64, _: i64, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, _rt::as_i64(delay_ms), _rt::as_i64(ttl_ms), result6, len6, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          if layout6.size() != 0 {
            _rt::alloc::dealloc(result6.cast(), layout6);
          }
          match l8 {
            0 => {
              let e = {
                let l9 = *ptr7.add(4).cast::<*mut u8>();
                let l10 = *ptr7.add(8).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                _rt::string_lift(bytes11)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = i32::from(*ptr7.add(4).cast::<u8>());
                let l13 = *ptr7.add(8).cast::<*mut u8>();
                let l14 = *ptr7.add(12).cast::<usize>();
                let len15 = l14;
                let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                let l16 = i32::from(*ptr7.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l12 as u8),
                  message: _rt::string_lift(bytes15),
                  details: match l16 {
                    0 => None,
                    1 => {
                      let e = {
                        let l17 = *ptr7.add(20).cast::<*mut u8>();
                        let l18 = *ptr7.add(24).cast::<usize>();
                        let len19 = l18;
                        let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                        _rt::string_lift(bytes19)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Receive message from queue
      ///
      /// Blocks until message available or timeout expires.
      /// Message is "leased" - must be acked or nacked.
      ///
      /// # Arguments
      /// - `queue-name`: Queue name
      /// - `timeout-ms`: Maximum time to wait (0 = poll, return immediately)
      ///
      /// # Returns
      /// - `ok(some(message))`: Message received
      /// - `ok(none)`: No message available (timeout)
      /// - `err`: Receive failed
      pub fn receive_from_queue(queue_name: &str,timeout_ms: DurationMs,) -> Result<Option<QueueMessage>,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 64]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 64]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "receive-from-queue"]
            fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, _rt::as_i64(timeout_ms), ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*ptr1.add(8).cast::<u8>());

                match l3 {
                  0 => None,
                  1 => {
                    let e = {
                      let l4 = *ptr1.add(16).cast::<*mut u8>();
                      let l5 = *ptr1.add(20).cast::<usize>();
                      let len6 = l5;
                      let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                      let l7 = *ptr1.add(24).cast::<*mut u8>();
                      let l8 = *ptr1.add(28).cast::<usize>();
                      let len9 = l8;
                      let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                      let l10 = *ptr1.add(32).cast::<*mut u8>();
                      let l11 = *ptr1.add(36).cast::<usize>();
                      let len12 = l11;
                      let l13 = *ptr1.add(40).cast::<i64>();
                      let l14 = *ptr1.add(48).cast::<i32>();
                      let l15 = *ptr1.add(52).cast::<*mut u8>();
                      let l16 = *ptr1.add(56).cast::<usize>();
                      let base23 = l15;
                      let len23 = l16;
                      let mut result23 = _rt::Vec::with_capacity(len23);
                      for i in 0..len23 {
                        let base = base23.add(i * 16);
                        let e23 = {
                          let l17 = *base.add(0).cast::<*mut u8>();
                          let l18 = *base.add(4).cast::<usize>();
                          let len19 = l18;
                          let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);
                          let l20 = *base.add(8).cast::<*mut u8>();
                          let l21 = *base.add(12).cast::<usize>();
                          let len22 = l21;
                          let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);

                          (_rt::string_lift(bytes19), _rt::string_lift(bytes22))
                        };
                        result23.push(e23);
                      }
                      _rt::cabi_dealloc(base23, len23 * 16, 4);

                      QueueMessage{
                        id: _rt::string_lift(bytes6),
                        msg_type: _rt::string_lift(bytes9),
                        payload: _rt::Vec::from_raw_parts(l10.cast(), len12, len12),
                        timestamp: l13 as u64,
                        delivery_count: l14 as u32,
                        headers: result23,
                      }
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l24 = i32::from(*ptr1.add(8).cast::<u8>());
                let l25 = *ptr1.add(12).cast::<*mut u8>();
                let l26 = *ptr1.add(16).cast::<usize>();
                let len27 = l26;
                let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);
                let l28 = i32::from(*ptr1.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l24 as u8),
                  message: _rt::string_lift(bytes27),
                  details: match l28 {
                    0 => None,
                    1 => {
                      let e = {
                        let l29 = *ptr1.add(24).cast::<*mut u8>();
                        let l30 = *ptr1.add(28).cast::<usize>();
                        let len31 = l30;
                        let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                        _rt::string_lift(bytes31)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Acknowledge message processing
      ///
      /// Removes message from queue permanently.
      /// Must be called after successful processing.
      pub fn ack(queue_name: &str,message_id: &MessageId,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = message_id;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "ack"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr2.add(4).cast::<u8>());
                let l5 = *ptr2.add(8).cast::<*mut u8>();
                let l6 = *ptr2.add(12).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = i32::from(*ptr2.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l4 as u8),
                  message: _rt::string_lift(bytes7),
                  details: match l8 {
                    0 => None,
                    1 => {
                      let e = {
                        let l9 = *ptr2.add(20).cast::<*mut u8>();
                        let l10 = *ptr2.add(24).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Negative acknowledge (reject message)
      ///
      /// Returns message to queue for redelivery.
      /// Use when processing fails but message should be retried.
      ///
      /// # Arguments
      /// - `queue-name`: Queue name
      /// - `message-id`: Message to reject
      /// - `requeue`: If true, message goes back to queue. If false, goes to DLQ.
      pub fn nack(queue_name: &str,message_id: &MessageId,requeue: bool,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = message_id;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "nack"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, match &requeue { true => 1, false => 0 }, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr2.add(4).cast::<u8>());
                let l5 = *ptr2.add(8).cast::<*mut u8>();
                let l6 = *ptr2.add(12).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = i32::from(*ptr2.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l4 as u8),
                  message: _rt::string_lift(bytes7),
                  details: match l8 {
                    0 => None,
                    1 => {
                      let e = {
                        let l9 = *ptr2.add(20).cast::<*mut u8>();
                        let l10 = *ptr2.add(24).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Publish message to topic
      ///
      /// Message is delivered to ALL subscribers (broadcast).
      ///
      /// # Arguments
      /// - `topic-name`: Topic name
      /// - `msg-type`: Message type for filtering
      /// - `payload`: Message payload
      ///
      /// # Returns
      /// - `ok(message-id)`: Message published
      /// - `err`: Publish failed
      pub fn publish_to_topic(topic_name: &str,msg_type: &str,payload: &Payload,) -> Result<MessageId,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = topic_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = msg_type;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = payload;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "publish-to-topic"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(4).cast::<*mut u8>();
                let l6 = *ptr3.add(8).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr3.add(4).cast::<u8>());
                let l9 = *ptr3.add(8).cast::<*mut u8>();
                let l10 = *ptr3.add(12).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                let l12 = i32::from(*ptr3.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l8 as u8),
                  message: _rt::string_lift(bytes11),
                  details: match l12 {
                    0 => None,
                    1 => {
                      let e = {
                        let l13 = *ptr3.add(20).cast::<*mut u8>();
                        let l14 = *ptr3.add(24).cast::<usize>();
                        let len15 = l14;
                        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                        _rt::string_lift(bytes15)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to topic
      ///
      /// Creates subscription that receives all messages published to topic.
      /// Each subscriber gets its own copy of messages.
      ///
      /// # Arguments
      /// - `topic-name`: Topic to subscribe to
      /// - `filter`: Optional message type filter (e.g., "order.*")
      ///
      /// # Returns
      /// Subscription ID for unsubscribe
      pub fn subscribe_to_topic(topic_name: &str,filter: Option<&str>,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec0 = topic_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result2_0,result2_1,result2_2,) = match filter {
            Some(e) => {
              let vec1 = e;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();

              (1i32, ptr1.cast_mut(), len1)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "subscribe-to-topic"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result2_0, result2_1, result2_2, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(8).cast::<i64>();

                l5 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr3.add(8).cast::<u8>());
                let l7 = *ptr3.add(12).cast::<*mut u8>();
                let l8 = *ptr3.add(16).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                let l10 = i32::from(*ptr3.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l6 as u8),
                  message: _rt::string_lift(bytes9),
                  details: match l10 {
                    0 => None,
                    1 => {
                      let e = {
                        let l11 = *ptr3.add(24).cast::<*mut u8>();
                        let l12 = *ptr3.add(28).cast::<usize>();
                        let len13 = l12;
                        let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                        _rt::string_lift(bytes13)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Unsubscribe from topic
      pub fn unsubscribe_from_topic(subscription_id: u64,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "unsubscribe-from-topic"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&subscription_id), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l3 = *ptr0.add(8).cast::<*mut u8>();
                let l4 = *ptr0.add(12).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l2 as u8),
                  message: _rt::string_lift(bytes5),
                  details: match l6 {
                    0 => None,
                    1 => {
                      let e = {
                        let l7 = *ptr0.add(20).cast::<*mut u8>();
                        let l8 = *ptr0.add(24).cast::<usize>();
                        let len9 = l8;
                        let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                        _rt::string_lift(bytes9)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Create queue (if not exists)
      ///
      /// # Arguments
      /// - `queue-name`: Queue name
      /// - `max-size`: Maximum queue size (0 = unlimited)
      /// - `message-ttl-ms`: Default TTL for messages (0 = infinite)
      pub fn create_queue(queue_name: &str,max_size: u32,message_ttl_ms: DurationMs,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "create-queue"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, _rt::as_i32(&max_size), _rt::as_i64(message_ttl_ms), ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                let l4 = *ptr1.add(8).cast::<*mut u8>();
                let l5 = *ptr1.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr1.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr1.add(20).cast::<*mut u8>();
                        let l9 = *ptr1.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Delete queue
      pub fn delete_queue(queue_name: &str,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "delete-queue"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                let l4 = *ptr1.add(8).cast::<*mut u8>();
                let l5 = *ptr1.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr1.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr1.add(20).cast::<*mut u8>();
                        let l9 = *ptr1.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get queue depth (number of messages)
      pub fn queue_depth(queue_name: &str,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec0 = queue_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/channels@0.1.0")]
          extern "C" {
            #[link_name = "queue-depth"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(8).cast::<i64>();

                l3 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(8).cast::<u8>());
                let l5 = *ptr1.add(12).cast::<*mut u8>();
                let l6 = *ptr1.add(16).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = i32::from(*ptr1.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l4 as u8),
                  message: _rt::string_lift(bytes7),
                  details: match l8 {
                    0 => None,
                    1 => {
                      let e = {
                        let l9 = *ptr1.add(24).cast::<*mut u8>();
                        let l10 = *ptr1.add(28).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod durability {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Payload = super::super::super::plexspaces::actor::types::Payload;
      pub type ActorError = super::super::super::plexspaces::actor::types::ActorError;
      /// Journal entry representing a persisted event
      #[derive(Clone)]
      pub struct JournalEntry {
        /// Sequence number (monotonically increasing)
        pub sequence: u64,
        /// Event type
        pub event_type: _rt::String,
        /// Event payload
        pub payload: Payload,
        /// Timestamp when persisted
        pub timestamp: u64,
      }
      impl ::core::fmt::Debug for JournalEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("JournalEntry").field("sequence", &self.sequence).field("event-type", &self.event_type).field("payload", &self.payload).field("timestamp", &self.timestamp).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Append event to journal
      ///
      /// Event is durably persisted before returning.
      /// Use for event sourcing patterns.
      ///
      /// # Arguments
      /// - `event-type`: Event type identifier
      /// - `payload`: Event payload
      ///
      /// # Returns
      /// - `ok(sequence)`: Sequence number of persisted event
      /// - `err`: Persistence failed
      ///
      /// # Example
      /// ```rust
      /// // Persist state change event
      /// let event = serde_json::to_vec(&OrderCreated { id: "123" })?;
      /// let seq = durability::persist("order.created", event)?;
      /// ```
      pub fn persist(event_type: &str,payload: &Payload,) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec0 = event_type;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = payload;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "persist"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(8).cast::<i64>();

                l4 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*ptr2.add(8).cast::<u8>());
                let l6 = *ptr2.add(12).cast::<*mut u8>();
                let l7 = *ptr2.add(16).cast::<usize>();
                let len8 = l7;
                let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                let l9 = i32::from(*ptr2.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l5 as u8),
                  message: _rt::string_lift(bytes8),
                  details: match l9 {
                    0 => None,
                    1 => {
                      let e = {
                        let l10 = *ptr2.add(24).cast::<*mut u8>();
                        let l11 = *ptr2.add(28).cast::<usize>();
                        let len12 = l11;
                        let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                        _rt::string_lift(bytes12)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Persist multiple events atomically
      ///
      /// All events are persisted in a single transaction.
      /// Either all succeed or all fail.
      ///
      /// # Arguments
      /// - `events`: List of (event_type, payload) tuples
      ///
      /// # Returns
      /// - `ok(first_sequence)`: Sequence number of first event
      pub fn persist_batch(events: &[(_rt::String,Payload,)],) -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let vec3 = events;
          let len3 = vec3.len();
          let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 16, 4);
          let result3 = if layout3.size() != 0 {
            let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3.add(i * 16);
            {
              let (t0_0, t0_1, ) = e;
              let vec1 = t0_0;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              *base.add(4).cast::<usize>() = len1;
              *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
              let vec2 = t0_1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(12).cast::<usize>() = len2;
              *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
            }
          }
          let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "persist-batch"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result3, len3, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          if layout3.size() != 0 {
            _rt::alloc::dealloc(result3.cast(), layout3);
          }
          match l5 {
            0 => {
              let e = {
                let l6 = *ptr4.add(8).cast::<i64>();

                l6 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr4.add(8).cast::<u8>());
                let l8 = *ptr4.add(12).cast::<*mut u8>();
                let l9 = *ptr4.add(16).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                let l11 = i32::from(*ptr4.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l7 as u8),
                  message: _rt::string_lift(bytes10),
                  details: match l11 {
                    0 => None,
                    1 => {
                      let e = {
                        let l12 = *ptr4.add(24).cast::<*mut u8>();
                        let l13 = *ptr4.add(28).cast::<usize>();
                        let len14 = l13;
                        let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                        _rt::string_lift(bytes14)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Create checkpoint (snapshot)
      ///
      /// Forces immediate snapshot of actor state.
      /// After checkpoint, replay only needs events after this point.
      ///
      /// # Returns
      /// - `ok(sequence)`: Sequence number of checkpoint
      /// - `err`: Checkpoint failed
      pub fn checkpoint() -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "checkpoint"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(8).cast::<i64>();

                l2 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                let l4 = *ptr0.add(12).cast::<*mut u8>();
                let l5 = *ptr0.add(16).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr0.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr0.add(24).cast::<*mut u8>();
                        let l9 = *ptr0.add(28).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get current journal sequence number
      ///
      /// Returns highest persisted sequence number.
      /// Useful for tracking progress.
      pub fn get_sequence() -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "get-sequence"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(8).cast::<i64>();

                l2 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                let l4 = *ptr0.add(12).cast::<*mut u8>();
                let l5 = *ptr0.add(16).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr0.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr0.add(24).cast::<*mut u8>();
                        let l9 = *ptr0.add(28).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get last checkpoint sequence number
      ///
      /// Returns sequence number of most recent checkpoint.
      /// Events before this are compacted.
      pub fn get_checkpoint_sequence() -> Result<u64,ActorError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "get-checkpoint-sequence"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(8).cast::<i64>();

                l2 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                let l4 = *ptr0.add(12).cast::<*mut u8>();
                let l5 = *ptr0.add(16).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr0.add(20).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr0.add(24).cast::<*mut u8>();
                        let l9 = *ptr0.add(28).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Check if currently in replay mode
      ///
      /// Returns true during recovery (replaying journal).
      /// Actors should skip side effects during replay.
      ///
      /// # Example
      /// ```rust
      /// if !durability::is_replaying()? {
      /// // Only send email during normal execution
      /// send_notification_email()?;
      /// }
      /// ```
      pub fn is_replaying() -> Result<bool,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "is-replaying"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());

                _rt::bool_lift(l2 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                let l4 = *ptr0.add(8).cast::<*mut u8>();
                let l5 = *ptr0.add(12).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l3 as u8),
                  message: _rt::string_lift(bytes6),
                  details: match l7 {
                    0 => None,
                    1 => {
                      let e = {
                        let l8 = *ptr0.add(20).cast::<*mut u8>();
                        let l9 = *ptr0.add(24).cast::<usize>();
                        let len10 = l9;
                        let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                        _rt::string_lift(bytes10)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Cache result of side effect
      ///
      /// During replay, returns cached result instead of re-executing.
      /// Use for non-deterministic operations (HTTP calls, random, time).
      ///
      /// # Arguments
      /// - `key`: Unique key for this side effect
      /// - `result`: Result to cache (only used during normal execution)
      ///
      /// # Returns
      /// - During normal execution: Returns provided result
      /// - During replay: Returns previously cached result
      ///
      /// # Example
      /// ```rust
      /// // HTTP call is cached during replay
      /// let response = durability::cache_side_effect(
      /// "http:orders:123",
      /// || http_client.get("https://api.example.com/orders/123")
      /// )?;
      /// ```
      pub fn cache_side_effect(key: &str,result_value: &Payload,) -> Result<Payload,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = result_value;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "cache-side-effect"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(4).cast::<*mut u8>();
                let l5 = *ptr2.add(8).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr2.add(4).cast::<u8>());
                let l8 = *ptr2.add(8).cast::<*mut u8>();
                let l9 = *ptr2.add(12).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                let l11 = i32::from(*ptr2.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l7 as u8),
                  message: _rt::string_lift(bytes10),
                  details: match l11 {
                    0 => None,
                    1 => {
                      let e = {
                        let l12 = *ptr2.add(20).cast::<*mut u8>();
                        let l13 = *ptr2.add(24).cast::<usize>();
                        let len14 = l13;
                        let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                        _rt::string_lift(bytes14)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read journal entries (for debugging/introspection)
      ///
      /// # Arguments
      /// - `from-sequence`: Start sequence (inclusive)
      /// - `to-sequence`: End sequence (exclusive), 0 = to end
      /// - `limit`: Maximum entries to return
      pub fn read_journal(from_sequence: u64,to_sequence: u64,limit: u32,) -> Result<_rt::Vec::<JournalEntry>,ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "read-journal"]
            fn wit_import(_: i64, _: i64, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: i64, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&from_sequence), _rt::as_i64(&to_sequence), _rt::as_i32(&limit), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let base12 = l2;
                let len12 = l3;
                let mut result12 = _rt::Vec::with_capacity(len12);
                for i in 0..len12 {
                  let base = base12.add(i * 32);
                  let e12 = {
                    let l4 = *base.add(0).cast::<i64>();
                    let l5 = *base.add(8).cast::<*mut u8>();
                    let l6 = *base.add(12).cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = *base.add(16).cast::<*mut u8>();
                    let l9 = *base.add(20).cast::<usize>();
                    let len10 = l9;
                    let l11 = *base.add(24).cast::<i64>();

                    JournalEntry{
                      sequence: l4 as u64,
                      event_type: _rt::string_lift(bytes7),
                      payload: _rt::Vec::from_raw_parts(l8.cast(), len10, len10),
                      timestamp: l11 as u64,
                    }
                  };
                  result12.push(e12);
                }
                _rt::cabi_dealloc(base12, len12 * 32, 8);

                result12
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l13 = i32::from(*ptr0.add(4).cast::<u8>());
                let l14 = *ptr0.add(8).cast::<*mut u8>();
                let l15 = *ptr0.add(12).cast::<usize>();
                let len16 = l15;
                let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);
                let l17 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l13 as u8),
                  message: _rt::string_lift(bytes16),
                  details: match l17 {
                    0 => None,
                    1 => {
                      let e = {
                        let l18 = *ptr0.add(20).cast::<*mut u8>();
                        let l19 = *ptr0.add(24).cast::<usize>();
                        let len20 = l19;
                        let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);

                        _rt::string_lift(bytes20)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Compact journal up to sequence
      ///
      /// Removes journal entries before sequence.
      /// Only allowed if checkpoint exists at or after sequence.
      pub fn compact(up_to_sequence: u64,) -> Result<(),ActorError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "plexspaces:actor/durability@0.1.0")]
          extern "C" {
            #[link_name = "compact"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&up_to_sequence), ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l3 = *ptr0.add(8).cast::<*mut u8>();
                let l4 = *ptr0.add(12).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = i32::from(*ptr0.add(16).cast::<u8>());

                super::super::super::plexspaces::actor::types::ActorError{
                  code: super::super::super::plexspaces::actor::types::ErrorCode::_lift(l2 as u8),
                  message: _rt::string_lift(bytes5),
                  details: match l6 {
                    0 => None,
                    1 => {
                      let e = {
                        let l7 = *ptr0.add(20).cast::<*mut u8>();
                        let l8 = *ptr0.add(24).cast::<usize>();
                        let len9 = l8;
                        let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                        _rt::string_lift(bytes9)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod exports {
  #[allow(dead_code)]
  pub mod plexspaces {
    #[allow(dead_code)]
    pub mod actor {
      #[allow(dead_code, clippy::all)]
      pub mod actor {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
        use super::super::super::super::_rt;
        pub type ActorId = super::super::super::super::plexspaces::actor::types::ActorId;
        pub type Payload = super::super::super::super::plexspaces::actor::types::Payload;
        pub type ActorResult = super::super::super::super::plexspaces::actor::types::ActorResult;
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_init_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let len0 = arg1;
        let result1 = T::init(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0));
        let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
        match result1 {
          Ok(_) => { {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
          } },
          Err(e) => { {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
            let vec3 = (e.into_bytes()).into_boxed_slice();
            let ptr3 = vec3.as_ptr().cast::<u8>();
            let len3 = vec3.len();
            ::core::mem::forget(vec3);
            *ptr2.add(8).cast::<usize>() = len3;
            *ptr2.add(4).cast::<*mut u8>() = ptr3.cast_mut();
          } },
        };ptr2
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __post_return_init<T: Guest>(arg0: *mut u8,) {
        let l0 = i32::from(*arg0.add(0).cast::<u8>());
        match l0 {
          0 => (),
          _ => {
            let l1 = *arg0.add(4).cast::<*mut u8>();
            let l2 = *arg0.add(8).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
          },
        }
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_handle_message_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: *mut u8,arg5: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let len0 = arg1;
      let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
      let len1 = arg3;
      let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
      let len2 = arg5;
      let result3 = T::handle_message(_rt::string_lift(bytes0), _rt::string_lift(bytes1), _rt::Vec::from_raw_parts(arg4.cast(), len2, len2));
      let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
      use super::super::super::super::plexspaces::actor::types::ActorResult as V9;
      match result3 {
        V9::Ok(e) => {
          *ptr4.add(0).cast::<u8>() = (0i32) as u8;
          let vec5 = (e).into_boxed_slice();
          let ptr5 = vec5.as_ptr().cast::<u8>();
          let len5 = vec5.len();
          ::core::mem::forget(vec5);
          *ptr4.add(8).cast::<usize>() = len5;
          *ptr4.add(4).cast::<*mut u8>() = ptr5.cast_mut();
        },
        V9::Err(e) => {
          *ptr4.add(0).cast::<u8>() = (1i32) as u8;
          let super::super::super::super::plexspaces::actor::types::ActorError{ code:code6, message:message6, details:details6, } = e;
          *ptr4.add(4).cast::<u8>() = (code6.clone() as i32) as u8;
          let vec7 = (message6.into_bytes()).into_boxed_slice();
          let ptr7 = vec7.as_ptr().cast::<u8>();
          let len7 = vec7.len();
          ::core::mem::forget(vec7);
          *ptr4.add(12).cast::<usize>() = len7;
          *ptr4.add(8).cast::<*mut u8>() = ptr7.cast_mut();
          match details6 {
            Some(e) => {
              *ptr4.add(16).cast::<u8>() = (1i32) as u8;
              let vec8 = (e.into_bytes()).into_boxed_slice();
              let ptr8 = vec8.as_ptr().cast::<u8>();
              let len8 = vec8.len();
              ::core::mem::forget(vec8);
              *ptr4.add(24).cast::<usize>() = len8;
              *ptr4.add(20).cast::<*mut u8>() = ptr8.cast_mut();
            },
            None => {
              {
                *ptr4.add(16).cast::<u8>() = (0i32) as u8;
              }
            },
          };},
        }
        ptr4
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __post_return_handle_message<T: Guest>(arg0: *mut u8,) {
        let l0 = i32::from(*arg0.add(0).cast::<u8>());
        match l0 {
          0 => {
            let l1 = *arg0.add(4).cast::<*mut u8>();
            let l2 = *arg0.add(8).cast::<usize>();
            let base3 = l1;
            let len3 = l2;
            _rt::cabi_dealloc(base3, len3 * 1, 1);
          },
          _ => {
            let l4 = *arg0.add(8).cast::<*mut u8>();
            let l5 = *arg0.add(12).cast::<usize>();
            _rt::cabi_dealloc(l4, l5, 1);
            let l6 = i32::from(*arg0.add(16).cast::<u8>());
            match l6 {
              0 => (),
              _ => {
                let l7 = *arg0.add(20).cast::<*mut u8>();
                let l8 = *arg0.add(24).cast::<usize>();
                _rt::cabi_dealloc(l7, l8, 1);
              },
            }
          },
        }
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_snapshot_state_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let result0 = T::snapshot_state();
      let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
      match result0 {
        Ok(e) => { {
          *ptr1.add(0).cast::<u8>() = (0i32) as u8;
          let vec2 = (e).into_boxed_slice();
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          ::core::mem::forget(vec2);
          *ptr1.add(8).cast::<usize>() = len2;
          *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
        } },
        Err(e) => { {
          *ptr1.add(0).cast::<u8>() = (1i32) as u8;
          let vec3 = (e.into_bytes()).into_boxed_slice();
          let ptr3 = vec3.as_ptr().cast::<u8>();
          let len3 = vec3.len();
          ::core::mem::forget(vec3);
          *ptr1.add(8).cast::<usize>() = len3;
          *ptr1.add(4).cast::<*mut u8>() = ptr3.cast_mut();
        } },
      };ptr1
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __post_return_snapshot_state<T: Guest>(arg0: *mut u8,) {
      let l0 = i32::from(*arg0.add(0).cast::<u8>());
      match l0 {
        0 => {
          let l1 = *arg0.add(4).cast::<*mut u8>();
          let l2 = *arg0.add(8).cast::<usize>();
          let base3 = l1;
          let len3 = l2;
          _rt::cabi_dealloc(base3, len3 * 1, 1);
        },
        _ => {
          let l4 = *arg0.add(4).cast::<*mut u8>();
          let l5 = *arg0.add(8).cast::<usize>();
          _rt::cabi_dealloc(l4, l5, 1);
        },
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_shutdown_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result0 = T::shutdown();
    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result0 {
      Ok(_) => { {
        *ptr1.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr1.add(0).cast::<u8>() = (1i32) as u8;
        let vec2 = (e.into_bytes()).into_boxed_slice();
        let ptr2 = vec2.as_ptr().cast::<u8>();
        let len2 = vec2.len();
        ::core::mem::forget(vec2);
        *ptr1.add(8).cast::<usize>() = len2;
        *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
      } },
    };ptr1
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_shutdown<T: Guest>(arg0: *mut u8,) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => (),
      _ => {
        let l1 = *arg0.add(4).cast::<*mut u8>();
        let l2 = *arg0.add(8).cast::<usize>();
        _rt::cabi_dealloc(l1, l2, 1);
      },
    }
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_handle_call_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let len0 = arg1;
  let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
  let len1 = arg3;
  let result2 = T::handle_call(_rt::string_lift(bytes0), _rt::Vec::from_raw_parts(arg2.cast(), len1, len1));
  let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
  use super::super::super::super::plexspaces::actor::types::ActorResult as V8;
  match result2 {
    V8::Ok(e) => {
      *ptr3.add(0).cast::<u8>() = (0i32) as u8;
      let vec4 = (e).into_boxed_slice();
      let ptr4 = vec4.as_ptr().cast::<u8>();
      let len4 = vec4.len();
      ::core::mem::forget(vec4);
      *ptr3.add(8).cast::<usize>() = len4;
      *ptr3.add(4).cast::<*mut u8>() = ptr4.cast_mut();
    },
    V8::Err(e) => {
      *ptr3.add(0).cast::<u8>() = (1i32) as u8;
      let super::super::super::super::plexspaces::actor::types::ActorError{ code:code5, message:message5, details:details5, } = e;
      *ptr3.add(4).cast::<u8>() = (code5.clone() as i32) as u8;
      let vec6 = (message5.into_bytes()).into_boxed_slice();
      let ptr6 = vec6.as_ptr().cast::<u8>();
      let len6 = vec6.len();
      ::core::mem::forget(vec6);
      *ptr3.add(12).cast::<usize>() = len6;
      *ptr3.add(8).cast::<*mut u8>() = ptr6.cast_mut();
      match details5 {
        Some(e) => {
          *ptr3.add(16).cast::<u8>() = (1i32) as u8;
          let vec7 = (e.into_bytes()).into_boxed_slice();
          let ptr7 = vec7.as_ptr().cast::<u8>();
          let len7 = vec7.len();
          ::core::mem::forget(vec7);
          *ptr3.add(24).cast::<usize>() = len7;
          *ptr3.add(20).cast::<*mut u8>() = ptr7.cast_mut();
        },
        None => {
          {
            *ptr3.add(16).cast::<u8>() = (0i32) as u8;
          }
        },
      };},
    }
    ptr3
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_handle_call<T: Guest>(arg0: *mut u8,) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => {
        let l1 = *arg0.add(4).cast::<*mut u8>();
        let l2 = *arg0.add(8).cast::<usize>();
        let base3 = l1;
        let len3 = l2;
        _rt::cabi_dealloc(base3, len3 * 1, 1);
      },
      _ => {
        let l4 = *arg0.add(8).cast::<*mut u8>();
        let l5 = *arg0.add(12).cast::<usize>();
        _rt::cabi_dealloc(l4, l5, 1);
        let l6 = i32::from(*arg0.add(16).cast::<u8>());
        match l6 {
          0 => (),
          _ => {
            let l7 = *arg0.add(20).cast::<*mut u8>();
            let l8 = *arg0.add(24).cast::<usize>();
            _rt::cabi_dealloc(l7, l8, 1);
          },
        }
      },
    }
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_handle_cast_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let len0 = arg1;
  let result1 = T::handle_cast(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0));
  let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
  match result1 {
    Ok(_) => { {
      *ptr2.add(0).cast::<u8>() = (0i32) as u8;
    } },
    Err(e) => { {
      *ptr2.add(0).cast::<u8>() = (1i32) as u8;
      let vec3 = (e.into_bytes()).into_boxed_slice();
      let ptr3 = vec3.as_ptr().cast::<u8>();
      let len3 = vec3.len();
      ::core::mem::forget(vec3);
      *ptr2.add(8).cast::<usize>() = len3;
      *ptr2.add(4).cast::<*mut u8>() = ptr3.cast_mut();
    } },
  };ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_handle_cast<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_handle_info_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg1;
let result1 = T::handle_info(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0));
let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result1 {
  Ok(_) => { {
    *ptr2.add(0).cast::<u8>() = (0i32) as u8;
  } },
  Err(e) => { {
    *ptr2.add(0).cast::<u8>() = (1i32) as u8;
    let vec3 = (e.into_bytes()).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr2.add(8).cast::<usize>() = len3;
    *ptr2.add(4).cast::<*mut u8>() = ptr3.cast_mut();
  } },
};ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_handle_info<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_handle_event_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg1;
let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
let len1 = arg3;
let result2 = T::handle_event(_rt::string_lift(bytes0), _rt::Vec::from_raw_parts(arg2.cast(), len1, len1));
let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result2 {
  Ok(_) => { {
    *ptr3.add(0).cast::<u8>() = (0i32) as u8;
  } },
  Err(e) => { {
    *ptr3.add(0).cast::<u8>() = (1i32) as u8;
    let vec4 = (e.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr3.add(8).cast::<usize>() = len4;
    *ptr3.add(4).cast::<*mut u8>() = ptr4.cast_mut();
  } },
};ptr3
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_handle_event<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_handle_transition_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg1;
let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
let len1 = arg3;
let result2 = T::handle_transition(_rt::string_lift(bytes0), _rt::Vec::from_raw_parts(arg2.cast(), len1, len1));
let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result2 {
  Ok(e) => { {
    *ptr3.add(0).cast::<u8>() = (0i32) as u8;
    let vec4 = (e.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr3.add(8).cast::<usize>() = len4;
    *ptr3.add(4).cast::<*mut u8>() = ptr4.cast_mut();
  } },
  Err(e) => { {
    *ptr3.add(0).cast::<u8>() = (1i32) as u8;
    let vec5 = (e.into_bytes()).into_boxed_slice();
    let ptr5 = vec5.as_ptr().cast::<u8>();
    let len5 = vec5.len();
    ::core::mem::forget(vec5);
    *ptr3.add(8).cast::<usize>() = len5;
    *ptr3.add(4).cast::<*mut u8>() = ptr5.cast_mut();
  } },
};ptr3
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_handle_transition<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
    _ => {
      let l3 = *arg0.add(4).cast::<*mut u8>();
      let l4 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l3, l4, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_state_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::get_state();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
let vec2 = (result0.into_bytes()).into_boxed_slice();
let ptr2 = vec2.as_ptr().cast::<u8>();
let len2 = vec2.len();
::core::mem::forget(vec2);
*ptr1.add(4).cast::<usize>() = len2;
*ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_state<T: Guest>(arg0: *mut u8,) {
  let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(4).cast::<usize>();
  _rt::cabi_dealloc(l0, l1, 1);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_post_init_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::post_init();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(_) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    let vec2 = (e.into_bytes()).into_boxed_slice();
    let ptr2 = vec2.as_ptr().cast::<u8>();
    let len2 = vec2.len();
    ::core::mem::forget(vec2);
    *ptr1.add(8).cast::<usize>() = len2;
    *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_post_init<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_pre_suspend_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::pre_suspend();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(_) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    let vec2 = (e.into_bytes()).into_boxed_slice();
    let ptr2 = vec2.as_ptr().cast::<u8>();
    let len2 = vec2.len();
    ::core::mem::forget(vec2);
    *ptr1.add(8).cast::<usize>() = len2;
    *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_pre_suspend<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_post_resume_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::post_resume();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(_) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    let vec2 = (e.into_bytes()).into_boxed_slice();
    let ptr2 = vec2.as_ptr().cast::<u8>();
    let len2 = vec2.len();
    ::core::mem::forget(vec2);
    *ptr1.add(8).cast::<usize>() = len2;
    *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_post_resume<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
pub trait Guest {
  /// Initialize actor with state
  ///
  /// Called ONCE when actor is first created or recovered.
  /// Actor should deserialize initial-state and set up internal state.
  ///
  /// # Arguments
  /// - `initial-state`: State bytes (empty for new actor, snapshot for recovered)
  ///
  /// # Returns
  /// - `ok`: Initialization successful
  /// - `err`: Initialization failed (actor will be terminated)
  ///
  /// # Lifecycle
  /// 1. Runtime creates WASM instance
  /// 2. Runtime calls `init(initial_state)`
  /// 3. If init succeeds, actor is ready to receive messages
  /// 4. If init fails, actor is terminated
  fn init(initial_state: Payload,) -> Result<(),_rt::String>;
  /// Handle incoming message (generic handler)
  ///
  /// Called for every message received by the actor.
  /// This is the primary message handler.
  ///
  /// # Arguments
  /// - `from`: Sender actor ID
  /// - `msg-type`: Message type (e.g., "call", "cast", "info")
  /// - `payload`: Message payload bytes
  ///
  /// # Returns
  /// - `ok(response)`: Message processed, response payload (may be empty)
  /// - `err`: Message processing failed
  ///
  /// # Message Types
  /// - "call": Synchronous request, MUST return response
  /// - "cast": Asynchronous message, response ignored
  /// - "info": System message (timer, monitor notification)
  ///
  /// # Example (Rust)
  /// ```rust
  /// fn handle_message(from: String, msg_type: String, payload: Vec<u8>) -> ActorResult {
  /// match msg_type.as_str() {
  /// "call" => handle_call(from, payload),
  /// "cast" => { handle_cast(from, payload); ActorResult::Ok(vec![]) },
  /// _ => ActorResult::Err(format!("Unknown message type: {}", msg_type)),
  /// }
  /// }
  /// ```
  fn handle_message(from_actor: ActorId,msg_type: _rt::String,payload: Payload,) -> ActorResult;
  /// Snapshot actor state for persistence
  ///
  /// Called periodically by runtime for checkpointing.
  /// Also called during graceful shutdown.
  /// Actor should serialize its complete state.
  ///
  /// # Returns
  /// - `ok(state)`: Serialized state bytes
  /// - `err`: Snapshot failed (actor may be terminated)
  ///
  /// # Notes
  /// - State should be deterministic (same state = same bytes)
  /// - Keep state size reasonable (< 10MB recommended)
  /// - Use efficient serialization (protobuf, msgpack)
  fn snapshot_state() -> Result<Payload,_rt::String>;
  /// Graceful shutdown
  ///
  /// Called before actor is terminated.
  /// Actor should clean up resources, flush buffers, etc.
  ///
  /// # Returns
  /// - `ok`: Shutdown successful
  /// - `err`: Shutdown failed (runtime will force terminate)
  ///
  /// # Timeout
  /// Runtime enforces shutdown timeout (configurable, default 30s).
  /// After timeout, actor is force-terminated.
  fn shutdown() -> Result<(),_rt::String>;
  /// =========================================================================
  /// Optional: Behavior-specific handlers
  ///
  /// Actors MAY implement these for specific behavior patterns.
  /// If not implemented, runtime falls back to handle-message.
  /// =========================================================================
  /// Handle synchronous request (GenServer pattern)
  ///
  /// Called for "call" messages when actor implements GenServer behavior.
  /// MUST return a response.
  ///
  /// # Arguments
  /// - `from`: Sender actor ID (for reply routing)
  /// - `request`: Request payload
  ///
  /// # Returns
  /// Response payload (MUST be provided)
  fn handle_call(from_actor: ActorId,request: Payload,) -> ActorResult;
  /// Handle asynchronous message (GenServer pattern)
  ///
  /// Called for "cast" messages when actor implements GenServer behavior.
  /// Response is ignored.
  ///
  /// # Arguments
  /// - `message`: Message payload
  fn handle_cast(message: Payload,) -> Result<(),_rt::String>;
  /// Handle info message (GenServer pattern)
  ///
  /// Called for system messages (timers, monitors, etc.)
  ///
  /// # Arguments
  /// - `message`: Info message payload
  fn handle_info(message: Payload,) -> Result<(),_rt::String>;
  /// Handle event (GenEvent pattern)
  ///
  /// Called for event notifications.
  /// Actor processes event but does not respond.
  ///
  /// # Arguments
  /// - `event-type`: Type of event
  /// - `event`: Event payload
  fn handle_event(event_type: _rt::String,event: Payload,) -> Result<(),_rt::String>;
  /// Handle state transition (GenFSM pattern)
  ///
  /// Called for state machine transitions.
  /// Returns new state name.
  ///
  /// # Arguments
  /// - `current-state`: Current state name
  /// - `event`: Triggering event
  ///
  /// # Returns
  /// - `ok(new-state)`: New state name
  /// - `err`: Transition failed
  fn handle_transition(current_state: _rt::String,event: Payload,) -> Result<_rt::String,_rt::String>;
  /// Get current FSM state (GenFSM pattern)
  ///
  /// Returns current state name for state machine actors.
  fn get_state() -> _rt::String;
  /// =========================================================================
  /// Optional: Lifecycle hooks
  /// =========================================================================
  /// Called after successful initialization
  ///
  /// Use for post-init setup that requires messaging.
  fn post_init() -> Result<(),_rt::String>;
  /// Called when actor is about to be suspended
  ///
  /// Actor can clean up before suspension (e.g., for migration).
  fn pre_suspend() -> Result<(),_rt::String>;
  /// Called when actor is resumed after suspension
  ///
  /// Actor can restore connections, timers, etc.
  fn post_resume() -> Result<(),_rt::String>;
}
#[doc(hidden)]

macro_rules! __export_plexspaces_actor_actor_0_1_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "plexspaces:actor/actor@0.1.0#init"]
    unsafe extern "C" fn export_init(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_init_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#init"]
    unsafe extern "C" fn _post_return_init(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_init::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-message"]
    unsafe extern "C" fn export_handle_message(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: *mut u8,arg5: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_message_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-message"]
    unsafe extern "C" fn _post_return_handle_message(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_message::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#snapshot-state"]
    unsafe extern "C" fn export_snapshot_state() -> *mut u8 {
      $($path_to_types)*::_export_snapshot_state_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#snapshot-state"]
    unsafe extern "C" fn _post_return_snapshot_state(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_snapshot_state::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#shutdown"]
    unsafe extern "C" fn export_shutdown() -> *mut u8 {
      $($path_to_types)*::_export_shutdown_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#shutdown"]
    unsafe extern "C" fn _post_return_shutdown(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_shutdown::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-call"]
    unsafe extern "C" fn export_handle_call(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_call_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-call"]
    unsafe extern "C" fn _post_return_handle_call(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_call::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-cast"]
    unsafe extern "C" fn export_handle_cast(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_cast_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-cast"]
    unsafe extern "C" fn _post_return_handle_cast(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_cast::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-info"]
    unsafe extern "C" fn export_handle_info(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_info_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-info"]
    unsafe extern "C" fn _post_return_handle_info(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_info::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-event"]
    unsafe extern "C" fn export_handle_event(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_event_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-event"]
    unsafe extern "C" fn _post_return_handle_event(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_event::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#handle-transition"]
    unsafe extern "C" fn export_handle_transition(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {
      $($path_to_types)*::_export_handle_transition_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#handle-transition"]
    unsafe extern "C" fn _post_return_handle_transition(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_handle_transition::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#get-state"]
    unsafe extern "C" fn export_get_state() -> *mut u8 {
      $($path_to_types)*::_export_get_state_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#get-state"]
    unsafe extern "C" fn _post_return_get_state(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_state::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#post-init"]
    unsafe extern "C" fn export_post_init() -> *mut u8 {
      $($path_to_types)*::_export_post_init_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#post-init"]
    unsafe extern "C" fn _post_return_post_init(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_post_init::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#pre-suspend"]
    unsafe extern "C" fn export_pre_suspend() -> *mut u8 {
      $($path_to_types)*::_export_pre_suspend_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#pre-suspend"]
    unsafe extern "C" fn _post_return_pre_suspend(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_pre_suspend::<$ty>(arg0)
    }
    #[export_name = "plexspaces:actor/actor@0.1.0#post-resume"]
    unsafe extern "C" fn export_post_resume() -> *mut u8 {
      $($path_to_types)*::_export_post_resume_cabi::<$ty>()
    }
    #[export_name = "cabi_post_plexspaces:actor/actor@0.1.0#post-resume"]
    unsafe extern "C" fn _post_return_post_resume(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_post_resume::<$ty>(arg0)
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_plexspaces_actor_actor_0_1_0_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 28]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);

}

}
}
}
mod _rt {
  pub use alloc_crate::string::String;
  pub use alloc_crate::alloc;

  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    let layout = alloc::Layout::from_size_align_unchecked(size, align);
    alloc::dealloc(ptr as *mut u8, layout);
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_plexspaces_actor_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::plexspaces::actor::actor::__export_plexspaces_actor_actor_0_1_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::plexspaces::actor::actor);
  )
}
#[doc(inline)]
pub(crate) use __export_plexspaces_actor_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.24.0:plexspaces-actor:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 4558] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc7\"\x01A\x02\x01A\x18\
\x01B\x14\x01m\x05\x05trace\x05debug\x04info\x04warn\x05error\x04\0\x09log-level\
\x03\0\0\x01@\x02\x05level\x01\x07messages\x01\0\x04\0\x03log\x01\x02\x01o\x02ss\
\x01p\x03\x01@\x03\x05level\x01\x07messages\x06fields\x04\x01\0\x04\0\x0flog-wit\
h-fields\x01\x05\x01@\x01\x07messages\x01\0\x04\0\x05trace\x01\x06\x04\0\x05debu\
g\x01\x06\x04\0\x04info\x01\x06\x04\0\x04warn\x01\x06\x04\0\x05error\x01\x06\x01\
@\x01\x04names\0w\x04\0\x0astart-span\x01\x07\x01@\x01\x07span-idw\x01\0\x04\0\x08\
end-span\x01\x08\x01@\x02\x04names\x0aattributes\x04\x01\0\x04\0\x0eadd-span-eve\
nt\x01\x09\x03\x01\x1eplexspaces:actor/logging@0.1.0\x05\0\x01B'\x01s\x04\0\x08a\
ctor-id\x03\0\0\x01p}\x04\0\x07payload\x03\0\x02\x01s\x04\0\x0ecorrelation-id\x03\
\0\x04\x01s\x04\0\x0amessage-id\x03\0\x06\x01w\x04\0\x09timestamp\x03\0\x08\x01w\
\x04\0\x0bduration-ms\x03\0\x0a\x01p}\x01q\x06\x0astring-val\x01s\0\x07int-val\x01\
x\0\x09float-val\x01u\0\x09bytes-val\x01\x0c\0\x08bool-val\x01\x7f\0\x08null-val\
\0\0\x04\0\x0btuple-field\x03\0\x0d\x01p\x0e\x04\0\x0atuple-data\x03\0\x0f\x01m\x07\
\x0bstring-type\x08int-type\x0afloat-type\x0abytes-type\x09bool-type\x09null-typ\
e\x0atuple-type\x04\0\x0afield-type\x03\0\x11\x01q\x04\x05exact\x01\x0e\0\x03any\
\0\0\x05typed\x01\x12\0\x09predicate\x01s\0\x04\0\x0dpattern-field\x03\0\x13\x01\
p\x14\x04\0\x07pattern\x03\0\x15\x01m\x09\x07unknown\x0factor-not-found\x0fdeliv\
ery-failed\x07timeout\x0finvalid-message\x0dnot-permitted\x12resource-exhausted\x08\
internal\x0fnot-implemented\x04\0\x0aerror-code\x03\0\x17\x01ks\x01r\x03\x04code\
\x18\x07messages\x07details\x19\x04\0\x0bactor-error\x03\0\x1a\x01q\x02\x02ok\x01\
\x03\0\x03err\x01\x1b\0\x04\0\x0cactor-result\x03\0\x1c\x01k\x05\x01o\x02ss\x01p\
\x1f\x01r\x07\x02id\x07\x0afrom-actor\x01\x08msg-types\x07payload\x03\x0ecorrela\
tion-id\x1e\x09timestamp\x09\x07headers\x20\x04\0\x07message\x03\0!\x01k\x01\x01\
ky\x01r\x05\x08actor-id#\x06labels\x20\x0cmailbox-size$\x07durable\x7f\x0asuperv\
isor#\x04\0\x0dspawn-options\x03\0%\x03\x01\x1cplexspaces:actor/types@0.1.0\x05\x01\
\x02\x03\0\x01\x08actor-id\x02\x03\0\x01\x07payload\x02\x03\0\x01\x0amessage-id\x02\
\x03\0\x01\x0ecorrelation-id\x02\x03\0\x01\x0bduration-ms\x02\x03\0\x01\x0dspawn\
-options\x02\x03\0\x01\x0bactor-error\x01B4\x02\x03\x02\x01\x02\x04\0\x08actor-i\
d\x03\0\0\x02\x03\x02\x01\x03\x04\0\x07payload\x03\0\x02\x02\x03\x02\x01\x04\x04\
\0\x0amessage-id\x03\0\x04\x02\x03\x02\x01\x05\x04\0\x0ecorrelation-id\x03\0\x06\
\x02\x03\x02\x01\x06\x04\0\x0bduration-ms\x03\0\x08\x02\x03\x02\x01\x07\x04\0\x0d\
spawn-options\x03\0\x0a\x02\x03\x02\x01\x08\x04\0\x0bactor-error\x03\0\x0c\x01j\x01\
\x05\x01\x0d\x01@\x03\x02to\x01\x08msg-types\x07payload\x03\0\x0e\x04\0\x04tell\x01\
\x0f\x01j\x01\x03\x01\x0d\x01@\x04\x02to\x01\x08msg-types\x07payload\x03\x0atime\
out-ms\x09\0\x10\x04\0\x03ask\x01\x11\x01j\0\x01\x0d\x01@\x02\x0ecorrelation-id\x07\
\x07payload\x03\0\x12\x04\0\x05reply\x01\x13\x01k\x07\x01@\x05\x02to\x01\x08msg-\
types\x07payload\x03\x0foriginal-sender\x01\x0ecorrelation-id\x14\0\x0e\x04\0\x07\
forward\x01\x15\x01j\x01\x01\x01\x0d\x01@\x03\x0amodule-refs\x0dinitial-state\x03\
\x07options\x0b\0\x16\x04\0\x05spawn\x01\x17\x01@\x02\x08actor-id\x01\x0atimeout\
-ms\x09\0\x12\x04\0\x04stop\x01\x18\x01@\x01\x08actor-id\x01\0\x12\x04\0\x04link\
\x01\x19\x04\0\x06unlink\x01\x19\x01j\x01w\x01\x0d\x01@\x01\x08actor-id\x01\0\x1a\
\x04\0\x07monitor\x01\x1b\x01@\x01\x0bmonitor-refw\0\x12\x04\0\x09demonitor\x01\x1c\
\x01@\0\0\x01\x04\0\x07self-id\x01\x1d\x01k\x01\x01@\0\0\x1e\x04\0\x09parent-id\x01\
\x1f\x01@\0\0w\x04\0\x03now\x01\x20\x01@\x01\x0bduration-ms\x09\x01\0\x04\0\x05s\
leep\x01!\x01@\x03\x08delay-ms\x09\x08msg-types\x07payload\x03\0\x1a\x04\0\x0ase\
nd-after\x01\"\x01@\x01\x08timer-idw\0\x12\x04\0\x0ccancel-timer\x01#\x03\x01\x20\
plexspaces:actor/messaging@0.1.0\x05\x09\x02\x03\0\x01\x0atuple-data\x02\x03\0\x01\
\x07pattern\x01B\"\x02\x03\x02\x01\x0a\x04\0\x0atuple-data\x03\0\0\x02\x03\x02\x01\
\x0b\x04\0\x07pattern\x03\0\x02\x02\x03\x02\x01\x06\x04\0\x0bduration-ms\x03\0\x04\
\x02\x03\x02\x01\x08\x04\0\x0bactor-error\x03\0\x06\x01j\0\x01\x07\x01@\x01\x0at\
uple-data\x01\0\x08\x04\0\x05write\x01\x09\x01@\x02\x0atuple-data\x01\x06ttl-ms\x05\
\0\x08\x04\0\x0ewrite-with-ttl\x01\x0a\x01k\x01\x01j\x01\x0b\x01\x07\x01@\x01\x0c\
pattern-data\x03\0\x0c\x04\0\x04read\x01\x0d\x01@\x02\x0cpattern-data\x03\x0atim\
eout-ms\x05\0\x0c\x04\0\x0dread-blocking\x01\x0e\x01p\x01\x01j\x01\x0f\x01\x07\x01\
@\x02\x0cpattern-data\x03\x05limity\0\x10\x04\0\x08read-all\x01\x11\x04\0\x04tak\
e\x01\x0d\x04\0\x0dtake-blocking\x01\x0e\x01j\x01w\x01\x07\x01@\x01\x0cpattern-d\
ata\x03\0\x12\x04\0\x05count\x01\x13\x04\0\x09subscribe\x01\x13\x01@\x01\x0fsubs\
cription-idw\0\x08\x04\0\x0bunsubscribe\x01\x14\x01j\x01\x7f\x01\x07\x01@\x03\x0c\
pattern-data\x03\x08expected\x01\x09new-tuple\x01\0\x15\x04\0\x10compare-and-swa\
p\x01\x16\x03\x01!plexspaces:actor/tuplespace@0.1.0\x05\x0c\x01B(\x02\x03\x02\x01\
\x03\x04\0\x07payload\x03\0\0\x02\x03\x02\x01\x04\x04\0\x0amessage-id\x03\0\x02\x02\
\x03\x02\x01\x06\x04\0\x0bduration-ms\x03\0\x04\x02\x03\x02\x01\x08\x04\0\x0bact\
or-error\x03\0\x06\x01o\x02ss\x01p\x08\x01r\x06\x02id\x03\x08msg-types\x07payloa\
d\x01\x09timestampw\x0edelivery-county\x07headers\x09\x04\0\x0dqueue-message\x03\
\0\x0a\x01j\x01\x03\x01\x07\x01@\x03\x0aqueue-names\x08msg-types\x07payload\x01\0\
\x0c\x04\0\x0dsend-to-queue\x01\x0d\x01@\x06\x0aqueue-names\x08msg-types\x07payl\
oad\x01\x08delay-ms\x05\x06ttl-ms\x05\x07headers\x09\0\x0c\x04\0\x1asend-to-queu\
e-with-options\x01\x0e\x01k\x0b\x01j\x01\x0f\x01\x07\x01@\x02\x0aqueue-names\x0a\
timeout-ms\x05\0\x10\x04\0\x12receive-from-queue\x01\x11\x01j\0\x01\x07\x01@\x02\
\x0aqueue-names\x0amessage-id\x03\0\x12\x04\0\x03ack\x01\x13\x01@\x03\x0aqueue-n\
ames\x0amessage-id\x03\x07requeue\x7f\0\x12\x04\0\x04nack\x01\x14\x01@\x03\x0ato\
pic-names\x08msg-types\x07payload\x01\0\x0c\x04\0\x10publish-to-topic\x01\x15\x01\
ks\x01j\x01w\x01\x07\x01@\x02\x0atopic-names\x06filter\x16\0\x17\x04\0\x12subscr\
ibe-to-topic\x01\x18\x01@\x01\x0fsubscription-idw\0\x12\x04\0\x16unsubscribe-fro\
m-topic\x01\x19\x01@\x03\x0aqueue-names\x08max-sizey\x0emessage-ttl-ms\x05\0\x12\
\x04\0\x0ccreate-queue\x01\x1a\x01@\x01\x0aqueue-names\0\x12\x04\0\x0cdelete-que\
ue\x01\x1b\x01@\x01\x0aqueue-names\0\x17\x04\0\x0bqueue-depth\x01\x1c\x03\x01\x1f\
plexspaces:actor/channels@0.1.0\x05\x0d\x01B\x1e\x02\x03\x02\x01\x03\x04\0\x07pa\
yload\x03\0\0\x02\x03\x02\x01\x08\x04\0\x0bactor-error\x03\0\x02\x01r\x04\x08seq\
uencew\x0aevent-types\x07payload\x01\x09timestampw\x04\0\x0djournal-entry\x03\0\x04\
\x01j\x01w\x01\x03\x01@\x02\x0aevent-types\x07payload\x01\0\x06\x04\0\x07persist\
\x01\x07\x01o\x02s\x01\x01p\x08\x01@\x01\x06events\x09\0\x06\x04\0\x0dpersist-ba\
tch\x01\x0a\x01@\0\0\x06\x04\0\x0acheckpoint\x01\x0b\x04\0\x0cget-sequence\x01\x0b\
\x04\0\x17get-checkpoint-sequence\x01\x0b\x01j\x01\x7f\x01\x03\x01@\0\0\x0c\x04\0\
\x0cis-replaying\x01\x0d\x01j\x01\x01\x01\x03\x01@\x02\x03keys\x0cresult-value\x01\
\0\x0e\x04\0\x11cache-side-effect\x01\x0f\x01p\x05\x01j\x01\x10\x01\x03\x01@\x03\
\x0dfrom-sequencew\x0bto-sequencew\x05limity\0\x11\x04\0\x0cread-journal\x01\x12\
\x01j\0\x01\x03\x01@\x01\x0eup-to-sequencew\0\x13\x04\0\x07compact\x01\x14\x03\x01\
!plexspaces:actor/durability@0.1.0\x05\x0e\x02\x03\0\x01\x0cactor-result\x01B!\x02\
\x03\x02\x01\x02\x04\0\x08actor-id\x03\0\0\x02\x03\x02\x01\x03\x04\0\x07payload\x03\
\0\x02\x02\x03\x02\x01\x0f\x04\0\x0cactor-result\x03\0\x04\x02\x03\x02\x01\x08\x04\
\0\x0bactor-error\x03\0\x06\x01j\0\x01s\x01@\x01\x0dinitial-state\x03\0\x08\x04\0\
\x04init\x01\x09\x01@\x03\x0afrom-actor\x01\x08msg-types\x07payload\x03\0\x05\x04\
\0\x0ehandle-message\x01\x0a\x01j\x01\x03\x01s\x01@\0\0\x0b\x04\0\x0esnapshot-st\
ate\x01\x0c\x01@\0\0\x08\x04\0\x08shutdown\x01\x0d\x01@\x02\x0afrom-actor\x01\x07\
request\x03\0\x05\x04\0\x0bhandle-call\x01\x0e\x01@\x01\x07message\x03\0\x08\x04\
\0\x0bhandle-cast\x01\x0f\x04\0\x0bhandle-info\x01\x0f\x01@\x02\x0aevent-types\x05\
event\x03\0\x08\x04\0\x0chandle-event\x01\x10\x01j\x01s\x01s\x01@\x02\x0dcurrent\
-states\x05event\x03\0\x11\x04\0\x11handle-transition\x01\x12\x01@\0\0s\x04\0\x09\
get-state\x01\x13\x04\0\x09post-init\x01\x0d\x04\0\x0bpre-suspend\x01\x0d\x04\0\x0b\
post-resume\x01\x0d\x04\x01\x1cplexspaces:actor/actor@0.1.0\x05\x10\x04\x01'plex\
spaces:actor/plexspaces-actor@0.1.0\x04\0\x0b\x16\x01\0\x10plexspaces-actor\x03\0\
\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.202.0\x10wit-bi\
ndgen-rust\x060.24.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

