// @generated
// This file is @generated by prost-build.
// ============================================================================
// PROCESS GROUP SERVICE
// ============================================================================
// Distributed pub/sub and broadcast messaging for actor coordination.
// Inspired by Erlang pg/pg2 with PlexSpaces enhancements (multi-tenancy, built-in broadcast).
// ============================================================================
// PROCESS GROUP MESSAGES
// ============================================================================

/// Process group metadata
///
/// ## Purpose
/// Represents a named group of actors for pub/sub coordination.
///
/// ## Why This Exists
/// - Groups are the fundamental unit for broadcast messaging
/// - Enables discovery (what groups exist?)
/// - Tracks group metadata (creation time, member count)
///
/// ## Storage
/// Stored in KeyValueStore with key format: `tenant:{tenant_id}:group:{group_name}`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessGroup {
    /// Unique group name (within tenant + namespace)
    ///
    /// Format: lowercase alphanumeric + hyphens + underscores
    /// Example: "config-updates", "user_events", "cluster-nodes"
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID for multi-tenancy isolation
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace for hierarchical isolation within tenant
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor IDs currently in this group
    ///
    /// NOTE: Not populated in ListGroups response (use GetMembers for member list)
    #[prost(string, repeated, tag="4")]
    pub member_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Number of members in group (across all nodes)
    #[prost(uint32, tag="5")]
    pub member_count: u32,
    /// Group metadata (labels, annotations, creation time)
    #[prost(message, optional, tag="6")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    /// When group was created
    #[prost(message, optional, tag="7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Group membership entry (internal storage representation)
///
/// ## Purpose
/// Tracks individual actor membership in a group with join_count for multiple joins.
///
/// ## Why This Exists
/// - Erlang pg2 allows multiple joins (must leave equally)
/// - Tracks which node hosts each member (for routing optimization)
/// - Enables fast local vs remote member filtering
///
/// ## Storage
/// Stored in KeyValueStore with key format:
/// `tenant:{tenant_id}:group:{group_name}:member:{actor_id}`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembership {
    /// Group name
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Actor ID in this group
    #[prost(string, tag="3")]
    pub actor_id: ::prost::alloc::string::String,
    /// Node hosting this actor (for routing optimization)
    #[prost(string, tag="4")]
    pub node_id: ::prost::alloc::string::String,
    /// How many times actor joined this group
    ///
    /// Semantics:
    /// - Incremented on each JoinGroup call
    /// - Decremented on each LeaveGroup call
    /// - Actor fully removed when join_count reaches 0
    #[prost(int32, tag="5")]
    pub join_count: i32,
    /// Topics this actor is subscribed to within the group (Erlang pg2 pub/sub pattern)
    ///
    /// ## Purpose
    /// Enables topic-based filtering within a group.
    /// Actor only receives messages published to topics they're subscribed to.
    ///
    /// ## Semantics
    /// - Empty list means actor receives all messages (no topic filtering)
    /// - Non-empty list means actor only receives messages for subscribed topics
    /// - Topics are hierarchical (e.g., "config.database", "events.user.login")
    /// - Actor can subscribe to multiple topics within same group
    ///
    /// ## Examples
    /// - \["config.database", "config.cache"\] → receives database and cache config updates
    /// - \["events.user.*"\] → receives all user events (wildcard support, future)
    /// - \[\] → receives all messages regardless of topic
    #[prost(string, repeated, tag="8")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// When actor first joined this group
    #[prost(message, optional, tag="6")]
    pub joined_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When actor last renewed membership (future: heartbeat tracking)
    #[prost(message, optional, tag="7")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================================================
// REQUEST/RESPONSE MESSAGES
// ============================================================================

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    /// Group name (required)
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID (required for multi-tenancy isolation)
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace (optional hierarchical isolation)
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
    /// Metadata (labels, annotations)
    #[prost(message, optional, tag="4")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupResponse {
    /// Created group
    #[prost(message, optional, tag="1")]
    pub group: ::core::option::Option<ProcessGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    /// Group name to delete
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID (for security - prevent cross-tenant deletion)
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinGroupRequest {
    /// Group to join
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Actor ID to add to group
    #[prost(string, tag="3")]
    pub actor_id: ::prost::alloc::string::String,
    /// Node hosting this actor (optional - can be looked up via ActorRegistry)
    #[prost(string, tag="4")]
    pub node_id: ::prost::alloc::string::String,
    /// Topics to subscribe to within the group (optional - empty = all topics)
    ///
    /// ## Purpose
    /// Enables topic-based pub/sub filtering (Erlang pg2 pattern).
    /// Actor only receives messages published to subscribed topics.
    ///
    /// ## Semantics
    /// - Empty list: Actor receives all messages (no filtering)
    /// - Non-empty list: Actor only receives messages for specified topics
    /// - Topics are hierarchical (e.g., "config.database", "events.user.login")
    /// - Actor can subscribe to multiple topics in single join call
    ///
    /// ## Examples
    /// - \["config.database"\] → only database config updates
    /// - \["events.user.login", "events.user.logout"\] → only user login/logout events
    /// - \[\] → all messages (default)
    #[prost(string, repeated, tag="5")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaveGroupRequest {
    /// Group to leave
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Actor ID to remove from group
    #[prost(string, tag="3")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMembersRequest {
    /// Group name
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Pagination (optional)
    #[prost(int32, tag="3")]
    pub page_size: i32,
    #[prost(string, tag="4")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMembersResponse {
    /// All members (cluster-wide)
    #[prost(string, repeated, tag="1")]
    pub member_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Pagination
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub total_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLocalMembersRequest {
    /// Group name
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLocalMembersResponse {
    /// Local members only (this node)
    #[prost(string, repeated, tag="1")]
    pub member_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Total count (local only)
    #[prost(int32, tag="2")]
    pub local_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {
    /// Filter by tenant (required - prevents cross-tenant access)
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Filter by namespace (optional)
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Filter by group name pattern (optional, e.g., "config-*")
    #[prost(string, tag="3")]
    pub name_pattern: ::prost::alloc::string::String,
    /// Pagination
    #[prost(int32, tag="4")]
    pub page_size: i32,
    #[prost(string, tag="5")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    /// Groups matching filter
    #[prost(message, repeated, tag="1")]
    pub groups: ::prost::alloc::vec::Vec<ProcessGroup>,
    /// Pagination
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub total_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishToGroupRequest {
    /// Group to publish to
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Tenant ID (for security - prevent cross-tenant publishing)
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Topic within the group (optional - if not specified, publishes to all members)
    ///
    /// ## Purpose
    /// Enables topic-based pub/sub within a group (Erlang pg2 pattern).
    /// Actors can subscribe to specific topics within a group.
    ///
    /// ## Semantics
    /// - If topic is empty, message is broadcast to all group members
    /// - If topic is specified, only members subscribed to that topic receive the message
    /// - Topics are hierarchical (e.g., "config.database", "events.user.login")
    /// - Topic matching supports wildcards (future: "*", "config.*")
    ///
    /// ## Examples
    /// - group_name="config-updates", topic="database" → only database config subscribers
    /// - group_name="events", topic="user.login" → only user login event subscribers
    /// - group_name="events", topic="" → all event subscribers
    #[prost(string, tag="4")]
    pub topic: ::prost::alloc::string::String,
    /// Message to broadcast to all members
    ///
    /// Uses existing Message type from actor_runtime.proto:
    /// - sender_id: Actor publishing the message
    /// - receiver_id: Will be set to each member's actor_id
    /// - message_type: Type of broadcast (e.g., "config_update", "event")
    /// - payload: Message content
    /// - priority: Message priority (system=75, high=50, normal=25, low=0)
    /// - ttl: How long to retry failed deliveries
    #[prost(message, optional, tag="3")]
    pub message: ::core::option::Option<super::super::actor::v1::Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishToGroupResponse {
    /// How many members received the message
    ///
    /// NOTE: This is best-effort count (async delivery)
    /// - Local members: Counted immediately
    /// - Remote members: May still be in-flight
    #[prost(uint32, tag="1")]
    pub recipients_count: u32,
    /// How many members were unreachable
    #[prost(uint32, tag="2")]
    pub failures_count: u32,
    /// Breakdown by node (for debugging)
    #[prost(map="string, uint32", tag="3")]
    pub recipients_per_node: ::std::collections::HashMap<::prost::alloc::string::String, u32>,
}
// @@protoc_insertion_point(module)
