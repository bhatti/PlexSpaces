// @generated
// This file is @generated by prost-build.
// ==================== Workflow Definition ====================

/// Workflow definition (versioned template)
///
/// Stored in database for querying, defines workflow structure as DAG of steps.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowDefinition {
    /// Unique definition ID (e.g., "credit-approval")
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Human-readable name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Semantic version (e.g., "1.0.0")
    #[prost(string, tag="3")]
    pub version: ::prost::alloc::string::String,
    /// Workflow steps (DAG)
    #[prost(message, repeated, tag="4")]
    pub steps: ::prost::alloc::vec::Vec<Step>,
    /// Default timeout for entire workflow
    ///
    /// Max 24 hours
    #[prost(message, optional, tag="5")]
    pub default_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Default retry policy for steps
    #[prost(message, optional, tag="6")]
    pub default_retry: ::core::option::Option<RetryConfig>,
    /// User-defined labels
    #[prost(map="string, string", tag="7")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Creation timestamp
    #[prost(message, optional, tag="8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag="9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Workflow step definition
///
/// Defines a single step in workflow DAG with dependencies, retry, and error handling.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
    /// Unique step ID within workflow
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Human-readable name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Step type (task, parallel, map, etc.)
    #[prost(enumeration="StepType", tag="3")]
    pub r#type: i32,
    /// Step IDs this depends on (for DAG ordering)
    ///
    /// Max 100 dependencies
    #[prost(string, repeated, tag="4")]
    pub depends_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Step-specific timeout
    ///
    /// Max 1 hour
    #[prost(message, optional, tag="5")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Retry configuration
    #[prost(message, optional, tag="6")]
    pub retry: ::core::option::Option<RetryConfig>,
    /// Step ID to run on error (compensation/saga)
    #[prost(string, tag="7")]
    pub on_error: ::prost::alloc::string::String,
    /// Type-specific configuration (JSON)
    #[prost(message, optional, tag="8")]
    pub config: ::core::option::Option<::prost_types::Struct>,
}
/// Retry configuration
///
/// Exponential backoff retry policy with error type matching.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryConfig {
    /// Maximum retry attempts
    ///
    /// 1 to 1000 retries
    #[prost(uint32, tag="1")]
    pub max_attempts: u32,
    /// Initial retry interval (milliseconds)
    ///
    /// 1ms to 5 minutes
    #[prost(uint32, tag="2")]
    pub initial_interval_ms: u32,
    /// Exponential backoff rate (e.g., 2.0 for doubling)
    ///
    /// 1x to 10x
    #[prost(double, tag="3")]
    pub backoff_rate: f64,
    /// Maximum retry interval (milliseconds)
    ///
    /// 1ms to 1 hour
    #[prost(uint32, tag="4")]
    pub max_interval_ms: u32,
    /// Error types to retry (empty = retry all)
    #[prost(string, repeated, tag="5")]
    pub retryable_errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
// ==================== Workflow Execution ====================

/// Workflow execution (metadata)
///
/// Stored in database for querying. Full state is in journal.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecution {
    /// Unique execution ID (ULID)
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
    /// Workflow definition ID
    #[prost(string, tag="2")]
    pub definition_id: ::prost::alloc::string::String,
    /// Workflow definition version
    #[prost(string, tag="3")]
    pub definition_version: ::prost::alloc::string::String,
    /// Current execution status
    #[prost(enumeration="ExecutionStatus", tag="4")]
    pub status: i32,
    /// Currently executing step ID
    #[prost(string, tag="5")]
    pub current_step_id: ::prost::alloc::string::String,
    /// Initial workflow input
    #[prost(message, optional, tag="6")]
    pub input: ::core::option::Option<::prost_types::Struct>,
    /// Final workflow output (if completed)
    #[prost(message, optional, tag="7")]
    pub output: ::core::option::Option<::prost_types::Struct>,
    /// Error message (if failed)
    #[prost(string, tag="8")]
    pub error: ::prost::alloc::string::String,
    /// Node executing this workflow
    #[prost(string, tag="9")]
    pub node_id: ::prost::alloc::string::String,
    /// Creation timestamp
    #[prost(message, optional, tag="10")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Start timestamp
    #[prost(message, optional, tag="11")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Completion timestamp
    #[prost(message, optional, tag="12")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag="13")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// User-defined labels
    #[prost(map="string, string", tag="14")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Step execution (metadata)
///
/// Stored in database for history/monitoring. Full state in journal.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepExecution {
    /// Unique step execution ID (ULID)
    #[prost(string, tag="1")]
    pub step_execution_id: ::prost::alloc::string::String,
    /// Parent workflow execution ID
    #[prost(string, tag="2")]
    pub execution_id: ::prost::alloc::string::String,
    /// Step definition ID
    #[prost(string, tag="3")]
    pub step_id: ::prost::alloc::string::String,
    /// Step status
    #[prost(enumeration="StepStatus", tag="4")]
    pub status: i32,
    /// Step input
    #[prost(message, optional, tag="5")]
    pub input: ::core::option::Option<::prost_types::Struct>,
    /// Step output
    #[prost(message, optional, tag="6")]
    pub output: ::core::option::Option<::prost_types::Struct>,
    /// Error message (if failed)
    #[prost(string, tag="7")]
    pub error: ::prost::alloc::string::String,
    /// Retry attempt number
    ///
    /// Max 1000 attempts
    #[prost(uint32, tag="8")]
    pub attempt: u32,
    /// Start timestamp
    #[prost(message, optional, tag="9")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Completion timestamp
    #[prost(message, optional, tag="10")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
}
// ==================== Request/Response Messages ====================

// Definition management

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDefinitionRequest {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<WorkflowDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDefinitionResponse {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<WorkflowDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefinitionRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Empty = latest version
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefinitionResponse {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<WorkflowDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDefinitionsRequest {
    #[prost(message, optional, tag="1")]
    pub page: ::core::option::Option<super::super::common::v1::PageRequest>,
    #[prost(map="string, string", tag="2")]
    pub label_filter: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDefinitionsResponse {
    #[prost(message, repeated, tag="1")]
    pub definitions: ::prost::alloc::vec::Vec<WorkflowDefinition>,
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDefinitionRequest {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<WorkflowDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDefinitionResponse {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<WorkflowDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDefinitionRequest {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Empty = delete all versions
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
}
// Execution management

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartExecutionRequest {
    #[prost(string, tag="1")]
    pub definition_id: ::prost::alloc::string::String,
    /// Empty = latest version
    #[prost(string, tag="2")]
    pub definition_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub input: ::core::option::Option<::prost_types::Struct>,
    /// Optional - auto-generate if empty
    #[prost(string, tag="4")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="5")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartExecutionResponse {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExecutionRequest {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExecutionResponse {
    #[prost(message, optional, tag="1")]
    pub execution: ::core::option::Option<WorkflowExecution>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsRequest {
    #[prost(message, optional, tag="1")]
    pub page: ::core::option::Option<super::super::common::v1::PageRequest>,
    #[prost(string, tag="2")]
    pub definition_id: ::prost::alloc::string::String,
    #[prost(enumeration="ExecutionStatus", tag="3")]
    pub status: i32,
    #[prost(map="string, string", tag="4")]
    pub label_filter: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub started_after: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub started_before: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsResponse {
    #[prost(message, repeated, tag="1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecution>,
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelExecutionRequest {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalExecutionRequest {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub data: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExecutionRequest {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
    /// "status", "context", "current_step"
    #[prost(string, tag="2")]
    pub query_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExecutionResponse {
    #[prost(message, optional, tag="1")]
    pub result: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStepExecutionsRequest {
    #[prost(string, tag="1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStepExecutionsResponse {
    #[prost(message, repeated, tag="1")]
    pub step_executions: ::prost::alloc::vec::Vec<StepExecution>,
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// Step types (simplified)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StepType {
    StepTypeUnspecified = 0,
    /// Execute actor method
    StepTypeTask = 1,
    /// Execute steps in parallel
    StepTypeParallel = 2,
    /// Map over collection (parallel iteration)
    StepTypeMap = 3,
    /// Wait for duration
    StepTypeWait = 4,
    /// Conditional branching
    StepTypeChoice = 5,
    /// Wait for external signal
    StepTypeSignal = 6,
}
impl StepType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StepType::StepTypeUnspecified => "STEP_TYPE_UNSPECIFIED",
            StepType::StepTypeTask => "STEP_TYPE_TASK",
            StepType::StepTypeParallel => "STEP_TYPE_PARALLEL",
            StepType::StepTypeMap => "STEP_TYPE_MAP",
            StepType::StepTypeWait => "STEP_TYPE_WAIT",
            StepType::StepTypeChoice => "STEP_TYPE_CHOICE",
            StepType::StepTypeSignal => "STEP_TYPE_SIGNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEP_TYPE_UNSPECIFIED" => Some(Self::StepTypeUnspecified),
            "STEP_TYPE_TASK" => Some(Self::StepTypeTask),
            "STEP_TYPE_PARALLEL" => Some(Self::StepTypeParallel),
            "STEP_TYPE_MAP" => Some(Self::StepTypeMap),
            "STEP_TYPE_WAIT" => Some(Self::StepTypeWait),
            "STEP_TYPE_CHOICE" => Some(Self::StepTypeChoice),
            "STEP_TYPE_SIGNAL" => Some(Self::StepTypeSignal),
            _ => None,
        }
    }
}
/// Execution status
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    ExecutionStatusUnspecified = 0,
    ExecutionStatusPending = 1,
    ExecutionStatusRunning = 2,
    ExecutionStatusCompleted = 3,
    ExecutionStatusFailed = 4,
    ExecutionStatusCancelled = 5,
    ExecutionStatusTimedOut = 6,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionStatus::ExecutionStatusUnspecified => "EXECUTION_STATUS_UNSPECIFIED",
            ExecutionStatus::ExecutionStatusPending => "EXECUTION_STATUS_PENDING",
            ExecutionStatus::ExecutionStatusRunning => "EXECUTION_STATUS_RUNNING",
            ExecutionStatus::ExecutionStatusCompleted => "EXECUTION_STATUS_COMPLETED",
            ExecutionStatus::ExecutionStatusFailed => "EXECUTION_STATUS_FAILED",
            ExecutionStatus::ExecutionStatusCancelled => "EXECUTION_STATUS_CANCELLED",
            ExecutionStatus::ExecutionStatusTimedOut => "EXECUTION_STATUS_TIMED_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_STATUS_UNSPECIFIED" => Some(Self::ExecutionStatusUnspecified),
            "EXECUTION_STATUS_PENDING" => Some(Self::ExecutionStatusPending),
            "EXECUTION_STATUS_RUNNING" => Some(Self::ExecutionStatusRunning),
            "EXECUTION_STATUS_COMPLETED" => Some(Self::ExecutionStatusCompleted),
            "EXECUTION_STATUS_FAILED" => Some(Self::ExecutionStatusFailed),
            "EXECUTION_STATUS_CANCELLED" => Some(Self::ExecutionStatusCancelled),
            "EXECUTION_STATUS_TIMED_OUT" => Some(Self::ExecutionStatusTimedOut),
            _ => None,
        }
    }
}
/// Step status
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StepStatus {
    StepStatusUnspecified = 0,
    StepStatusPending = 1,
    StepStatusRunning = 2,
    StepStatusCompleted = 3,
    StepStatusFailed = 4,
    StepStatusRetrying = 5,
    StepStatusCancelled = 6,
}
impl StepStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StepStatus::StepStatusUnspecified => "STEP_STATUS_UNSPECIFIED",
            StepStatus::StepStatusPending => "STEP_STATUS_PENDING",
            StepStatus::StepStatusRunning => "STEP_STATUS_RUNNING",
            StepStatus::StepStatusCompleted => "STEP_STATUS_COMPLETED",
            StepStatus::StepStatusFailed => "STEP_STATUS_FAILED",
            StepStatus::StepStatusRetrying => "STEP_STATUS_RETRYING",
            StepStatus::StepStatusCancelled => "STEP_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEP_STATUS_UNSPECIFIED" => Some(Self::StepStatusUnspecified),
            "STEP_STATUS_PENDING" => Some(Self::StepStatusPending),
            "STEP_STATUS_RUNNING" => Some(Self::StepStatusRunning),
            "STEP_STATUS_COMPLETED" => Some(Self::StepStatusCompleted),
            "STEP_STATUS_FAILED" => Some(Self::StepStatusFailed),
            "STEP_STATUS_RETRYING" => Some(Self::StepStatusRetrying),
            "STEP_STATUS_CANCELLED" => Some(Self::StepStatusCancelled),
            _ => None,
        }
    }
}
// ==================== Error Types ====================

/// Workflow error types
///
/// ## Purpose
/// Defines error types for workflow operations (storage, serialization, execution).
/// Used in error responses and for error handling in workflow service.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowError {
    WorkflowErrorUnspecified = 0,
    /// Storage operation failed (database, journal, etc.)
    WorkflowErrorStorage = 1,
    /// Serialization/deserialization failed
    WorkflowErrorSerialization = 2,
    /// Workflow or execution not found
    WorkflowErrorNotFound = 3,
    /// Invalid workflow definition
    WorkflowErrorInvalidDefinition = 4,
    /// Execution error (runtime failure)
    WorkflowErrorExecution = 5,
}
impl WorkflowError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkflowError::WorkflowErrorUnspecified => "WORKFLOW_ERROR_UNSPECIFIED",
            WorkflowError::WorkflowErrorStorage => "WORKFLOW_ERROR_STORAGE",
            WorkflowError::WorkflowErrorSerialization => "WORKFLOW_ERROR_SERIALIZATION",
            WorkflowError::WorkflowErrorNotFound => "WORKFLOW_ERROR_NOT_FOUND",
            WorkflowError::WorkflowErrorInvalidDefinition => "WORKFLOW_ERROR_INVALID_DEFINITION",
            WorkflowError::WorkflowErrorExecution => "WORKFLOW_ERROR_EXECUTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_ERROR_UNSPECIFIED" => Some(Self::WorkflowErrorUnspecified),
            "WORKFLOW_ERROR_STORAGE" => Some(Self::WorkflowErrorStorage),
            "WORKFLOW_ERROR_SERIALIZATION" => Some(Self::WorkflowErrorSerialization),
            "WORKFLOW_ERROR_NOT_FOUND" => Some(Self::WorkflowErrorNotFound),
            "WORKFLOW_ERROR_INVALID_DEFINITION" => Some(Self::WorkflowErrorInvalidDefinition),
            "WORKFLOW_ERROR_EXECUTION" => Some(Self::WorkflowErrorExecution),
            _ => None,
        }
    }
}
include!("plexspaces.workflow.v1.tonic.rs");
// @@protoc_insertion_point(module)