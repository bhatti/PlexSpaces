// @generated
// This file is @generated by prost-build.
/// Mailbox configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailboxConfig {
    /// Type of mailbox
    #[prost(enumeration="MailboxType", tag="1")]
    pub mailbox_type: i32,
    /// Maximum queue capacity (0 = unlimited for UNBOUNDED)
    #[prost(uint32, tag="2")]
    pub capacity: u32,
    /// Backpressure strategy when queue is full
    #[prost(enumeration="BackpressureStrategy", tag="3")]
    pub backpressure_strategy: i32,
    /// Message timeout (how long messages wait before being dropped)
    #[prost(message, optional, tag="4")]
    pub message_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Enable priority-based processing
    #[prost(bool, tag="5")]
    pub enable_priority: bool,
    /// Enable message deduplication
    #[prost(bool, tag="6")]
    pub enable_deduplication: bool,
    /// Deduplication window
    #[prost(message, optional, tag="7")]
    pub deduplication_window: ::core::option::Option<::prost_types::Duration>,
    /// Maximum cache size for message ID deduplication (default: 10000)
    /// LRU cache with fixed size - evicts least recently used when full
    /// Range: 100 to 1,000,000 entries
    #[prost(uint32, tag="14")]
    pub message_id_cache_size: u32,
    /// Maximum cache size for idempotency key deduplication (default: 10000)
    /// LRU cache with fixed size - evicts least recently used when full
    /// Range: 100 to 1,000,000 entries
    #[prost(uint32, tag="15")]
    pub idempotency_cache_size: u32,
    /// Storage strategy (where messages are stored)
    #[prost(enumeration="StorageStrategy", tag="8")]
    pub storage_strategy: i32,
    /// Ordering strategy (how messages are ordered)
    #[prost(enumeration="OrderingStrategy", tag="9")]
    pub ordering_strategy: i32,
    /// Durability strategy (durability guarantees)
    /// This is a hint/requirement - the actual implementation is determined by channel_backend
    #[prost(enumeration="DurabilityStrategy", tag="10")]
    pub durability_strategy: i32,
    /// Channel backend implementation (defaults to IN_MEMORY if not specified)
    /// This directly specifies which channel backend to use for the mailbox.
    /// The backend must be available/configured, otherwise mailbox creation will fail.
    #[prost(enumeration="super::super::channel::v1::ChannelBackend", tag="12")]
    pub channel_backend: i32,
    /// Channel-specific configuration (optional, backend-specific)
    /// Only used if channel_backend is specified. If not provided, backend uses defaults.
    #[prost(message, optional, tag="13")]
    pub channel_config: ::core::option::Option<super::super::channel::v1::ChannelConfig>,
    /// Metadata
    #[prost(map="string, string", tag="11")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Mailbox statistics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailboxStats {
    /// Actor this mailbox belongs to
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Current queue depth
    #[prost(uint32, tag="2")]
    pub current_depth: u32,
    /// Maximum depth reached
    #[prost(uint32, tag="3")]
    pub max_depth: u32,
    /// Total messages enqueued
    #[prost(uint64, tag="4")]
    pub total_enqueued: u64,
    /// Total messages dequeued
    #[prost(uint64, tag="5")]
    pub total_dequeued: u64,
    /// Total messages dropped
    #[prost(uint64, tag="6")]
    pub total_dropped: u64,
    /// Total messages timed out
    #[prost(uint64, tag="7")]
    pub total_timed_out: u64,
    /// Average wait time
    #[prost(message, optional, tag="8")]
    pub avg_wait_time: ::core::option::Option<::prost_types::Duration>,
    /// Oldest message timestamp
    #[prost(message, optional, tag="9")]
    pub oldest_message_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag="10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Message envelope for mailbox
///
/// ## Note
/// This is the proto representation of the internal `Message` struct.
/// The Rust `Message` type should use this proto-generated type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageEnvelope {
    /// Unique message ID
    #[prost(string, tag="1")]
    pub message_id: ::prost::alloc::string::String,
    /// Message type
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
    /// Message payload
    #[prost(bytes="vec", tag="3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Sender actor ID
    #[prost(string, tag="4")]
    pub sender_id: ::prost::alloc::string::String,
    /// Recipient actor ID
    #[prost(string, tag="5")]
    pub recipient_id: ::prost::alloc::string::String,
    /// Message priority
    #[prost(enumeration="MessagePriority", tag="6")]
    pub priority: i32,
    /// When message was enqueued
    #[prost(message, optional, tag="7")]
    pub enqueued_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Message expiration time
    #[prost(message, optional, tag="8")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Correlation ID for request-reply
    #[prost(string, tag="9")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Message metadata
    #[prost(map="string, string", tag="10")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMailboxRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<MailboxConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMailboxResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMailboxRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMailboxStatsRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMailboxStatsResponse {
    #[prost(message, optional, tag="1")]
    pub stats: ::core::option::Option<MailboxStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMailboxConfigRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<MailboxConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeMailboxRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeMailboxResponse {
    #[prost(uint32, tag="1")]
    pub messages_purged: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMailboxesRequest {
    /// Optional filter
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMailboxesResponse {
    #[prost(message, repeated, tag="1")]
    pub mailboxes: ::prost::alloc::vec::Vec<MailboxInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailboxInfo {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<MailboxConfig>,
    #[prost(message, optional, tag="3")]
    pub stats: ::core::option::Option<MailboxStats>,
}
/// Mailbox type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MailboxType {
    MailboxTypeUnspecified = 0,
    /// First-In-First-Out queue
    Fifo = 1,
    /// Priority-based queue
    Priority = 2,
    /// Bounded queue with backpressure
    Bounded = 3,
    /// Unbounded queue (default)
    Unbounded = 4,
}
impl MailboxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MailboxType::MailboxTypeUnspecified => "MAILBOX_TYPE_UNSPECIFIED",
            MailboxType::Fifo => "FIFO",
            MailboxType::Priority => "PRIORITY",
            MailboxType::Bounded => "BOUNDED",
            MailboxType::Unbounded => "UNBOUNDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAILBOX_TYPE_UNSPECIFIED" => Some(Self::MailboxTypeUnspecified),
            "FIFO" => Some(Self::Fifo),
            "PRIORITY" => Some(Self::Priority),
            "BOUNDED" => Some(Self::Bounded),
            "UNBOUNDED" => Some(Self::Unbounded),
            _ => None,
        }
    }
}
/// Message priority
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessagePriority {
    MessagePriorityUnspecified = 0,
    Lowest = 1,
    Low = 2,
    Normal = 3,
    High = 4,
    Highest = 5,
    /// System messages always processed first
    System = 10,
}
impl MessagePriority {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MessagePriority::MessagePriorityUnspecified => "MESSAGE_PRIORITY_UNSPECIFIED",
            MessagePriority::Lowest => "LOWEST",
            MessagePriority::Low => "LOW",
            MessagePriority::Normal => "NORMAL",
            MessagePriority::High => "HIGH",
            MessagePriority::Highest => "HIGHEST",
            MessagePriority::System => "SYSTEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_PRIORITY_UNSPECIFIED" => Some(Self::MessagePriorityUnspecified),
            "LOWEST" => Some(Self::Lowest),
            "LOW" => Some(Self::Low),
            "NORMAL" => Some(Self::Normal),
            "HIGH" => Some(Self::High),
            "HIGHEST" => Some(Self::Highest),
            "SYSTEM" => Some(Self::System),
            _ => None,
        }
    }
}
/// Backpressure strategy when mailbox is full
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackpressureStrategy {
    BackpressureStrategyUnspecified = 0,
    /// Block sender until space is available
    Block = 1,
    /// Drop oldest message in queue
    DropOldest = 2,
    /// Drop newest message (reject)
    DropNewest = 3,
    /// Return error to sender
    Error = 4,
}
impl BackpressureStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BackpressureStrategy::BackpressureStrategyUnspecified => "BACKPRESSURE_STRATEGY_UNSPECIFIED",
            BackpressureStrategy::Block => "BLOCK",
            BackpressureStrategy::DropOldest => "DROP_OLDEST",
            BackpressureStrategy::DropNewest => "DROP_NEWEST",
            BackpressureStrategy::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKPRESSURE_STRATEGY_UNSPECIFIED" => Some(Self::BackpressureStrategyUnspecified),
            "BLOCK" => Some(Self::Block),
            "DROP_OLDEST" => Some(Self::DropOldest),
            "DROP_NEWEST" => Some(Self::DropNewest),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Storage strategy for mailbox messages
///
/// ## Purpose
/// Defines where mailbox messages are stored (memory, disk, distributed).
/// Composable strategy pattern for flexible mailbox implementations.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageStrategy {
    StorageStrategyUnspecified = 0,
    /// In-memory only (fastest, lost on restart)
    Memory = 1,
    /// Disk-backed (spills to disk when full, survives restart)
    Disk = 2,
    /// Distributed (Redis, Kafka, etc. for multi-node)
    Distributed = 3,
}
impl StorageStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StorageStrategy::StorageStrategyUnspecified => "STORAGE_STRATEGY_UNSPECIFIED",
            StorageStrategy::Memory => "MEMORY",
            StorageStrategy::Disk => "DISK",
            StorageStrategy::Distributed => "DISTRIBUTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_STRATEGY_UNSPECIFIED" => Some(Self::StorageStrategyUnspecified),
            "MEMORY" => Some(Self::Memory),
            "DISK" => Some(Self::Disk),
            "DISTRIBUTED" => Some(Self::Distributed),
            _ => None,
        }
    }
}
/// Ordering strategy for mailbox messages
///
/// ## Purpose
/// Defines how messages are ordered when dequeued.
/// Composable strategy pattern for flexible mailbox implementations.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderingStrategy {
    OrderingStrategyUnspecified = 0,
    /// First-in-first-out (default, preserves order)
    OrderingFifo = 1,
    /// Priority-based (high priority first)
    OrderingPriority = 2,
    /// LIFO (last-in-first-out, stack-like)
    OrderingLifo = 3,
    /// Random (for load balancing)
    OrderingRandom = 4,
}
impl OrderingStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrderingStrategy::OrderingStrategyUnspecified => "ORDERING_STRATEGY_UNSPECIFIED",
            OrderingStrategy::OrderingFifo => "ORDERING_FIFO",
            OrderingStrategy::OrderingPriority => "ORDERING_PRIORITY",
            OrderingStrategy::OrderingLifo => "ORDERING_LIFO",
            OrderingStrategy::OrderingRandom => "ORDERING_RANDOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDERING_STRATEGY_UNSPECIFIED" => Some(Self::OrderingStrategyUnspecified),
            "ORDERING_FIFO" => Some(Self::OrderingFifo),
            "ORDERING_PRIORITY" => Some(Self::OrderingPriority),
            "ORDERING_LIFO" => Some(Self::OrderingLifo),
            "ORDERING_RANDOM" => Some(Self::OrderingRandom),
            _ => None,
        }
    }
}
/// Durability strategy for mailbox messages
///
/// ## Purpose
/// Defines durability guarantees for mailbox messages.
/// Composable strategy pattern for flexible mailbox implementations.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DurabilityStrategy {
    DurabilityStrategyUnspecified = 0,
    /// No durability (messages lost on crash)
    DurabilityNone = 1,
    /// At-least-once delivery (journaled, may replay)
    DurabilityAtLeastOnce = 2,
    /// Exactly-once delivery (with deduplication)
    DurabilityExactlyOnce = 3,
    /// Fully durable (messages persisted immediately)
    DurabilityDurable = 4,
}
impl DurabilityStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DurabilityStrategy::DurabilityStrategyUnspecified => "DURABILITY_STRATEGY_UNSPECIFIED",
            DurabilityStrategy::DurabilityNone => "DURABILITY_NONE",
            DurabilityStrategy::DurabilityAtLeastOnce => "DURABILITY_AT_LEAST_ONCE",
            DurabilityStrategy::DurabilityExactlyOnce => "DURABILITY_EXACTLY_ONCE",
            DurabilityStrategy::DurabilityDurable => "DURABILITY_DURABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DURABILITY_STRATEGY_UNSPECIFIED" => Some(Self::DurabilityStrategyUnspecified),
            "DURABILITY_NONE" => Some(Self::DurabilityNone),
            "DURABILITY_AT_LEAST_ONCE" => Some(Self::DurabilityAtLeastOnce),
            "DURABILITY_EXACTLY_ONCE" => Some(Self::DurabilityExactlyOnce),
            "DURABILITY_DURABLE" => Some(Self::DurabilityDurable),
            _ => None,
        }
    }
}
/// Mailbox error types
///
/// ## Purpose
/// Defines error types for mailbox operations.
/// Used in error responses and for error handling in mailbox service.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MailboxError {
    MailboxErrorUnspecified = 0,
    /// Mailbox not found
    MailboxErrorNotFound = 1,
    /// Mailbox is full (backpressure triggered)
    MailboxErrorFull = 2,
    /// Message timeout (message expired)
    MailboxErrorTimeout = 3,
    /// Invalid configuration
    MailboxErrorInvalidConfig = 4,
    /// Storage operation failed
    MailboxErrorStorage = 5,
    /// Serialization/deserialization failed
    MailboxErrorSerialization = 6,
}
impl MailboxError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MailboxError::MailboxErrorUnspecified => "MAILBOX_ERROR_UNSPECIFIED",
            MailboxError::MailboxErrorNotFound => "MAILBOX_ERROR_NOT_FOUND",
            MailboxError::MailboxErrorFull => "MAILBOX_ERROR_FULL",
            MailboxError::MailboxErrorTimeout => "MAILBOX_ERROR_TIMEOUT",
            MailboxError::MailboxErrorInvalidConfig => "MAILBOX_ERROR_INVALID_CONFIG",
            MailboxError::MailboxErrorStorage => "MAILBOX_ERROR_STORAGE",
            MailboxError::MailboxErrorSerialization => "MAILBOX_ERROR_SERIALIZATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAILBOX_ERROR_UNSPECIFIED" => Some(Self::MailboxErrorUnspecified),
            "MAILBOX_ERROR_NOT_FOUND" => Some(Self::MailboxErrorNotFound),
            "MAILBOX_ERROR_FULL" => Some(Self::MailboxErrorFull),
            "MAILBOX_ERROR_TIMEOUT" => Some(Self::MailboxErrorTimeout),
            "MAILBOX_ERROR_INVALID_CONFIG" => Some(Self::MailboxErrorInvalidConfig),
            "MAILBOX_ERROR_STORAGE" => Some(Self::MailboxErrorStorage),
            "MAILBOX_ERROR_SERIALIZATION" => Some(Self::MailboxErrorSerialization),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
