// @generated
// This file is @generated by prost-build.
/// System information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfo {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub build_date: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub git_commit: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub uptime: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag="5")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub platform: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub architecture: ::prost::alloc::string::String,
    #[prost(int32, tag="8")]
    pub cpu_cores: i32,
    #[prost(uint64, tag="9")]
    pub total_memory_mb: u64,
    #[prost(string, repeated, tag="10")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Health check result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheck {
    #[prost(string, tag="1")]
    pub component: ::prost::alloc::string::String,
    #[prost(enumeration="HealthStatus", tag="2")]
    pub status: i32,
    #[prost(string, tag="3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub checked_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub response_time: ::core::option::Option<::prost_types::Duration>,
    #[prost(map="string, message", tag="6")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
}
// System metrics are now defined in metrics.proto (observability core)
// Import and use: plexspaces.metrics.v1.SystemMetrics

/// Configuration setting
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSetting {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub is_secret: bool,
    #[prost(bool, tag="5")]
    pub requires_restart: bool,
    #[prost(message, optional, tag="6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="7")]
    pub updated_by: ::prost::alloc::string::String,
}
/// Log entry
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogEntry {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration="LogLevel", tag="2")]
    pub level: i32,
    #[prost(string, tag="3")]
    pub component: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub message: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="5")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
    #[prost(string, tag="6")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub span_id: ::prost::alloc::string::String,
}
/// Backup information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupInfo {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration="BackupType", tag="2")]
    pub r#type: i32,
    #[prost(enumeration="BackupStatus", tag="3")]
    pub status: i32,
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="6")]
    pub size_bytes: u64,
    #[prost(string, tag="7")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="9")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="10")]
    pub error: ::prost::alloc::string::String,
}
// Requests and responses

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoRequest {
    #[prost(bool, tag="1")]
    pub include_details: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoResponse {
    #[prost(message, optional, tag="1")]
    pub system_info: ::core::option::Option<SystemInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthRequest {
    /// If empty, check all components
    #[prost(string, repeated, tag="1")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthResponse {
    #[prost(enumeration="HealthStatus", tag="1")]
    pub overall_status: i32,
    #[prost(message, repeated, tag="2")]
    pub checks: ::prost::alloc::vec::Vec<HealthCheck>,
}
/// Node Health State for Kubernetes-style probes
///
/// ## Purpose
/// Tracks the current health state of a PlexSpaces node using Kubernetes
/// startup/liveness/readiness probe semantics.
///
/// ## Why This Exists
/// - Kubernetes requires health probes to determine when to restart pods (liveness)
///    and when to route traffic (readiness)
/// - Standard gRPC Health Protocol (grpc.health.v1.Health) provides the transport,
///    but we need to track the internal state
/// - Enables graceful shutdown with request draining
///
/// ## Design Notes
/// - This message is stored internally in PlexSpacesHealthReporter
/// - Not directly exposed via gRPC (use grpc.health.v1.Health.Check instead)
/// - Maps to ServingStatus: SERVING or NOT_SERVING
///
/// ## Health State Machine
/// ```
/// NOT_SERVING (startup) → SERVING (ready) → NOT_SERVING (shutdown/overload)
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeHealthState {
    /// Current serving status (maps to grpc.health.v1.ServingStatus)
    #[prost(enumeration="ServingStatus", tag="1")]
    pub serving_status: i32,
    /// Why the node is in this state
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
    /// When this state was entered
    #[prost(message, optional, tag="3")]
    pub state_entered_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Startup probe: Has initialization completed?
    #[prost(bool, tag="4")]
    pub startup_complete: bool,
    /// Liveness probe: Is the node alive (or should it be restarted)?
    #[prost(bool, tag="5")]
    pub is_alive: bool,
    /// Readiness probe: Is the node ready to accept requests?
    #[prost(bool, tag="6")]
    pub is_ready: bool,
    /// Graceful shutdown in progress
    #[prost(bool, tag="7")]
    pub shutdown_in_progress: bool,
    /// Number of in-flight requests being drained
    #[prost(uint64, tag="8")]
    pub in_flight_requests: u64,
}
/// Node readiness status (detailed)
///
/// ## Purpose
/// Detailed breakdown of readiness checks to help diagnose why a node is not ready.
///
/// ## Why This Exists
/// - Readiness probe just returns SERVING/NOT_SERVING
/// - This message explains WHY the node is not ready
/// - Useful for debugging and observability
///
/// ## Usage
/// - Exposed via custom GetNodeReadiness RPC (optional)
/// - Not used by Kubernetes probes (those use standard Health service)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeReadinessStatus {
    /// Overall readiness
    #[prost(bool, tag="1")]
    pub is_ready: bool,
    /// Reason if not ready
    #[prost(string, tag="2")]
    pub not_ready_reason: ::prost::alloc::string::String,
    /// Individual readiness checks
    ///
    /// Is node alive?
    #[prost(bool, tag="3")]
    pub liveness_passing: bool,
    /// Queue depth < threshold?
    #[prost(bool, tag="4")]
    pub queue_depth_ok: bool,
    /// TupleSpace backend reachable?
    #[prost(bool, tag="5")]
    pub tuplespace_healthy: bool,
    /// Required nodes connected?
    #[prost(bool, tag="6")]
    pub required_nodes_connected: bool,
    /// Metrics
    #[prost(uint64, tag="7")]
    pub total_queue_depth: u64,
    #[prost(uint64, tag="8")]
    pub queue_depth_threshold: u64,
    #[prost(uint32, tag="9")]
    pub connected_nodes_count: u32,
    #[prost(string, repeated, tag="10")]
    pub required_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required nodes not connected
    #[prost(string, repeated, tag="11")]
    pub missing_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Health probe configuration
///
/// ## Purpose
/// Configuration for health probe behavior (thresholds, timeouts, etc.)
///
/// ## Why This Exists
/// - Makes health probe behavior configurable
/// - Can be adjusted based on deployment environment
/// - Allows tuning for different workload characteristics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthProbeConfig {
    /// Monitoring interval (how often to check health)
    ///
    /// Default: 5 seconds
    #[prost(message, optional, tag="1")]
    pub monitoring_interval: ::core::option::Option<::prost_types::Duration>,
    /// Graceful shutdown drain timeout
    ///
    /// Default: 30 seconds
    #[prost(message, optional, tag="2")]
    pub drain_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Queue depth threshold for readiness
    ///
    /// Default: 10000
    #[prost(uint64, tag="3")]
    pub queue_depth_threshold: u64,
    /// Required nodes for readiness (if empty, no requirement)
    #[prost(string, repeated, tag="4")]
    pub required_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Enable detailed health logging
    #[prost(bool, tag="5")]
    pub enable_detailed_logging: bool,
    /// Automatic dependency registration configuration
    ///
    /// ## Purpose
    /// Configures automatic registration of health checkers for dependencies
    /// discovered via object-registry by name/type.
    ///
    /// ## Design Notes
    /// - Dependencies are registered automatically at startup
    /// - Uses object-registry to discover services by name/type
    /// - Supports both critical and non-critical dependencies
    #[prost(message, optional, tag="6")]
    pub dependency_registration: ::core::option::Option<DependencyRegistrationConfig>,
}
/// Dependency registration configuration
///
/// ## Purpose
/// Configures automatic registration of health checkers for dependencies
/// discovered via object-registry.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyRegistrationConfig {
    /// Whether to enable automatic dependency registration
    #[prost(bool, tag="1")]
    pub enabled: bool,
    /// Dependencies to register automatically
    /// Format: "name:type:critical" (e.g., "database:service:true", "redis:service:false")
    #[prost(string, repeated, tag="2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default namespace for dependency lookup
    #[prost(string, tag="3")]
    pub default_namespace: ::prost::alloc::string::String,
    /// Default tenant for dependency lookup
    #[prost(string, tag="4")]
    pub default_tenant: ::prost::alloc::string::String,
}
/// Dependency health check
///
/// ## Purpose
/// Represents a health check for a specific dependency (database, external service, etc.)
/// Supports critical vs non-critical dependencies for partial failure scenarios.
///
/// ## Design Notes
/// - Critical dependencies block readiness/startup if unhealthy
/// - Non-critical dependencies allow partial failure (circuit breaker fallback)
/// - Each dependency has a name and check function
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyCheck {
    /// Name of the dependency (e.g., "database", "redis", "external-api")
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Whether this dependency is critical for readiness/startup
    /// - Critical: Node not ready if dependency unhealthy
    /// - Non-critical: Node can be ready even if dependency unhealthy (fallback)
    #[prost(bool, tag="2")]
    pub is_critical: bool,
    /// Current health status
    #[prost(enumeration="HealthStatus", tag="3")]
    pub status: i32,
    /// Error message if unhealthy
    #[prost(string, tag="4")]
    pub error_message: ::prost::alloc::string::String,
    /// When this check was last performed
    #[prost(message, optional, tag="5")]
    pub checked_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Response time for the check
    #[prost(message, optional, tag="6")]
    pub response_time: ::core::option::Option<::prost_types::Duration>,
    /// Additional details (key-value pairs)
    #[prost(map="string, message", tag="7")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Value>,
}
/// Health check result with dependency breakdown
///
/// ## Purpose
/// Extends HealthCheck to include dependency checks for detailed diagnostics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailedHealthCheck {
    /// Overall health status
    #[prost(enumeration="HealthStatus", tag="1")]
    pub overall_status: i32,
    /// Individual component checks
    #[prost(message, repeated, tag="2")]
    pub component_checks: ::prost::alloc::vec::Vec<HealthCheck>,
    /// Dependency checks (critical and non-critical)
    #[prost(message, repeated, tag="3")]
    pub dependency_checks: ::prost::alloc::vec::Vec<DependencyCheck>,
    /// Whether all critical dependencies are healthy
    #[prost(bool, tag="4")]
    pub critical_dependencies_healthy: bool,
    /// Whether any non-critical dependencies are unhealthy (for observability)
    #[prost(bool, tag="5")]
    pub non_critical_dependencies_healthy: bool,
}
/// Mark startup complete request
///
/// ## Purpose
/// Signals that node initialization is complete and the node is ready to
/// transition from NOT_SERVING (startup) to SERVING.
///
/// ## When to Use
/// After all initialization steps complete:
/// - gRPC server started
/// - TupleSpace backend connected
/// - Actor registry initialized
/// - Initial actors spawned
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkStartupCompleteRequest {
    /// Optional message explaining what was initialized
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkStartupCompleteResponse {
    /// New serving status (should be SERVING)
    #[prost(enumeration="ServingStatus", tag="1")]
    pub status: i32,
    /// Time taken for startup
    #[prost(message, optional, tag="2")]
    pub startup_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Begin shutdown request
///
/// ## Purpose
/// Initiates graceful shutdown sequence:
/// 1. Set health to NOT_SERVING (Kubernetes removes from service)
/// 2. Drain in-flight requests
/// 3. Prepare for final shutdown
///
/// ## Kubernetes Behavior
/// - Readiness probe fails immediately (removed from load balancer)
/// - No new requests routed to this pod
/// - Pod has terminationGracePeriodSeconds (default 30s) before SIGKILL
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginShutdownRequest {
    /// Reason for shutdown (for logging)
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
    /// Override default drain timeout
    #[prost(message, optional, tag="2")]
    pub drain_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginShutdownResponse {
    /// Number of requests drained
    #[prost(uint64, tag="1")]
    pub requests_drained: u64,
    /// Time taken to drain
    #[prost(message, optional, tag="2")]
    pub drain_duration: ::core::option::Option<::prost_types::Duration>,
    /// Whether drain completed or timed out
    #[prost(bool, tag="3")]
    pub drain_completed: bool,
}
/// Get node readiness request (custom health check)
///
/// ## Purpose
/// Get detailed readiness status for debugging (beyond simple SERVING/NOT_SERVING)
///
/// No parameters needed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeReadinessRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeReadinessResponse {
    #[prost(message, optional, tag="1")]
    pub readiness: ::core::option::Option<NodeReadinessStatus>,
}
/// Get detailed health request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDetailedHealthRequest {
    /// If true, include non-critical dependency checks
    #[prost(bool, tag="1")]
    pub include_non_critical: bool,
}
/// Get detailed health response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDetailedHealthResponse {
    #[prost(message, optional, tag="1")]
    pub health: ::core::option::Option<DetailedHealthCheck>,
}
/// Liveness probe request
///
/// No parameters needed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LivenessProbeRequest {
}
/// Liveness probe response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LivenessProbeResponse {
    /// Whether node is alive
    #[prost(bool, tag="1")]
    pub is_alive: bool,
    /// Status code for HTTP (200 if alive, 503 if not)
    #[prost(int32, tag="2")]
    pub http_status_code: i32,
}
/// Readiness probe request
///
/// No parameters needed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadinessProbeRequest {
}
/// Readiness probe response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadinessProbeResponse {
    /// Whether node is ready
    #[prost(bool, tag="1")]
    pub is_ready: bool,
    /// Status code for HTTP (200 if ready, 503 if not)
    #[prost(int32, tag="2")]
    pub http_status_code: i32,
    /// Reason if not ready (for debugging)
    #[prost(string, tag="3")]
    pub not_ready_reason: ::prost::alloc::string::String,
}
/// Startup probe request
///
/// No parameters needed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartupProbeRequest {
}
/// Startup probe response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartupProbeResponse {
    /// Whether startup is complete
    #[prost(bool, tag="1")]
    pub startup_complete: bool,
    /// Status code for HTTP (200 if complete, 503 if not)
    #[prost(int32, tag="2")]
    pub http_status_code: i32,
    /// Reason if not complete (for debugging)
    #[prost(string, tag="3")]
    pub not_complete_reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub interval: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsResponse {
    /// System metrics from observability core (metrics.proto)
    #[prost(message, repeated, tag="1")]
    pub metrics: ::prost::alloc::vec::Vec<super::super::metrics::v1::SystemMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigRequest {
    /// Glob pattern for keys
    #[prost(string, tag="1")]
    pub key_pattern: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub include_secrets: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigResponse {
    #[prost(message, repeated, tag="1")]
    pub settings: ::prost::alloc::vec::Vec<ConfigSetting>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetConfigRequest {
    #[prost(message, repeated, tag="1")]
    pub settings: ::prost::alloc::vec::Vec<ConfigSetting>,
    #[prost(bool, tag="2")]
    pub validate_only: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetConfigResponse {
    #[prost(message, repeated, tag="1")]
    pub errors: ::prost::alloc::vec::Vec<ConfigValidationError>,
    #[prost(bool, tag="2")]
    pub requires_restart: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigValidationError {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogsRequest {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration="LogLevel", tag="3")]
    pub min_level: i32,
    #[prost(string, repeated, tag="4")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Search query
    #[prost(string, tag="5")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, optional, tag="6")]
    pub page_request: ::core::option::Option<super::super::common::v1::PageRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLogsResponse {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<LogEntry>,
    #[prost(message, optional, tag="2")]
    pub page_response: ::core::option::Option<super::super::common::v1::PageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupRequest {
    #[prost(enumeration="BackupType", tag="1")]
    pub r#type: i32,
    /// If empty, backup all
    #[prost(string, repeated, tag="2")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub destination: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub compress: bool,
    #[prost(bool, tag="5")]
    pub encrypt: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupResponse {
    #[prost(message, optional, tag="1")]
    pub backup: ::core::option::Option<BackupInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsRequest {
    #[prost(message, optional, tag="1")]
    pub page_request: ::core::option::Option<super::super::common::v1::PageRequest>,
    #[prost(enumeration="BackupType", tag="2")]
    pub r#type: i32,
    #[prost(enumeration="BackupStatus", tag="3")]
    pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
    #[prost(message, repeated, tag="1")]
    pub backups: ::prost::alloc::vec::Vec<BackupInfo>,
    #[prost(message, optional, tag="2")]
    pub page_response: ::core::option::Option<super::super::common::v1::PageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreBackupRequest {
    #[prost(string, tag="1")]
    pub backup_id: ::prost::alloc::string::String,
    /// If empty, restore all
    #[prost(string, repeated, tag="2")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub verify_checksum: bool,
    #[prost(bool, tag="4")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreBackupResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub restored_components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {
    #[prost(bool, tag="1")]
    pub graceful: bool,
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag="3")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// Shutdown status (observability)
///
/// ## Purpose
/// Provides detailed status of ongoing shutdown process.
///
/// ## Why This Exists
/// - Observability: Monitor shutdown progress
/// - Debugging: Understand where shutdown is stuck
/// - Metrics: Track shutdown duration per phase
///
/// ## Usage
/// Call GetShutdownStatus RPC to check shutdown progress.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownStatus {
    /// Current shutdown phase
    #[prost(enumeration="ShutdownPhase", tag="1")]
    pub phase: i32,
    /// Signal that triggered shutdown (if any)
    #[prost(enumeration="ShutdownSignal", tag="2")]
    pub signal: i32,
    /// When shutdown started
    #[prost(message, optional, tag="3")]
    pub shutdown_started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Elapsed time since shutdown started
    #[prost(message, optional, tag="4")]
    pub elapsed: ::core::option::Option<::prost_types::Duration>,
    /// Detailed status per phase
    #[prost(message, optional, tag="5")]
    pub health_not_serving_status: ::core::option::Option<ShutdownPhaseStatus>,
    #[prost(message, optional, tag="6")]
    pub draining_status: ::core::option::Option<ShutdownPhaseStatus>,
    #[prost(message, optional, tag="7")]
    pub stopping_actors_status: ::core::option::Option<ShutdownPhaseStatus>,
    #[prost(message, optional, tag="8")]
    pub closing_connections_status: ::core::option::Option<ShutdownPhaseStatus>,
    #[prost(message, optional, tag="9")]
    pub shutting_down_tuplespace_status: ::core::option::Option<ShutdownPhaseStatus>,
    #[prost(message, optional, tag="10")]
    pub final_cleanup_status: ::core::option::Option<ShutdownPhaseStatus>,
    /// Whether shutdown completed successfully
    #[prost(bool, tag="11")]
    pub completed: bool,
    /// Error if shutdown failed
    #[prost(string, tag="12")]
    pub error: ::prost::alloc::string::String,
}
/// Per-phase shutdown status
///
/// ## Purpose
/// Tracks status of individual shutdown phase.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownPhaseStatus {
    /// Phase name
    #[prost(enumeration="ShutdownPhase", tag="1")]
    pub phase: i32,
    /// Whether this phase completed
    #[prost(bool, tag="2")]
    pub completed: bool,
    /// When phase started
    #[prost(message, optional, tag="3")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When phase completed
    #[prost(message, optional, tag="4")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Duration of this phase
    #[prost(message, optional, tag="5")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    /// Error if phase failed
    #[prost(string, tag="6")]
    pub error: ::prost::alloc::string::String,
    /// Phase-specific details (JSON)
    #[prost(message, optional, tag="7")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
/// Get shutdown status request
///
/// No parameters needed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShutdownStatusRequest {
}
/// Get shutdown status response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShutdownStatusResponse {
    #[prost(message, optional, tag="1")]
    pub status: ::core::option::Option<ShutdownStatus>,
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    HealthStatusUnspecified = 0,
    HealthStatusHealthy = 1,
    HealthStatusDegraded = 2,
    HealthStatusUnhealthy = 3,
    HealthStatusUnknown = 4,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HealthStatus::HealthStatusUnspecified => "HEALTH_STATUS_UNSPECIFIED",
            HealthStatus::HealthStatusHealthy => "HEALTH_STATUS_HEALTHY",
            HealthStatus::HealthStatusDegraded => "HEALTH_STATUS_DEGRADED",
            HealthStatus::HealthStatusUnhealthy => "HEALTH_STATUS_UNHEALTHY",
            HealthStatus::HealthStatusUnknown => "HEALTH_STATUS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::HealthStatusUnspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::HealthStatusHealthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::HealthStatusDegraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::HealthStatusUnhealthy),
            "HEALTH_STATUS_UNKNOWN" => Some(Self::HealthStatusUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    LogLevelUnspecified = 0,
    LogLevelTrace = 1,
    LogLevelDebug = 2,
    LogLevelInfo = 3,
    LogLevelWarn = 4,
    LogLevelError = 5,
    LogLevelFatal = 6,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogLevel::LogLevelUnspecified => "LOG_LEVEL_UNSPECIFIED",
            LogLevel::LogLevelTrace => "LOG_LEVEL_TRACE",
            LogLevel::LogLevelDebug => "LOG_LEVEL_DEBUG",
            LogLevel::LogLevelInfo => "LOG_LEVEL_INFO",
            LogLevel::LogLevelWarn => "LOG_LEVEL_WARN",
            LogLevel::LogLevelError => "LOG_LEVEL_ERROR",
            LogLevel::LogLevelFatal => "LOG_LEVEL_FATAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOG_LEVEL_UNSPECIFIED" => Some(Self::LogLevelUnspecified),
            "LOG_LEVEL_TRACE" => Some(Self::LogLevelTrace),
            "LOG_LEVEL_DEBUG" => Some(Self::LogLevelDebug),
            "LOG_LEVEL_INFO" => Some(Self::LogLevelInfo),
            "LOG_LEVEL_WARN" => Some(Self::LogLevelWarn),
            "LOG_LEVEL_ERROR" => Some(Self::LogLevelError),
            "LOG_LEVEL_FATAL" => Some(Self::LogLevelFatal),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupType {
    BackupTypeUnspecified = 0,
    BackupTypeFull = 1,
    BackupTypeIncremental = 2,
    BackupTypeDifferential = 3,
}
impl BackupType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BackupType::BackupTypeUnspecified => "BACKUP_TYPE_UNSPECIFIED",
            BackupType::BackupTypeFull => "BACKUP_TYPE_FULL",
            BackupType::BackupTypeIncremental => "BACKUP_TYPE_INCREMENTAL",
            BackupType::BackupTypeDifferential => "BACKUP_TYPE_DIFFERENTIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_TYPE_UNSPECIFIED" => Some(Self::BackupTypeUnspecified),
            "BACKUP_TYPE_FULL" => Some(Self::BackupTypeFull),
            "BACKUP_TYPE_INCREMENTAL" => Some(Self::BackupTypeIncremental),
            "BACKUP_TYPE_DIFFERENTIAL" => Some(Self::BackupTypeDifferential),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupStatus {
    BackupStatusUnspecified = 0,
    BackupStatusRunning = 1,
    BackupStatusCompleted = 2,
    BackupStatusFailed = 3,
    BackupStatusCancelled = 4,
}
impl BackupStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BackupStatus::BackupStatusUnspecified => "BACKUP_STATUS_UNSPECIFIED",
            BackupStatus::BackupStatusRunning => "BACKUP_STATUS_RUNNING",
            BackupStatus::BackupStatusCompleted => "BACKUP_STATUS_COMPLETED",
            BackupStatus::BackupStatusFailed => "BACKUP_STATUS_FAILED",
            BackupStatus::BackupStatusCancelled => "BACKUP_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_STATUS_UNSPECIFIED" => Some(Self::BackupStatusUnspecified),
            "BACKUP_STATUS_RUNNING" => Some(Self::BackupStatusRunning),
            "BACKUP_STATUS_COMPLETED" => Some(Self::BackupStatusCompleted),
            "BACKUP_STATUS_FAILED" => Some(Self::BackupStatusFailed),
            "BACKUP_STATUS_CANCELLED" => Some(Self::BackupStatusCancelled),
            _ => None,
        }
    }
}
/// Serving status (matches grpc.health.v1.ServingStatus)
///
/// ## Purpose
/// Simplified serving status compatible with standard gRPC Health Protocol.
///
/// ## Values
/// - SERVING: Node is healthy and accepting requests
/// - NOT_SERVING: Node is not ready (startup, shutdown, overload, or dead)
/// - UNKNOWN: Health status cannot be determined
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServingStatus {
    ServingStatusUnspecified = 0,
    /// Ready to serve requests
    ServingStatusServing = 1,
    /// Not ready (various reasons)
    ServingStatusNotServing = 2,
    /// Cannot determine status
    ServingStatusUnknown = 3,
}
impl ServingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ServingStatus::ServingStatusUnspecified => "SERVING_STATUS_UNSPECIFIED",
            ServingStatus::ServingStatusServing => "SERVING_STATUS_SERVING",
            ServingStatus::ServingStatusNotServing => "SERVING_STATUS_NOT_SERVING",
            ServingStatus::ServingStatusUnknown => "SERVING_STATUS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVING_STATUS_UNSPECIFIED" => Some(Self::ServingStatusUnspecified),
            "SERVING_STATUS_SERVING" => Some(Self::ServingStatusServing),
            "SERVING_STATUS_NOT_SERVING" => Some(Self::ServingStatusNotServing),
            "SERVING_STATUS_UNKNOWN" => Some(Self::ServingStatusUnknown),
            _ => None,
        }
    }
}
/// Probe type (Kubernetes-style)
///
/// ## Purpose
/// Distinguishes between the three types of health probes used in Kubernetes.
///
/// ## Probe Types
/// - **STARTUP**: Is the application started? (NOT_SERVING → SERVING transition)
/// - **LIVENESS**: Is the application alive? (should Kubernetes restart the pod?)
/// - **READINESS**: Is the application ready? (should Kubernetes route traffic?)
///
/// ## Design Notes
/// - All three probes use the same gRPC Health service
/// - Logic differs based on what each probe checks
/// - See <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProbeType {
    ProbeTypeUnspecified = 0,
    /// Checks if startup complete
    ProbeTypeStartup = 1,
    /// Checks if node is alive (not deadlocked/crashed)
    ProbeTypeLiveness = 2,
    /// Checks if node is ready (not overloaded)
    ProbeTypeReadiness = 3,
}
impl ProbeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProbeType::ProbeTypeUnspecified => "PROBE_TYPE_UNSPECIFIED",
            ProbeType::ProbeTypeStartup => "PROBE_TYPE_STARTUP",
            ProbeType::ProbeTypeLiveness => "PROBE_TYPE_LIVENESS",
            ProbeType::ProbeTypeReadiness => "PROBE_TYPE_READINESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROBE_TYPE_UNSPECIFIED" => Some(Self::ProbeTypeUnspecified),
            "PROBE_TYPE_STARTUP" => Some(Self::ProbeTypeStartup),
            "PROBE_TYPE_LIVENESS" => Some(Self::ProbeTypeLiveness),
            "PROBE_TYPE_READINESS" => Some(Self::ProbeTypeReadiness),
            _ => None,
        }
    }
}
// Graceful shutdown coordination (VictoriaMetrics-style)
//
// ## Purpose
// Provides proto-first data model for graceful shutdown coordination,
// following the VictoriaMetrics pattern for proper signal handling.
//
// ## Why This Exists
// - Enables observability of shutdown progress
// - Supports distributed shutdown coordination
// - Proto-first design for cross-language compatibility
// - Integrates with Kubernetes graceful termination
//
// ## Design Notes
// Inspired by <https://victoriametrics.com/blog/go-graceful-shutdown/>
//
// ## Shutdown Sequence
// 1. Receive signal (SIGTERM/SIGINT/SIGHUP)
// 2. Set health to NOT_SERVING (K8s removes from load balancer)
// 3. Drain in-flight requests (timeout: 30s)
// 4. Stop accepting new actors
// 5. Stop all running actors (graceful)
// 6. Close gRPC connections
// 7. Shutdown TupleSpace
// 8. Final cleanup
// 9. Exit with code 0

/// Shutdown signal received from OS
///
/// ## Purpose
/// Represents OS signals that trigger graceful shutdown.
///
/// ## Mapping
/// - SIGTERM → Graceful shutdown (K8s default)
/// - SIGINT → Interrupt (Ctrl+C)
/// - SIGHUP → Reload/restart
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShutdownSignal {
    ShutdownSignalUnspecified = 0,
    /// Graceful shutdown (K8s sends this)
    ShutdownSignalSigterm = 1,
    /// Interrupt (Ctrl+C)
    ShutdownSignalSigint = 2,
    /// Hangup (reload config, graceful restart)
    ShutdownSignalSighup = 3,
}
impl ShutdownSignal {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ShutdownSignal::ShutdownSignalUnspecified => "SHUTDOWN_SIGNAL_UNSPECIFIED",
            ShutdownSignal::ShutdownSignalSigterm => "SHUTDOWN_SIGNAL_SIGTERM",
            ShutdownSignal::ShutdownSignalSigint => "SHUTDOWN_SIGNAL_SIGINT",
            ShutdownSignal::ShutdownSignalSighup => "SHUTDOWN_SIGNAL_SIGHUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHUTDOWN_SIGNAL_UNSPECIFIED" => Some(Self::ShutdownSignalUnspecified),
            "SHUTDOWN_SIGNAL_SIGTERM" => Some(Self::ShutdownSignalSigterm),
            "SHUTDOWN_SIGNAL_SIGINT" => Some(Self::ShutdownSignalSigint),
            "SHUTDOWN_SIGNAL_SIGHUP" => Some(Self::ShutdownSignalSighup),
            _ => None,
        }
    }
}
/// Shutdown phase tracking
///
/// ## Purpose
/// Tracks progress through graceful shutdown sequence.
///
/// ## State Machine
/// RUNNING → HEALTH_NOT_SERVING → DRAINING → STOPPING_ACTORS →
/// CLOSING_CONNECTIONS → SHUTTING_DOWN_TUPLESPACE → FINAL_CLEANUP → COMPLETE
///
/// ## Observability
/// Each phase transition is logged and can be monitored via GetShutdownStatus RPC.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShutdownPhase {
    ShutdownPhaseUnspecified = 0,
    /// Normal operation
    ShutdownPhaseRunning = 1,
    /// Health set to NOT_SERVING
    ShutdownPhaseHealthNotServing = 2,
    /// Draining in-flight requests
    ShutdownPhaseDraining = 3,
    /// Stopping all actors
    ShutdownPhaseStoppingActors = 4,
    /// Closing gRPC connections
    ShutdownPhaseClosingConnections = 5,
    /// Shutting down TupleSpace
    ShutdownPhaseShuttingDownTuplespace = 6,
    /// Final cleanup tasks
    ShutdownPhaseFinalCleanup = 7,
    /// Shutdown complete
    ShutdownPhaseComplete = 8,
}
impl ShutdownPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ShutdownPhase::ShutdownPhaseUnspecified => "SHUTDOWN_PHASE_UNSPECIFIED",
            ShutdownPhase::ShutdownPhaseRunning => "SHUTDOWN_PHASE_RUNNING",
            ShutdownPhase::ShutdownPhaseHealthNotServing => "SHUTDOWN_PHASE_HEALTH_NOT_SERVING",
            ShutdownPhase::ShutdownPhaseDraining => "SHUTDOWN_PHASE_DRAINING",
            ShutdownPhase::ShutdownPhaseStoppingActors => "SHUTDOWN_PHASE_STOPPING_ACTORS",
            ShutdownPhase::ShutdownPhaseClosingConnections => "SHUTDOWN_PHASE_CLOSING_CONNECTIONS",
            ShutdownPhase::ShutdownPhaseShuttingDownTuplespace => "SHUTDOWN_PHASE_SHUTTING_DOWN_TUPLESPACE",
            ShutdownPhase::ShutdownPhaseFinalCleanup => "SHUTDOWN_PHASE_FINAL_CLEANUP",
            ShutdownPhase::ShutdownPhaseComplete => "SHUTDOWN_PHASE_COMPLETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHUTDOWN_PHASE_UNSPECIFIED" => Some(Self::ShutdownPhaseUnspecified),
            "SHUTDOWN_PHASE_RUNNING" => Some(Self::ShutdownPhaseRunning),
            "SHUTDOWN_PHASE_HEALTH_NOT_SERVING" => Some(Self::ShutdownPhaseHealthNotServing),
            "SHUTDOWN_PHASE_DRAINING" => Some(Self::ShutdownPhaseDraining),
            "SHUTDOWN_PHASE_STOPPING_ACTORS" => Some(Self::ShutdownPhaseStoppingActors),
            "SHUTDOWN_PHASE_CLOSING_CONNECTIONS" => Some(Self::ShutdownPhaseClosingConnections),
            "SHUTDOWN_PHASE_SHUTTING_DOWN_TUPLESPACE" => Some(Self::ShutdownPhaseShuttingDownTuplespace),
            "SHUTDOWN_PHASE_FINAL_CLEANUP" => Some(Self::ShutdownPhaseFinalCleanup),
            "SHUTDOWN_PHASE_COMPLETE" => Some(Self::ShutdownPhaseComplete),
            _ => None,
        }
    }
}
include!("plexspaces.system.v1.tonic.rs");
// @@protoc_insertion_point(module)