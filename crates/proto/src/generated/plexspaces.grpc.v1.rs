// @generated
// This file is @generated by prost-build.
/// Middleware configuration for gRPC interceptor chain
///
/// ## Purpose
/// Defines the complete middleware stack for a gRPC server, including
/// execution order and per-middleware configuration.
///
/// ## Design Notes
/// - Order matters: Middleware executes in the order listed
/// - Each middleware is independently configurable
/// - Middleware can be enabled/disabled via `enabled` flag
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiddlewareConfig {
    /// Ordered list of middleware to apply
    ///
    /// Execution order:
    /// 1. Request flows top-to-bottom (first middleware sees request first)
    /// 2. Response flows bottom-to-top (last middleware sees response first)
    #[prost(message, repeated, tag="1")]
    pub middleware: ::prost::alloc::vec::Vec<MiddlewareSpec>,
}
/// Individual middleware specification
///
/// ## Purpose
/// Configures a single middleware interceptor with type-specific settings.
///
/// ## Design Notes
/// - `middleware_type` determines which config field is used
/// - `enabled` allows runtime enable/disable
/// - `priority` can override default order (lower = earlier execution)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiddlewareSpec {
    /// Middleware type (determines which config to use)
    #[prost(enumeration="MiddlewareType", tag="1")]
    pub middleware_type: i32,
    /// Whether this middleware is enabled
    #[prost(bool, tag="2")]
    pub enabled: bool,
    /// Execution priority (lower = earlier, default = 100)
    #[prost(int32, tag="3")]
    pub priority: i32,
    /// Type-specific configuration (one of):
    #[prost(oneof="middleware_spec::Config", tags="10, 11, 12, 13, 14, 15, 16, 17, 18")]
    pub config: ::core::option::Option<middleware_spec::Config>,
}
/// Nested message and enum types in `MiddlewareSpec`.
pub mod middleware_spec {
    /// Type-specific configuration (one of):
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag="10")]
        Metrics(super::MetricsMiddlewareConfig),
        #[prost(message, tag="11")]
        Tracing(super::TracingMiddlewareConfig),
        #[prost(message, tag="12")]
        Mtls(super::MtlsMiddlewareConfig),
        #[prost(message, tag="13")]
        Compression(super::CompressionMiddlewareConfig),
        #[prost(message, tag="14")]
        RateLimit(super::RateLimitMiddlewareConfig),
        #[prost(message, tag="15")]
        Auth(super::AuthMiddlewareConfig),
        #[prost(message, tag="16")]
        CircuitBreaker(super::CircuitBreakerMiddlewareConfig),
        #[prost(message, tag="17")]
        Retry(super::RetryMiddlewareConfig),
        #[prost(message, tag="18")]
        Logging(super::LoggingMiddlewareConfig),
    }
}
/// Metrics middleware configuration
///
/// ## Purpose
/// Exports gRPC metrics to Prometheus, StatsD, or OpenTelemetry.
///
/// ## Metrics Exported
/// - `grpc_requests_total`: Counter of requests by service/method/status
/// - `grpc_request_duration_seconds`: Histogram of request latency
/// - `grpc_active_requests`: Gauge of in-flight requests
/// - `grpc_request_size_bytes`: Histogram of request payload size
/// - `grpc_response_size_bytes`: Histogram of response payload size
///
/// ## Design Notes
/// - Prometheus format is default (can export to multiple backends)
/// - Metrics endpoint exposed at `/metrics` by default
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricsMiddlewareConfig {
    /// Metrics backend type
    #[prost(enumeration="MetricsBackend", tag="1")]
    pub backend: i32,
    /// Prometheus HTTP endpoint (e.g., "/metrics")
    #[prost(string, tag="2")]
    pub prometheus_endpoint: ::prost::alloc::string::String,
    /// StatsD server address (e.g., "localhost:8125")
    #[prost(string, tag="3")]
    pub statsd_address: ::prost::alloc::string::String,
    /// Histogram buckets for latency (seconds)
    #[prost(double, repeated, tag="4")]
    pub latency_buckets: ::prost::alloc::vec::Vec<f64>,
    /// Whether to include detailed method-level metrics
    #[prost(bool, tag="5")]
    pub detailed_metrics: bool,
}
/// Tracing middleware configuration
///
/// ## Purpose
/// Enables distributed tracing across nodes using OpenTelemetry.
///
/// ## Trace Propagation
/// - Injects trace context into outgoing gRPC metadata
/// - Extracts trace context from incoming gRPC metadata
/// - Creates spans for each RPC call
///
/// ## Design Notes
/// - Trace IDs propagate across the entire request path
/// - Integrates with Jaeger, Zipkin, or other OTLP backends
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracingMiddlewareConfig {
    /// Tracing backend (e.g., "jaeger", "zipkin", "otlp")
    #[prost(string, tag="1")]
    pub backend: ::prost::alloc::string::String,
    /// Backend endpoint (e.g., "<http://jaeger:14268/api/traces">)
    #[prost(string, tag="2")]
    pub endpoint: ::prost::alloc::string::String,
    /// Service name for traces
    #[prost(string, tag="3")]
    pub service_name: ::prost::alloc::string::String,
    /// Sampling rate (0.0 = none, 1.0 = all)
    #[prost(double, tag="4")]
    pub sampling_rate: f64,
    /// Whether to trace request/response payloads
    #[prost(bool, tag="5")]
    pub trace_payloads: bool,
}
/// Mutual TLS middleware configuration
///
/// ## Purpose
/// Enforces mutual TLS authentication between nodes.
///
/// ## Security
/// - Client cert verification
/// - Server cert verification
/// - Optional client cert requirement
///
/// ## Design Notes
/// - Certificate paths should be absolute or relative to node working directory
/// - Supports PEM format certificates
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MtlsMiddlewareConfig {
    /// Path to server certificate (PEM)
    #[prost(string, tag="1")]
    pub server_cert_path: ::prost::alloc::string::String,
    /// Path to server private key (PEM)
    #[prost(string, tag="2")]
    pub server_key_path: ::prost::alloc::string::String,
    /// Path to CA certificate for client verification (PEM)
    #[prost(string, tag="3")]
    pub ca_cert_path: ::prost::alloc::string::String,
    /// Whether client certificates are required
    #[prost(bool, tag="4")]
    pub require_client_cert: bool,
    /// Allowed client certificate subjects (CNs)
    #[prost(string, repeated, tag="5")]
    pub allowed_subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Compression middleware configuration
///
/// ## Purpose
/// Compresses gRPC payloads using gzip or brotli.
///
/// ## Design Notes
/// - Only compresses if payload size exceeds threshold
/// - Supports content negotiation (client can disable)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressionMiddlewareConfig {
    /// Compression algorithm
    #[prost(enumeration="CompressionAlgorithm", tag="1")]
    pub algorithm: i32,
    /// Minimum payload size to compress (bytes)
    #[prost(uint32, tag="2")]
    pub min_size_bytes: u32,
    /// Compression level (1=fastest, 9=best compression)
    #[prost(int32, tag="3")]
    pub compression_level: i32,
}
/// Rate limiting middleware configuration
///
/// ## Purpose
/// Limits request rate using token bucket algorithm.
///
/// ## Design Notes
/// - Per-client limits based on remote address
/// - Refill rate controls sustained throughput
/// - Burst size allows temporary spikes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimitMiddlewareConfig {
    /// Tokens refilled per second (sustained rate)
    #[prost(double, tag="1")]
    pub refill_rate: f64,
    /// Maximum burst size (tokens)
    #[prost(uint32, tag="2")]
    pub burst_size: u32,
    /// Whether to rate limit per client IP
    #[prost(bool, tag="3")]
    pub per_client: bool,
    /// HTTP status code for rate limit exceeded (429)
    #[prost(int32, tag="4")]
    pub status_code: i32,
}
/// JWT Claims
///
/// ## Purpose
/// Standard JWT claims structure for token validation.
///
/// ## Design Notes
/// - Follows RFC 7519 (JSON Web Token)
/// - Standard claims: sub (subject), exp (expiration), iat (issued at)
/// - Custom claims: roles (for RBAC), tenant_id (for multi-tenancy)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwtClaims {
    /// Subject (user ID)
    #[prost(string, tag="1")]
    pub sub: ::prost::alloc::string::String,
    /// Expiration time (Unix timestamp)
    #[prost(int64, tag="2")]
    pub exp: i64,
    /// Issued at time (Unix timestamp)
    #[prost(int64, tag="3")]
    pub iat: i64,
    /// Issuer (who issued the token)
    #[prost(string, tag="4")]
    pub iss: ::prost::alloc::string::String,
    /// Audience (who the token is intended for)
    #[prost(string, repeated, tag="5")]
    pub aud: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// User roles (for RBAC)
    #[prost(string, repeated, tag="6")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Tenant ID (for multi-tenancy)
    #[prost(string, tag="7")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Custom claims (extensible)
    #[prost(map="string, string", tag="8")]
    pub custom_claims: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Authentication middleware configuration
///
/// ## Purpose
/// Authenticates requests using tokens, certificates, or RBAC.
///
/// ## Design Notes
/// - Supports multiple auth methods (can be combined)
/// - Token validation can be JWT or custom
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthMiddlewareConfig {
    /// Authentication method
    #[prost(enumeration="AuthMethod", tag="1")]
    pub method: i32,
    /// JWT secret or public key path (for JWT method)
    #[prost(string, tag="2")]
    pub jwt_key: ::prost::alloc::string::String,
    /// RBAC policy configuration
    #[prost(message, optional, tag="3")]
    pub rbac: ::core::option::Option<RbacConfig>,
    /// Whether to allow unauthenticated requests (permissive mode)
    #[prost(bool, tag="4")]
    pub allow_unauthenticated: bool,
    /// mTLS configuration (for AUTH_METHOD_MTLS)
    /// References security.proto MtlsConfig for service-to-service authentication
    ///
    /// CA certificate path or PEM content for validation
    #[prost(string, tag="5")]
    pub mtls_ca_certificate: ::prost::alloc::string::String,
    /// Trusted services for mTLS (service IDs allowed to connect)
    /// If empty, all services with valid certificates are allowed
    #[prost(string, repeated, tag="6")]
    pub mtls_trusted_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// RBAC configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RbacConfig {
    /// Role definitions (role name → permissions)
    #[prost(map="string, message", tag="1")]
    pub roles: ::std::collections::HashMap<::prost::alloc::string::String, RolePermissions>,
    /// User-to-role assignments (user ID → role names)
    #[prost(map="string, message", tag="2")]
    pub user_roles: ::std::collections::HashMap<::prost::alloc::string::String, RoleAssignments>,
}
/// Role permissions
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolePermissions {
    /// Allowed gRPC services (e.g., "ActorService")
    #[prost(string, repeated, tag="1")]
    pub allowed_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Allowed gRPC methods (e.g., "SpawnActor")
    #[prost(string, repeated, tag="2")]
    pub allowed_methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Role assignments for a user
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleAssignments {
    /// Role names assigned to this user
    #[prost(string, repeated, tag="1")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Circuit breaker middleware configuration
///
/// ## Purpose
/// Fails fast when downstream service is unhealthy.
///
/// ## States
/// - CLOSED: Requests pass through normally
/// - OPEN: Requests fail immediately (circuit "open")
/// - HALF_OPEN: Test requests to check if service recovered
///
/// ## Design Notes
/// - Threshold determines when to open circuit
/// - Timeout determines when to try recovery
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerMiddlewareConfig {
    /// Failure threshold to open circuit
    #[prost(uint32, tag="1")]
    pub failure_threshold: u32,
    /// Success threshold to close circuit (in half-open state)
    #[prost(uint32, tag="2")]
    pub success_threshold: u32,
    /// Timeout before trying recovery (duration in half-open state)
    #[prost(message, optional, tag="3")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Time window for counting failures
    #[prost(message, optional, tag="4")]
    pub window: ::core::option::Option<::prost_types::Duration>,
}
/// Retry middleware configuration
///
/// ## Purpose
/// Automatically retries failed requests with exponential backoff.
///
/// ## Design Notes
/// - Only retries idempotent methods by default
/// - Backoff prevents overwhelming downstream service
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryMiddlewareConfig {
    /// Maximum retry attempts
    #[prost(uint32, tag="1")]
    pub max_retries: u32,
    /// Initial retry delay
    #[prost(message, optional, tag="2")]
    pub initial_delay: ::core::option::Option<::prost_types::Duration>,
    /// Maximum retry delay
    #[prost(message, optional, tag="3")]
    pub max_delay: ::core::option::Option<::prost_types::Duration>,
    /// Backoff multiplier (2.0 = exponential)
    #[prost(double, tag="4")]
    pub backoff_factor: f64,
    /// Retryable gRPC status codes
    #[prost(int32, repeated, tag="5")]
    pub retryable_status_codes: ::prost::alloc::vec::Vec<i32>,
}
/// Logging middleware configuration
///
/// ## Purpose
/// Logs gRPC requests/responses in structured JSON format.
///
/// ## Design Notes
/// - Can log to stdout, file, or syslog
/// - Log level controls verbosity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingMiddlewareConfig {
    /// Log level
    #[prost(enumeration="LogLevel", tag="1")]
    pub level: i32,
    /// Log destination
    #[prost(enumeration="LogDestination", tag="2")]
    pub destination: i32,
    /// Log file path (if destination = FILE)
    #[prost(string, tag="3")]
    pub log_file_path: ::prost::alloc::string::String,
    /// Whether to log request/response payloads
    #[prost(bool, tag="4")]
    pub log_payloads: bool,
    /// Whether to log headers/metadata
    #[prost(bool, tag="5")]
    pub log_headers: bool,
}
// ============================================================================
// Interceptor Service - Proto-First Design
// ============================================================================

/// Interceptor request context
///
/// ## Purpose
/// Provides context about the incoming gRPC request for interceptors to inspect/modify.
///
/// ## Design Notes
/// - Contains request metadata, path, headers
/// - Interceptors can add/remove headers
/// - Allows request rejection before handler execution
/// - Includes TLS certificate information for mTLS authentication
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptorRequest {
    /// gRPC method full path (e.g., "/plexspaces.actor.v1.ActorService/SpawnActor")
    #[prost(string, tag="1")]
    pub method: ::prost::alloc::string::String,
    /// Request headers/metadata
    #[prost(map="string, string", tag="2")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Remote client address
    #[prost(string, tag="3")]
    pub remote_addr: ::prost::alloc::string::String,
    /// Request timestamp
    #[prost(message, optional, tag="4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Request ID for correlation
    #[prost(string, tag="5")]
    pub request_id: ::prost::alloc::string::String,
    /// TLS peer certificate (PEM format) for mTLS authentication
    /// Extracted from TLS connection during handshake
    /// Empty if connection is not using TLS or mTLS is not enabled
    #[prost(string, tag="6")]
    pub peer_certificate: ::prost::alloc::string::String,
    /// Service identity extracted from peer certificate (CN or SAN)
    /// Set by TLS layer after certificate validation
    /// Used by mTLS interceptor for service-to-service authentication
    #[prost(string, tag="7")]
    pub peer_service_id: ::prost::alloc::string::String,
}
/// Interceptor response context
///
/// ## Purpose
/// Provides context about the gRPC response for interceptors to inspect/modify.
///
/// ## Design Notes
/// - Contains response metadata, status, headers
/// - Interceptors can add response headers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptorResponse {
    /// Response status code
    #[prost(int32, tag="1")]
    pub status_code: i32,
    /// Response headers/metadata
    #[prost(map="string, string", tag="2")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Response timestamp
    #[prost(message, optional, tag="3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Request duration (calculated by interceptor chain)
    #[prost(message, optional, tag="4")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
/// Interceptor result
///
/// ## Purpose
/// Result of interceptor execution (decision + optional modifications).
///
/// ## Design Notes
/// - If decision=DENY, error_message must be set
/// - If decision=MODIFY, modified headers can be provided
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptorResult {
    /// Interceptor decision
    #[prost(enumeration="InterceptorDecision", tag="1")]
    pub decision: i32,
    /// Error message if denied
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
    /// Modified headers (if decision=MODIFY)
    #[prost(map="string, string", tag="3")]
    pub modified_headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Metrics emitted by this interceptor
    #[prost(message, repeated, tag="4")]
    pub metrics: ::prost::alloc::vec::Vec<MetricSample>,
}
/// Metric sample emitted by interceptor
///
/// ## Purpose
/// Represents a single metric observation from an interceptor.
///
/// ## Examples
/// - Counter: grpc_requests_total{service="ActorService", method="SpawnActor"} 1
/// - Histogram: grpc_request_duration_seconds{service="ActorService"} 0.042
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricSample {
    /// Metric name
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Metric type
    #[prost(enumeration="MetricType", tag="2")]
    pub r#type: i32,
    /// Metric value
    #[prost(double, tag="3")]
    pub value: f64,
    /// Metric labels
    #[prost(map="string, string", tag="4")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Timestamp
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Middleware types
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MiddlewareType {
    MiddlewareTypeUnspecified = 0,
    /// Prometheus/StatsD metrics
    MiddlewareTypeMetrics = 1,
    /// OpenTelemetry distributed tracing
    MiddlewareTypeTracing = 2,
    /// Mutual TLS authentication
    MiddlewareTypeMtls = 3,
    /// gzip/brotli compression
    MiddlewareTypeCompression = 4,
    /// Token bucket rate limiting
    MiddlewareTypeRateLimit = 5,
    /// Authentication/authorization
    MiddlewareTypeAuth = 6,
    /// Circuit breaker pattern
    MiddlewareTypeCircuitBreaker = 7,
    /// Exponential backoff retries
    MiddlewareTypeRetry = 8,
    /// Structured logging
    MiddlewareTypeLogging = 9,
}
impl MiddlewareType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MiddlewareType::MiddlewareTypeUnspecified => "MIDDLEWARE_TYPE_UNSPECIFIED",
            MiddlewareType::MiddlewareTypeMetrics => "MIDDLEWARE_TYPE_METRICS",
            MiddlewareType::MiddlewareTypeTracing => "MIDDLEWARE_TYPE_TRACING",
            MiddlewareType::MiddlewareTypeMtls => "MIDDLEWARE_TYPE_MTLS",
            MiddlewareType::MiddlewareTypeCompression => "MIDDLEWARE_TYPE_COMPRESSION",
            MiddlewareType::MiddlewareTypeRateLimit => "MIDDLEWARE_TYPE_RATE_LIMIT",
            MiddlewareType::MiddlewareTypeAuth => "MIDDLEWARE_TYPE_AUTH",
            MiddlewareType::MiddlewareTypeCircuitBreaker => "MIDDLEWARE_TYPE_CIRCUIT_BREAKER",
            MiddlewareType::MiddlewareTypeRetry => "MIDDLEWARE_TYPE_RETRY",
            MiddlewareType::MiddlewareTypeLogging => "MIDDLEWARE_TYPE_LOGGING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MIDDLEWARE_TYPE_UNSPECIFIED" => Some(Self::MiddlewareTypeUnspecified),
            "MIDDLEWARE_TYPE_METRICS" => Some(Self::MiddlewareTypeMetrics),
            "MIDDLEWARE_TYPE_TRACING" => Some(Self::MiddlewareTypeTracing),
            "MIDDLEWARE_TYPE_MTLS" => Some(Self::MiddlewareTypeMtls),
            "MIDDLEWARE_TYPE_COMPRESSION" => Some(Self::MiddlewareTypeCompression),
            "MIDDLEWARE_TYPE_RATE_LIMIT" => Some(Self::MiddlewareTypeRateLimit),
            "MIDDLEWARE_TYPE_AUTH" => Some(Self::MiddlewareTypeAuth),
            "MIDDLEWARE_TYPE_CIRCUIT_BREAKER" => Some(Self::MiddlewareTypeCircuitBreaker),
            "MIDDLEWARE_TYPE_RETRY" => Some(Self::MiddlewareTypeRetry),
            "MIDDLEWARE_TYPE_LOGGING" => Some(Self::MiddlewareTypeLogging),
            _ => None,
        }
    }
}
/// Metrics backend type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetricsBackend {
    MetricsBackendUnspecified = 0,
    /// Prometheus pull model
    MetricsBackendPrometheus = 1,
    /// StatsD push model
    MetricsBackendStatsd = 2,
    /// OpenTelemetry protocol
    MetricsBackendOpentelemetry = 3,
}
impl MetricsBackend {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MetricsBackend::MetricsBackendUnspecified => "METRICS_BACKEND_UNSPECIFIED",
            MetricsBackend::MetricsBackendPrometheus => "METRICS_BACKEND_PROMETHEUS",
            MetricsBackend::MetricsBackendStatsd => "METRICS_BACKEND_STATSD",
            MetricsBackend::MetricsBackendOpentelemetry => "METRICS_BACKEND_OPENTELEMETRY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "METRICS_BACKEND_UNSPECIFIED" => Some(Self::MetricsBackendUnspecified),
            "METRICS_BACKEND_PROMETHEUS" => Some(Self::MetricsBackendPrometheus),
            "METRICS_BACKEND_STATSD" => Some(Self::MetricsBackendStatsd),
            "METRICS_BACKEND_OPENTELEMETRY" => Some(Self::MetricsBackendOpentelemetry),
            _ => None,
        }
    }
}
/// Compression algorithm
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionAlgorithm {
    CompressionAlgorithmUnspecified = 0,
    CompressionAlgorithmGzip = 1,
    CompressionAlgorithmBrotli = 2,
}
impl CompressionAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressionAlgorithm::CompressionAlgorithmUnspecified => "COMPRESSION_ALGORITHM_UNSPECIFIED",
            CompressionAlgorithm::CompressionAlgorithmGzip => "COMPRESSION_ALGORITHM_GZIP",
            CompressionAlgorithm::CompressionAlgorithmBrotli => "COMPRESSION_ALGORITHM_BROTLI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_ALGORITHM_UNSPECIFIED" => Some(Self::CompressionAlgorithmUnspecified),
            "COMPRESSION_ALGORITHM_GZIP" => Some(Self::CompressionAlgorithmGzip),
            "COMPRESSION_ALGORITHM_BROTLI" => Some(Self::CompressionAlgorithmBrotli),
            _ => None,
        }
    }
}
/// Authentication method
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthMethod {
    AuthMethodUnspecified = 0,
    /// JSON Web Token
    AuthMethodJwt = 1,
    /// Mutual TLS (use MtlsMiddleware)
    AuthMethodMtls = 2,
    /// Role-Based Access Control
    AuthMethodRbac = 3,
    /// Bearer token
    AuthMethodToken = 4,
}
impl AuthMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthMethod::AuthMethodUnspecified => "AUTH_METHOD_UNSPECIFIED",
            AuthMethod::AuthMethodJwt => "AUTH_METHOD_JWT",
            AuthMethod::AuthMethodMtls => "AUTH_METHOD_MTLS",
            AuthMethod::AuthMethodRbac => "AUTH_METHOD_RBAC",
            AuthMethod::AuthMethodToken => "AUTH_METHOD_TOKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTH_METHOD_UNSPECIFIED" => Some(Self::AuthMethodUnspecified),
            "AUTH_METHOD_JWT" => Some(Self::AuthMethodJwt),
            "AUTH_METHOD_MTLS" => Some(Self::AuthMethodMtls),
            "AUTH_METHOD_RBAC" => Some(Self::AuthMethodRbac),
            "AUTH_METHOD_TOKEN" => Some(Self::AuthMethodToken),
            _ => None,
        }
    }
}
/// Log level
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    LogLevelUnspecified = 0,
    LogLevelDebug = 1,
    LogLevelInfo = 2,
    LogLevelWarn = 3,
    LogLevelError = 4,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogLevel::LogLevelUnspecified => "LOG_LEVEL_UNSPECIFIED",
            LogLevel::LogLevelDebug => "LOG_LEVEL_DEBUG",
            LogLevel::LogLevelInfo => "LOG_LEVEL_INFO",
            LogLevel::LogLevelWarn => "LOG_LEVEL_WARN",
            LogLevel::LogLevelError => "LOG_LEVEL_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOG_LEVEL_UNSPECIFIED" => Some(Self::LogLevelUnspecified),
            "LOG_LEVEL_DEBUG" => Some(Self::LogLevelDebug),
            "LOG_LEVEL_INFO" => Some(Self::LogLevelInfo),
            "LOG_LEVEL_WARN" => Some(Self::LogLevelWarn),
            "LOG_LEVEL_ERROR" => Some(Self::LogLevelError),
            _ => None,
        }
    }
}
/// Log destination
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogDestination {
    LogDestinationUnspecified = 0,
    LogDestinationStdout = 1,
    LogDestinationFile = 2,
    LogDestinationSyslog = 3,
}
impl LogDestination {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogDestination::LogDestinationUnspecified => "LOG_DESTINATION_UNSPECIFIED",
            LogDestination::LogDestinationStdout => "LOG_DESTINATION_STDOUT",
            LogDestination::LogDestinationFile => "LOG_DESTINATION_FILE",
            LogDestination::LogDestinationSyslog => "LOG_DESTINATION_SYSLOG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOG_DESTINATION_UNSPECIFIED" => Some(Self::LogDestinationUnspecified),
            "LOG_DESTINATION_STDOUT" => Some(Self::LogDestinationStdout),
            "LOG_DESTINATION_FILE" => Some(Self::LogDestinationFile),
            "LOG_DESTINATION_SYSLOG" => Some(Self::LogDestinationSyslog),
            _ => None,
        }
    }
}
/// Interceptor decision
///
/// ## Purpose
/// Represents the decision made by an interceptor (allow, deny, modify).
///
/// ## Design Notes
/// - ALLOW: Continue to next interceptor or handler
/// - DENY: Reject request immediately
/// - MODIFY: Continue with modified request
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterceptorDecision {
    InterceptorDecisionUnspecified = 0,
    /// Allow request to proceed
    InterceptorDecisionAllow = 1,
    /// Reject request (short-circuit chain)
    InterceptorDecisionDeny = 2,
    /// Modify request and proceed
    InterceptorDecisionModify = 3,
}
impl InterceptorDecision {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InterceptorDecision::InterceptorDecisionUnspecified => "INTERCEPTOR_DECISION_UNSPECIFIED",
            InterceptorDecision::InterceptorDecisionAllow => "INTERCEPTOR_DECISION_ALLOW",
            InterceptorDecision::InterceptorDecisionDeny => "INTERCEPTOR_DECISION_DENY",
            InterceptorDecision::InterceptorDecisionModify => "INTERCEPTOR_DECISION_MODIFY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERCEPTOR_DECISION_UNSPECIFIED" => Some(Self::InterceptorDecisionUnspecified),
            "INTERCEPTOR_DECISION_ALLOW" => Some(Self::InterceptorDecisionAllow),
            "INTERCEPTOR_DECISION_DENY" => Some(Self::InterceptorDecisionDeny),
            "INTERCEPTOR_DECISION_MODIFY" => Some(Self::InterceptorDecisionModify),
            _ => None,
        }
    }
}
/// Metric type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetricType {
    MetricTypeUnspecified = 0,
    MetricTypeCounter = 1,
    MetricTypeGauge = 2,
    MetricTypeHistogram = 3,
    MetricTypeSummary = 4,
}
impl MetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MetricType::MetricTypeUnspecified => "METRIC_TYPE_UNSPECIFIED",
            MetricType::MetricTypeCounter => "METRIC_TYPE_COUNTER",
            MetricType::MetricTypeGauge => "METRIC_TYPE_GAUGE",
            MetricType::MetricTypeHistogram => "METRIC_TYPE_HISTOGRAM",
            MetricType::MetricTypeSummary => "METRIC_TYPE_SUMMARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "METRIC_TYPE_UNSPECIFIED" => Some(Self::MetricTypeUnspecified),
            "METRIC_TYPE_COUNTER" => Some(Self::MetricTypeCounter),
            "METRIC_TYPE_GAUGE" => Some(Self::MetricTypeGauge),
            "METRIC_TYPE_HISTOGRAM" => Some(Self::MetricTypeHistogram),
            "METRIC_TYPE_SUMMARY" => Some(Self::MetricTypeSummary),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
