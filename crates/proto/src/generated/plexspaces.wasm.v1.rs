// @generated
// This file is @generated by prost-build.
/// WebAssembly module definition
///
/// ## Purpose
/// Represents a compiled WebAssembly module that can be deployed to nodes
/// and instantiated as actors. Modules are immutable and content-addressed
/// for caching and deduplication.
///
/// ## Why This Exists
/// - Enables dynamic code deployment (like Java classloader)
/// - Content-addressed hash allows efficient caching across nodes
/// - Metadata enables version management and dependency tracking
/// - Separation of code (module) and state (actor instance) enables fast migration
///
/// ## Design Notes
/// - `module_bytes` is the compiled WASM binary (Component Model format)
/// - `module_hash` is SHA-256 for cache lookup and verification
/// - `wit_interface` is optional WIT definition for tooling/debugging
/// - Modules are immutable - updates create new versions with different hashes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WasmModule {
    /// Module name (e.g., "counter-actor", "chat-room-actor")
    ///
    /// Used for human-readable identification and registry lookups.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Module version (semantic versioning: "1.2.3")
    ///
    /// Enables gradual rollout and rollback of actor code.
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    /// Compiled WebAssembly Component Model bytes
    ///
    /// This is the actual WASM binary that will be loaded and instantiated.
    /// Must be a valid WASM Component Model module (not legacy WASM).
    #[prost(bytes="vec", tag="3")]
    pub module_bytes: ::prost::alloc::vec::Vec<u8>,
    /// SHA-256 hash of module_bytes (for content-addressable caching)
    ///
    /// Format: hex-encoded 64-character string
    /// Example: "a1b2c3d4e5f6..."
    ///
    /// Why content-addressed:
    /// - Deduplication: Same module hash = same module, cache once
    /// - Verification: Ensure module integrity during distribution
    /// - Efficient lookup: Nodes can check cache before downloading
    #[prost(string, tag="4")]
    pub module_hash: ::prost::alloc::string::String,
    /// WIT (WebAssembly Interface Types) interface definition (optional)
    ///
    /// Human-readable interface for tooling, debugging, and documentation.
    /// Not required for runtime (Component Model is self-describing).
    #[prost(string, tag="5")]
    pub wit_interface: ::prost::alloc::string::String,
    /// Supported languages (e.g., "rust", "javascript", "go")
    ///
    /// Indicates source language for debugging and tooling.
    #[prost(string, repeated, tag="6")]
    pub source_languages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Module metadata (tags, labels, annotations)
    ///
    /// Examples:
    /// - tags: \["production", "stateless", "compute-intensive"\]
    /// - labels: {"team": "backend", "service": "payment"}
    #[prost(message, optional, tag="7")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    /// Upload timestamp (when module was first deployed to registry)
    #[prost(message, optional, tag="8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Module size in bytes (uncompressed)
    ///
    /// Used for bandwidth estimation and pre-warming decisions.
    #[prost(uint64, tag="9")]
    pub size_bytes: u64,
    /// Schema version for forward/backward compatibility
    #[prost(uint32, tag="10")]
    pub version_number: u32,
}
/// Resource limits for WASM actor instances
///
/// ## Purpose
/// Defines resource constraints for WASM actors to prevent resource exhaustion
/// and ensure fair scheduling. Enforced by wasmtime runtime.
///
/// ## Why This Exists
/// - Memory limits prevent OOM crashes (multi-tenant safety)
/// - Fuel metering prevents infinite loops (gas-style execution limits)
/// - Time limits prevent hung actors
/// - Stack limits prevent stack overflow
///
/// ## Design Notes
/// - Limits are per-instance (each actor has own quota)
/// - Fuel is like Ethereum gas - metered during execution
/// - Defaults chosen for balanced workloads (can override per-actor)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// Maximum linear memory size in bytes (default: 16MB)
    ///
    /// WASM linear memory is contiguous, growable.
    /// 16MB default balances:
    /// - Enough for most actors (2MB-8MB typical)
    /// - 64 actors per GB of RAM
    /// - 32x more efficient than JavaNow (64MB per actor)
    #[prost(uint64, tag="1")]
    pub max_memory_bytes: u64,
    /// Maximum stack size in bytes (default: 512KB)
    ///
    /// Stack overflow protection. Most actors use < 100KB.
    #[prost(uint64, tag="2")]
    pub max_stack_bytes: u64,
    /// Maximum fuel units (gas-style execution limit)
    ///
    /// Fuel is consumed during execution (ops, memory access, calls).
    /// Default: 10 billion units = ~1 second CPU time
    /// Zero = unlimited (not recommended for untrusted code)
    #[prost(uint64, tag="3")]
    pub max_fuel: u64,
    /// Maximum execution time per message (optional)
    ///
    /// If set, actor handler must complete within this duration.
    /// Default: None (rely on fuel metering instead)
    #[prost(message, optional, tag="4")]
    pub max_execution_time: ::core::option::Option<::prost_types::Duration>,
    /// Maximum table elements (for indirect calls)
    ///
    /// Default: 10,000 (enough for most actors)
    #[prost(uint32, tag="5")]
    pub max_table_elements: u32,
    /// Maximum number of instances in instance pool
    ///
    /// For warm start optimization. Default: 10 per actor type.
    #[prost(uint32, tag="6")]
    pub max_pooled_instances: u32,
}
/// WASI capabilities for WASM actors
///
/// ## Purpose
/// Defines what host resources a WASM actor can access. Based on WASI Preview 2
/// capability-based security model.
///
/// ## Why This Exists
/// - **Principle of Least Privilege**: Actors only get capabilities they need
/// - **Facets Pattern Revival**: JavaNow-inspired capability composition
/// - **Security**: Sandboxed actors cannot access unauthorized resources
/// - **Auditing**: Capabilities are explicit and logged
///
/// ## Design Notes
/// - Capabilities are granted at instantiation time (immutable per instance)
/// - WASI capabilities (filesystem, network, clocks) use WASI standard
/// - PlexSpaces capabilities (tuplespace, actors) are custom host functions
/// - Denied by default (opt-in model)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WasmCapabilities {
    /// Allow filesystem access (WASI filesystem interface)
    ///
    /// If true, actor can use WASI file operations (open, read, write).
    /// Paths are virtualized (actor cannot access arbitrary host paths).
    #[prost(bool, tag="1")]
    pub allow_filesystem: bool,
    /// Filesystem root path (if filesystem access allowed)
    ///
    /// Actor's root is mapped to this host path (chroot-style).
    /// Example: "/actors/{actor_id}/data"
    #[prost(string, tag="2")]
    pub filesystem_root: ::prost::alloc::string::String,
    /// Allow network access (WASI sockets interface)
    ///
    /// If true, actor can make outbound network connections.
    /// Inbound connections not supported (actors receive messages via mailbox).
    #[prost(bool, tag="3")]
    pub allow_network: bool,
    /// Allow environment variables (WASI environment interface)
    ///
    /// If true, actor can read environment variables.
    /// Useful for configuration (but TupleSpace config preferred).
    #[prost(bool, tag="4")]
    pub allow_env: bool,
    /// Allow random number generation (WASI random interface)
    ///
    /// If true, actor can use cryptographically secure random.
    /// Generally safe to allow.
    #[prost(bool, tag="5")]
    pub allow_random: bool,
    /// Allow clock access (WASI clocks interface)
    ///
    /// If true, actor can read monotonic and wall-clock time.
    /// Required for timeouts, timestamps.
    #[prost(bool, tag="6")]
    pub allow_clocks: bool,
    /// Allow TupleSpace operations (PlexSpaces-specific)
    ///
    /// If true, actor can call host functions: tuplespace_write, tuplespace_read, etc.
    /// Most actors need this for coordination.
    #[prost(bool, tag="7")]
    pub allow_tuplespace: bool,
    /// Allow actor spawning (PlexSpaces-specific)
    ///
    /// If true, actor can spawn new actors via spawn_actor host function.
    /// Useful for supervisor actors, not needed for leaf actors.
    #[prost(bool, tag="8")]
    pub allow_spawn_actors: bool,
    /// Allow message sending (PlexSpaces-specific)
    ///
    /// If true, actor can send messages to other actors via send_message host function.
    /// Almost all actors need this (inter-actor communication).
    #[prost(bool, tag="9")]
    pub allow_send_messages: bool,
    /// Allow logging (PlexSpaces-specific)
    ///
    /// If true, actor can emit logs via log host function.
    /// Useful for debugging, not required for production actors.
    #[prost(bool, tag="10")]
    pub allow_logging: bool,
}
/// WASM actor configuration
///
/// ## Purpose
/// Combines resource limits and capabilities into a complete configuration
/// for instantiating a WASM actor. Can be templated per actor type.
///
/// ## Why This Exists
/// - **Reusable Profiles**: Define once, apply to many actors
/// - **Security Policies**: Enforce organizational security requirements
/// - **Resource Management**: Prevent resource exhaustion
///
/// ## Design Notes
/// - Can create profiles: "untrusted" (minimal caps), "trusted" (full caps)
/// - Immutable after instantiation (cannot escalate privileges)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WasmConfig {
    /// Resource limits for this actor
    #[prost(message, optional, tag="1")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// Capabilities granted to this actor
    #[prost(message, optional, tag="2")]
    pub capabilities: ::core::option::Option<WasmCapabilities>,
    /// Configuration name (e.g., "default", "untrusted", "compute-intensive")
    ///
    /// Allows reusing configurations across actors.
    #[prost(string, tag="3")]
    pub profile_name: ::prost::alloc::string::String,
    /// Enable instance pooling for warm starts
    ///
    /// If true, pre-instantiate instances for faster spawning.
    /// Trade-off: Memory usage vs latency.
    #[prost(bool, tag="4")]
    pub enable_pooling: bool,
    /// Enable ahead-of-time (AOT) compilation
    ///
    /// If true, compile module to native code on deployment.
    /// Trade-off: Deployment time vs execution speed.
    #[prost(bool, tag="5")]
    pub enable_aot: bool,
}
/// Deploy WASM module request
///
/// ## Purpose
/// Uploads a WASM module to the cluster registry and optionally pre-warms
/// nodes by pushing the module to their caches.
///
/// ## Why This Exists
/// - **Hybrid Distribution**: Push announces availability, nodes can pull
/// - **Pre-warming**: Reduce cold start latency by pre-fetching modules
/// - **Version Management**: Deploy new versions without disrupting running actors
///
/// ## Design Notes
/// - Module stored in cluster registry (e.g., S3, Redis, etcd)
/// - Nodes notified of new module (can pre-fetch if heuristics match)
/// - Idempotent: Re-deploying same module (same hash) is no-op
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployWasmModuleRequest {
    /// WASM module to deploy
    #[prost(message, optional, tag="1")]
    pub module: ::core::option::Option<WasmModule>,
    /// How to distribute module to nodes
    #[prost(enumeration="deploy_wasm_module_request::PreWarmStrategy", tag="2")]
    pub pre_warm: i32,
    /// Node tags for PUSH_TAGGED strategy (e.g., \["us-east-1", "production"\])
    #[prost(string, repeated, tag="3")]
    pub target_node_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DeployWasmModuleRequest`.
pub mod deploy_wasm_module_request {
    /// Pre-warm strategy
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PreWarmStrategy {
        /// No pre-warming - nodes fetch on-demand (lazy)
        None = 0,
        /// Announce to all nodes - they decide whether to pre-fetch
        Announce = 1,
        /// Push to all nodes immediately (eager)
        PushAll = 2,
        /// Push to subset of nodes (e.g., based on tags)
        PushTagged = 3,
    }
    impl PreWarmStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PreWarmStrategy::None => "NONE",
                PreWarmStrategy::Announce => "ANNOUNCE",
                PreWarmStrategy::PushAll => "PUSH_ALL",
                PreWarmStrategy::PushTagged => "PUSH_TAGGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "ANNOUNCE" => Some(Self::Announce),
                "PUSH_ALL" => Some(Self::PushAll),
                "PUSH_TAGGED" => Some(Self::PushTagged),
                _ => None,
            }
        }
    }
}
/// Deploy WASM module response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployWasmModuleResponse {
    /// Was deployment successful?
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Module hash (for cache lookup)
    #[prost(string, tag="2")]
    pub module_hash: ::prost::alloc::string::String,
    /// Number of nodes that received the module (for pre-warming)
    #[prost(uint32, tag="3")]
    pub nodes_pre_warmed: u32,
    /// Error details if deployment failed (replaces error_message)
    ///
    /// If deployment succeeded, this field is not set (code = OK).
    /// If deployment failed, code indicates failure reason.
    #[prost(message, optional, tag="4")]
    pub error: ::core::option::Option<WasmError>,
}
/// Instantiate WASM actor request
///
/// ## Purpose
/// Creates a new actor instance from a deployed WASM module. The instance
/// is initialized with provided state and configuration.
///
/// ## Why This Exists
/// - **Dynamic Actor Creation**: Spawn actors at runtime (like erlang:spawn)
/// - **State Initialization**: Restore actor from snapshot or start fresh
/// - **Configuration Flexibility**: Each actor can have custom config
///
/// ## Design Notes
/// - Module must be deployed first (or node will fetch on-demand)
/// - Initial state is opaque bytes (actor interprets based on module logic)
/// - Config can override module defaults (e.g., more memory for specific actor)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantiateActorRequest {
    /// Module name or hash to instantiate
    ///
    /// Supports both:
    /// - Name: "counter-actor@1.2.3" (fetches from registry)
    /// - Hash: "a1b2c3d4..." (direct cache lookup)
    #[prost(string, tag="1")]
    pub module_ref: ::prost::alloc::string::String,
    /// Actor ID to assign to this instance
    ///
    /// Format: ULID for sortability (see CLAUDE.md Core Principle 0)
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Initial state bytes (opaque to runtime)
    ///
    /// Passed to WASM module's init() function.
    /// Can be:
    /// - Empty (new actor with default state)
    /// - Snapshot (restoring actor from checkpoint)
    /// - Migration state (actor moving to new node)
    #[prost(bytes="vec", tag="3")]
    pub initial_state: ::prost::alloc::vec::Vec<u8>,
    /// Configuration overrides (optional)
    ///
    /// If not provided, uses module's default config or system defaults.
    #[prost(message, optional, tag="4")]
    pub config: ::core::option::Option<WasmConfig>,
    /// Node ID to instantiate on (optional)
    ///
    /// If not provided, scheduler chooses node based on load balancing.
    #[prost(string, tag="5")]
    pub target_node_id: ::prost::alloc::string::String,
}
/// Instantiate WASM actor response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantiateActorResponse {
    /// Was instantiation successful?
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Actor ID of instantiated actor
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Node ID where actor is running
    #[prost(string, tag="3")]
    pub node_id: ::prost::alloc::string::String,
    /// Instance creation time
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Error details if instantiation failed (replaces error_message)
    ///
    /// If instantiation succeeded, this field is not set (code = OK).
    /// If instantiation failed, code indicates failure reason.
    #[prost(message, optional, tag="5")]
    pub error: ::core::option::Option<WasmError>,
}
/// Migrate WASM actor request
///
/// ## Purpose
/// Moves a running actor from one node to another. Only state migrates,
/// code (WASM module) is already cached on destination node.
///
/// ## Why This Exists
/// - **Load Balancing**: Move actors to less loaded nodes
/// - **Node Shutdown**: Drain actors before maintenance
/// - **Locality Optimization**: Move actor closer to data
///
/// ## Design Notes
/// - Explicit migration (user-initiated) - simplest approach (User Decision A8)
/// - Code cached everywhere - only state migrates (10ms vs 500ms)
/// - Atomic migration: Source actor paused until destination ready
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateActorRequest {
    /// Actor ID to migrate
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Source node ID (current location)
    #[prost(string, tag="2")]
    pub source_node_id: ::prost::alloc::string::String,
    /// Destination node ID (target location)
    #[prost(string, tag="3")]
    pub target_node_id: ::prost::alloc::string::String,
    /// Include journal entries (for durable actors)
    ///
    /// If true, migrate journal for replay on destination.
    #[prost(bool, tag="4")]
    pub include_journal: bool,
}
/// Migrate WASM actor response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateActorResponse {
    /// Was migration successful?
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Migration duration (should be < 10ms for state-only)
    #[prost(message, optional, tag="2")]
    pub migration_time: ::core::option::Option<::prost_types::Duration>,
    /// Size of state transferred (bytes)
    #[prost(uint64, tag="3")]
    pub state_size_bytes: u64,
    /// Error details if migration failed
    #[prost(message, optional, tag="4")]
    pub error: ::core::option::Option<WasmError>,
}
/// WASM error details
///
/// ## Purpose
/// Provides structured error information for debugging and error handling.
/// Replaces simple string error messages with typed, actionable error data.
///
/// ## Why This Exists
/// - **Debugging**: Details map provides context (module name, actor ID, stack trace)
/// - **Client Handling**: Clients can programmatically handle specific error codes
/// - **Observability**: Error metrics can be tracked by code
/// - **Hash Mismatch**: Special fields for integrity check failures
///
/// ## Design Notes
/// - Compatible with gRPC Status (code + message + details)
/// - Details map is extensible (add any key-value metadata)
/// - expected_hash/actual_hash only populated for HASH_MISMATCH errors
///
/// ## Examples
/// ```
/// WasmError {
///    code: RESOURCE_LIMIT_EXCEEDED,
///    message: "Memory limit exceeded: 18MB > 16MB",
///    details: {
///      "actor_id": "calc-001@node2",
///      "limit": "16777216",
///      "actual": "18874368",
///      "resource": "memory"
///    }
/// }
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WasmError {
    /// Error code category
    #[prost(enumeration="WasmErrorCode", tag="1")]
    pub code: i32,
    /// Human-readable error message
    ///
    /// Format: Brief description suitable for logging and user display
    /// Example: "Module compilation failed: invalid opcode at offset 0x1234"
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Additional context for debugging
    ///
    /// Common keys:
    /// - "actor_id": Actor that failed
    /// - "module_name": Module that failed
    /// - "module_hash": Module hash for integrity errors
    /// - "stack_trace": Stack trace if available
    /// - "resource": Resource type (memory, fuel, cpu_time)
    /// - "limit": Resource limit value
    /// - "actual": Actual resource usage
    #[prost(map="string, string", tag="3")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// For HASH_MISMATCH: expected hash (SHA-256 hex)
    #[prost(string, tag="4")]
    pub expected_hash: ::prost::alloc::string::String,
    /// For HASH_MISMATCH: actual hash (SHA-256 hex)
    #[prost(string, tag="5")]
    pub actual_hash: ::prost::alloc::string::String,
}
/// WASM runtime error codes
///
/// ## Purpose
/// Defines error categories for WASM operations. Used for gRPC status codes
/// and error reporting across language boundaries.
///
/// ## Why This Exists
/// - **Proto-First**: Errors are part of the API contract (not Rust-only)
/// - **Multi-Language**: Error types available in all supported languages (TypeScript, Python SDKs)
/// - **gRPC Compatibility**: Maps to gRPC status codes for proper error handling
/// - **Structured Errors**: Clients can handle specific error types programmatically
///
/// ## Design Notes
/// - Error codes are stable (don't reorder or change values)
/// - New error codes can be added at the end
/// - OK = 0 for consistency with gRPC conventions
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WasmErrorCode {
    /// Success (not an error)
    WasmErrorCodeOk = 0,
    /// Module compilation failed
    ///
    /// Causes: Invalid WASM bytecode, unsupported features, syntax errors
    /// Recovery: Fix WASM module, use compatible toolchain
    WasmErrorCodeCompilationFailed = 1,
    /// Module instantiation failed
    ///
    /// Causes: Import resolution errors, initialization errors, memory allocation failure
    /// Recovery: Check module dependencies, ensure host functions available
    WasmErrorCodeInstantiationFailed = 2,
    /// Resource limit exceeded (memory, fuel, CPU time)
    ///
    /// Causes: Actor exceeded memory/fuel/time quota
    /// Recovery: Increase limits or optimize actor code
    WasmErrorCodeResourceLimitExceeded = 3,
    /// Capability denied (missing permission)
    ///
    /// Causes: Actor attempted unauthorized operation (filesystem, network, spawn)
    /// Recovery: Grant capability or remove unauthorized code
    WasmErrorCodeCapabilityDenied = 4,
    /// Host function call failed
    ///
    /// Causes: Host function error (send_message failed, tuplespace_write failed)
    /// Recovery: Check host function arguments, retry
    WasmErrorCodeHostFunctionError = 5,
    /// Actor function call failed
    ///
    /// Causes: Actor's exported function (init, handle_message) threw error or trapped
    /// Recovery: Fix actor code, check logs
    WasmErrorCodeActorFunctionError = 6,
    /// Module cache error
    ///
    /// Causes: Cache lookup failed, eviction error, storage backend error
    /// Recovery: Retry, check cache backend health
    WasmErrorCodeCacheError = 7,
    /// Module hash mismatch (integrity check failed)
    ///
    /// Causes: Module bytes corrupted during transfer, malicious modification
    /// Recovery: Re-deploy module, check network integrity
    WasmErrorCodeHashMismatch = 8,
    /// Module not found
    ///
    /// Causes: Module not deployed, evicted from cache, wrong name/version
    /// Recovery: Deploy module first, check name/version
    WasmErrorCodeModuleNotFound = 9,
    /// Serialization/deserialization error
    ///
    /// Causes: Invalid protobuf, incompatible schema version
    /// Recovery: Check message format, ensure compatible versions
    WasmErrorCodeSerializationError = 10,
    /// Internal wasmtime runtime error
    ///
    /// Causes: wasmtime internal error, runtime bug
    /// Recovery: Check logs, report bug, try different wasmtime version
    WasmErrorCodeWasmtimeError = 11,
}
impl WasmErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WasmErrorCode::WasmErrorCodeOk => "WASM_ERROR_CODE_OK",
            WasmErrorCode::WasmErrorCodeCompilationFailed => "WASM_ERROR_CODE_COMPILATION_FAILED",
            WasmErrorCode::WasmErrorCodeInstantiationFailed => "WASM_ERROR_CODE_INSTANTIATION_FAILED",
            WasmErrorCode::WasmErrorCodeResourceLimitExceeded => "WASM_ERROR_CODE_RESOURCE_LIMIT_EXCEEDED",
            WasmErrorCode::WasmErrorCodeCapabilityDenied => "WASM_ERROR_CODE_CAPABILITY_DENIED",
            WasmErrorCode::WasmErrorCodeHostFunctionError => "WASM_ERROR_CODE_HOST_FUNCTION_ERROR",
            WasmErrorCode::WasmErrorCodeActorFunctionError => "WASM_ERROR_CODE_ACTOR_FUNCTION_ERROR",
            WasmErrorCode::WasmErrorCodeCacheError => "WASM_ERROR_CODE_CACHE_ERROR",
            WasmErrorCode::WasmErrorCodeHashMismatch => "WASM_ERROR_CODE_HASH_MISMATCH",
            WasmErrorCode::WasmErrorCodeModuleNotFound => "WASM_ERROR_CODE_MODULE_NOT_FOUND",
            WasmErrorCode::WasmErrorCodeSerializationError => "WASM_ERROR_CODE_SERIALIZATION_ERROR",
            WasmErrorCode::WasmErrorCodeWasmtimeError => "WASM_ERROR_CODE_WASMTIME_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WASM_ERROR_CODE_OK" => Some(Self::WasmErrorCodeOk),
            "WASM_ERROR_CODE_COMPILATION_FAILED" => Some(Self::WasmErrorCodeCompilationFailed),
            "WASM_ERROR_CODE_INSTANTIATION_FAILED" => Some(Self::WasmErrorCodeInstantiationFailed),
            "WASM_ERROR_CODE_RESOURCE_LIMIT_EXCEEDED" => Some(Self::WasmErrorCodeResourceLimitExceeded),
            "WASM_ERROR_CODE_CAPABILITY_DENIED" => Some(Self::WasmErrorCodeCapabilityDenied),
            "WASM_ERROR_CODE_HOST_FUNCTION_ERROR" => Some(Self::WasmErrorCodeHostFunctionError),
            "WASM_ERROR_CODE_ACTOR_FUNCTION_ERROR" => Some(Self::WasmErrorCodeActorFunctionError),
            "WASM_ERROR_CODE_CACHE_ERROR" => Some(Self::WasmErrorCodeCacheError),
            "WASM_ERROR_CODE_HASH_MISMATCH" => Some(Self::WasmErrorCodeHashMismatch),
            "WASM_ERROR_CODE_MODULE_NOT_FOUND" => Some(Self::WasmErrorCodeModuleNotFound),
            "WASM_ERROR_CODE_SERIALIZATION_ERROR" => Some(Self::WasmErrorCodeSerializationError),
            "WASM_ERROR_CODE_WASMTIME_ERROR" => Some(Self::WasmErrorCodeWasmtimeError),
            _ => None,
        }
    }
}
include!("plexspaces.wasm.v1.tonic.rs");
// @@protoc_insertion_point(module)