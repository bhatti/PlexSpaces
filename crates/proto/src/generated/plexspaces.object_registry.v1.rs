// @generated
// This file is @generated by prost-build.
// ============================================================================
// CORE DATA MODEL
// ============================================================================

/// Unified object registration
///
/// This message represents ANY registered object in PlexSpaces (actor, tuplespace, service).
/// Type-specific fields use `object_category` and `capabilities` for differentiation.
///
/// ==================== IDENTITY ====================
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectRegistration {
    /// Unique object identifier (ULID for sortability)
    /// Format varies by type:
    /// - Actor: "actor_name@node_id" (e.g., "counter@node1")
    /// - TupleSpace: "ts-{backend}-{tenant}-{namespace}" (e.g., "ts-redis-acme-prod")
    /// - Service: "{service_name}-{instance_id}" (e.g., "order-svc-a1b2c3")
    #[prost(string, tag="1")]
    pub object_id: ::prost::alloc::string::String,
    /// Human-readable name (optional, for display)
    /// Examples: "Counter Actor", "Production TupleSpace", "Order Service"
    #[prost(string, tag="2")]
    pub object_name: ::prost::alloc::string::String,
    /// Object type (REQUIRED - Actor, TupleSpace, Service)
    #[prost(enumeration="ObjectType", tag="3")]
    pub object_type: i32,
    /// Version string (semantic versioning recommended)
    /// Examples: "1.0.0", "2.1.3-beta", "latest"
    #[prost(string, tag="4")]
    pub version: ::prost::alloc::string::String,
    // ==================== MULTI-TENANCY ====================

    /// Tenant identifier for multi-tenancy
    /// Examples: "acme-corp", "globex-inc", "user-123", "default"
    #[prost(string, tag="5")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace for logical grouping within tenant
    /// Examples: "production", "staging", "test", "feature-x"
    #[prost(string, tag="6")]
    pub namespace: ::prost::alloc::string::String,
    // ==================== LOCATION ====================

    /// Node identifier hosting this object
    /// Examples: "node1", "k8s-pod-abc123", "vm-instance-5"
    #[prost(string, tag="7")]
    pub node_id: ::prost::alloc::string::String,
    /// gRPC address to connect to this object (PRIMARY PURPOSE!)
    /// Format: "<http://host:port"> or "<https://host:port">
    /// Examples:
    /// - Actor: "<http://node1:9001"> (ActorService endpoint)
    /// - TupleSpace: "<http://ts-node:9002"> (TuplePlexSpaceService endpoint)
    /// - Service: "<http://order-pod:50051"> (Custom service endpoint)
    #[prost(string, tag="8")]
    pub grpc_address: ::prost::alloc::string::String,
    // ==================== TYPE-SPECIFIC CLASSIFICATION ====================

    /// Object category (sub-type, implementation-specific)
    ///
    /// For Actor:
    /// - "GenServer", "Workflow", "VirtualActor", "Supervisor", "StateMachine", "Custom"
    ///
    /// For TupleSpace:
    /// - "redis", "postgresql", "sqlite", "memory", "custom"
    ///
    /// For Service:
    /// - Service name: "order-service", "payment-service", "auth-service", "custom-api"
    #[prost(string, tag="9")]
    pub object_category: ::prost::alloc::string::String,
    /// Capabilities list (type-specific features)
    ///
    /// For Actor:
    /// - "persistent", "supervised", "mobile", "auto-activate", "keyed"
    ///
    /// For TupleSpace:
    /// - "persistent", "distributed", "barriers", "transactions", "watch"
    ///
    /// For Service:
    /// - "grpc", "http", "websocket", "streaming", "batch"
    #[prost(string, repeated, tag="10")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    // ==================== METADATA & CONFIGURATION ====================

    /// Additional metadata (key-value pairs)
    #[prost(message, optional, tag="11")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    /// Health status
    #[prost(enumeration="HealthStatus", tag="12")]
    pub health_status: i32,
    /// Labels for discovery and filtering (tag cloud)
    /// Examples: "prod", "us-west-2", "gpu-enabled", "high-memory", "experimental"
    #[prost(string, repeated, tag="13")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Performance metrics (type-specific)
    /// Examples:
    /// - Actor: "message_rate", "cpu_usage", "memory_mb"
    /// - TupleSpace: "tuple_count", "query_latency_ms", "throughput"
    /// - Service: "request_rate", "error_rate", "latency_p99"
    #[prost(map="string, double", tag="14")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    // ==================== LIFECYCLE & MONITORING ====================

    /// Last heartbeat timestamp (for health monitoring)
    #[prost(message, optional, tag="15")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    /// Registration creation timestamp
    #[prost(message, optional, tag="16")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Registration update timestamp
    #[prost(message, optional, tag="17")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================================================
// REQUEST/RESPONSE MESSAGES
// ============================================================================

/// Register object request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterRequest {
    /// Object registration to create/update
    #[prost(message, optional, tag="1")]
    pub registration: ::core::option::Option<ObjectRegistration>,
    /// TTL for auto-expiry (optional, default: no expiry)
    /// If specified, object auto-unregisters after TTL expires
    #[prost(message, optional, tag="2")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResponse {
    /// Registered object (with generated timestamps)
    #[prost(message, optional, tag="1")]
    pub registration: ::core::option::Option<ObjectRegistration>,
    /// Whether this was a new registration (true) or update (false)
    #[prost(bool, tag="2")]
    pub created: bool,
}
/// Unregister object request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterRequest {
    /// Object ID to unregister
    #[prost(string, tag="1")]
    pub object_id: ::prost::alloc::string::String,
    /// Object type (for key construction)
    #[prost(enumeration="ObjectType", tag="2")]
    pub object_type: i32,
    /// Tenant ID (for multi-tenancy)
    #[prost(string, tag="3")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace (for logical grouping)
    #[prost(string, tag="4")]
    pub namespace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterResponse {
    /// Whether object was found and unregistered
    #[prost(bool, tag="1")]
    pub unregistered: bool,
}
/// Lookup single object request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupRequest {
    /// Object ID to lookup
    #[prost(string, tag="1")]
    pub object_id: ::prost::alloc::string::String,
    /// Object type (optional - if not specified, searches all types)
    #[prost(enumeration="ObjectType", tag="2")]
    pub object_type: i32,
    /// Tenant ID (for multi-tenancy)
    #[prost(string, tag="3")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace (for logical grouping)
    #[prost(string, tag="4")]
    pub namespace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupResponse {
    /// Object registration (null if not found)
    #[prost(message, optional, tag="1")]
    pub registration: ::core::option::Option<ObjectRegistration>,
    /// Whether object was found
    #[prost(bool, tag="2")]
    pub found: bool,
}
/// Discover objects request (with extensive filtering)
///
/// ==================== TYPE FILTERING ====================
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoverRequest {
    /// Filter by object type (optional - if not specified, returns ALL types)
    #[prost(enumeration="ObjectType", tag="1")]
    pub object_type: i32,
    /// Filter by object category (exact match)
    /// Examples: "GenServer", "redis", "order-service"
    #[prost(string, tag="2")]
    pub object_category: ::prost::alloc::string::String,
    // ==================== LOCATION FILTERING ====================

    /// Filter by node ID
    #[prost(string, tag="3")]
    pub node_id: ::prost::alloc::string::String,
    /// Filter by tenant ID
    #[prost(string, tag="4")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Filter by namespace
    #[prost(string, tag="5")]
    pub namespace: ::prost::alloc::string::String,
    // ==================== CAPABILITY FILTERING ====================

    /// Filter by capabilities (ALL must be present)
    /// Example: \["persistent", "distributed"\] → only objects with BOTH capabilities
    #[prost(string, repeated, tag="6")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by labels (ANY can match)
    /// Example: \["prod", "us-west-2"\] → objects with "prod" OR "us-west-2"
    #[prost(string, repeated, tag="7")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    // ==================== HEALTH FILTERING ====================

    /// Filter by health status
    #[prost(enumeration="HealthStatus", tag="8")]
    pub health_status: i32,
    /// Filter by minimum health age (exclude stale objects)
    /// Example: last_heartbeat < (now - max_age) → excluded
    #[prost(message, optional, tag="9")]
    pub max_heartbeat_age: ::core::option::Option<::prost_types::Duration>,
    // ==================== PAGINATION ====================

    /// Maximum results per page (default: 100, max: 1000)
    #[prost(int32, tag="10")]
    pub page_size: i32,
    /// Pagination token from previous response (opaque)
    #[prost(string, tag="11")]
    pub page_token: ::prost::alloc::string::String,
    // ==================== SORTING ====================

    /// Sort field (default: "created_at")
    /// Options: "object_id", "created_at", "updated_at", "last_heartbeat"
    #[prost(string, tag="12")]
    pub sort_by: ::prost::alloc::string::String,
    /// Sort order (default: ascending)
    #[prost(bool, tag="13")]
    pub descending: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoverResponse {
    /// Matching objects (paginated)
    #[prost(message, repeated, tag="1")]
    pub registrations: ::prost::alloc::vec::Vec<ObjectRegistration>,
    /// Total count of matching objects (before pagination)
    #[prost(int64, tag="2")]
    pub total_count: i64,
    /// Next page token (empty if no more results)
    #[prost(string, tag="3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Whether there are more results
    #[prost(bool, tag="4")]
    pub has_more: bool,
}
/// Heartbeat request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    /// Object ID sending heartbeat
    #[prost(string, tag="1")]
    pub object_id: ::prost::alloc::string::String,
    /// Object type
    #[prost(enumeration="ObjectType", tag="2")]
    pub object_type: i32,
    /// Tenant ID
    #[prost(string, tag="3")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace
    #[prost(string, tag="4")]
    pub namespace: ::prost::alloc::string::String,
    /// Updated health status (optional)
    #[prost(enumeration="HealthStatus", tag="5")]
    pub health_status: i32,
    /// Updated metrics (optional)
    #[prost(map="string, double", tag="6")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatResponse {
    /// Whether heartbeat was accepted
    #[prost(bool, tag="1")]
    pub accepted: bool,
    /// Updated registration
    #[prost(message, optional, tag="2")]
    pub registration: ::core::option::Option<ObjectRegistration>,
}
/// Batch heartbeat request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchHeartbeatRequest {
    /// Multiple heartbeats
    #[prost(message, repeated, tag="1")]
    pub heartbeats: ::prost::alloc::vec::Vec<HeartbeatRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchHeartbeatResponse {
    /// Results for each heartbeat (same order as request)
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<HeartbeatResponse>,
    /// Number of successful heartbeats
    #[prost(int32, tag="2")]
    pub success_count: i32,
    /// Number of failed heartbeats
    #[prost(int32, tag="3")]
    pub failure_count: i32,
}
/// List object types request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectTypesRequest {
    /// Filter by tenant (optional)
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Filter by namespace (optional)
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
}
/// Object type summary
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectTypeSummary {
    /// Object type
    #[prost(enumeration="ObjectType", tag="1")]
    pub object_type: i32,
    /// Count of registered objects
    #[prost(int64, tag="2")]
    pub count: i64,
    /// Count by health status
    #[prost(map="string, int64", tag="3")]
    pub health_counts: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectTypesResponse {
    /// Summary for each object type
    #[prost(message, repeated, tag="1")]
    pub summaries: ::prost::alloc::vec::Vec<ObjectTypeSummary>,
    /// Total registered objects across all types
    #[prost(int64, tag="2")]
    pub total_count: i64,
}
// ============================================================================
// CORE ENUMS
// ============================================================================

/// Object type enum (mandatory for all registrations)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ObjectType {
    /// Unspecified - not allowed, must specify type
    ObjectTypeUnspecified = 0,
    /// Actor: Stateful computation unit (actor model)
    /// Examples: GenServer, Workflow, VirtualActor, Supervisor
    ObjectTypeActor = 1,
    /// TupleSpace: Coordination primitive (Linda model)
    /// Examples: Redis-backed, PostgreSQL-backed, in-memory
    ObjectTypeTuplespace = 2,
    /// Service: Microservice or gRPC endpoint
    /// Examples: order-service, payment-service, custom APIs
    ObjectTypeService = 3,
    /// VM: Firecracker microVM instance
    /// Examples: firecracker-vm-001, vm-tenant-a
    /// object_category: "firecracker", "qemu", etc.
    /// grpc_address: VM's API socket path or management endpoint
    ObjectTypeVm = 4,
    /// Application: PlexSpaces application (Erlang-style)
    /// Examples: calculator-app, order-processing-app
    /// object_category: Application name (e.g., "calculator")
    /// grpc_address: Node's ApplicationService endpoint
    /// node_id: Node where application is deployed
    ObjectTypeApplication = 5,
    /// Workflow: Workflow execution instance
    /// Examples: workflow-exec-123, order-workflow-456
    /// object_category: Workflow definition ID
    /// grpc_address: Node's WorkflowService endpoint
    /// node_id: Node where workflow is running
    ObjectTypeWorkflow = 6,
    /// Node: PlexSpaces node instance
    /// Examples: node-1, k8s-pod-abc123
    /// object_category: "Node"
    /// grpc_address: Node's gRPC endpoint
    ObjectTypeNode = 7,
}
impl ObjectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ObjectType::ObjectTypeUnspecified => "OBJECT_TYPE_UNSPECIFIED",
            ObjectType::ObjectTypeActor => "OBJECT_TYPE_ACTOR",
            ObjectType::ObjectTypeTuplespace => "OBJECT_TYPE_TUPLESPACE",
            ObjectType::ObjectTypeService => "OBJECT_TYPE_SERVICE",
            ObjectType::ObjectTypeVm => "OBJECT_TYPE_VM",
            ObjectType::ObjectTypeApplication => "OBJECT_TYPE_APPLICATION",
            ObjectType::ObjectTypeWorkflow => "OBJECT_TYPE_WORKFLOW",
            ObjectType::ObjectTypeNode => "OBJECT_TYPE_NODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OBJECT_TYPE_UNSPECIFIED" => Some(Self::ObjectTypeUnspecified),
            "OBJECT_TYPE_ACTOR" => Some(Self::ObjectTypeActor),
            "OBJECT_TYPE_TUPLESPACE" => Some(Self::ObjectTypeTuplespace),
            "OBJECT_TYPE_SERVICE" => Some(Self::ObjectTypeService),
            "OBJECT_TYPE_VM" => Some(Self::ObjectTypeVm),
            "OBJECT_TYPE_APPLICATION" => Some(Self::ObjectTypeApplication),
            "OBJECT_TYPE_WORKFLOW" => Some(Self::ObjectTypeWorkflow),
            "OBJECT_TYPE_NODE" => Some(Self::ObjectTypeNode),
            _ => None,
        }
    }
}
/// Health status (common across all object types)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    HealthStatusUnknown = 0,
    HealthStatusHealthy = 1,
    HealthStatusDegraded = 2,
    HealthStatusUnhealthy = 3,
    HealthStatusStarting = 4,
    HealthStatusStopping = 5,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HealthStatus::HealthStatusUnknown => "HEALTH_STATUS_UNKNOWN",
            HealthStatus::HealthStatusHealthy => "HEALTH_STATUS_HEALTHY",
            HealthStatus::HealthStatusDegraded => "HEALTH_STATUS_DEGRADED",
            HealthStatus::HealthStatusUnhealthy => "HEALTH_STATUS_UNHEALTHY",
            HealthStatus::HealthStatusStarting => "HEALTH_STATUS_STARTING",
            HealthStatus::HealthStatusStopping => "HEALTH_STATUS_STOPPING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNKNOWN" => Some(Self::HealthStatusUnknown),
            "HEALTH_STATUS_HEALTHY" => Some(Self::HealthStatusHealthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::HealthStatusDegraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::HealthStatusUnhealthy),
            "HEALTH_STATUS_STARTING" => Some(Self::HealthStatusStarting),
            "HEALTH_STATUS_STOPPING" => Some(Self::HealthStatusStopping),
            _ => None,
        }
    }
}
include!("plexspaces.object_registry.v1.tonic.rs");
// @@protoc_insertion_point(module)