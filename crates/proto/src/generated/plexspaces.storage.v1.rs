// @generated
// This file is @generated by prost-build.
/// BlobMetadata represents metadata about a stored blob
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobMetadata {
    /// Unique blob identifier (ULID or SHA256-based)
    #[prost(string, tag="1")]
    pub blob_id: ::prost::alloc::string::String,
    /// Tenant identifier for multi-tenancy isolation
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace within tenant (e.g., "production", "staging", "dev")
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
    /// Display name for the blob
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    /// SHA256 hash of blob contents (for deduplication)
    #[prost(string, tag="5")]
    pub sha256: ::prost::alloc::string::String,
    /// Content type (MIME type)
    #[prost(string, tag="6")]
    pub content_type: ::prost::alloc::string::String,
    /// Content length in bytes
    #[prost(int64, tag="7")]
    pub content_length: i64,
    /// ETag from object store
    #[prost(string, tag="8")]
    pub etag: ::prost::alloc::string::String,
    /// Blob group/category (optional grouping)
    #[prost(string, tag="9")]
    pub blob_group: ::prost::alloc::string::String,
    /// Blob kind/type (e.g., "LOGS", "ARTIFACTS", "CACHE", "USER_UPLOADED")
    #[prost(string, tag="10")]
    pub kind: ::prost::alloc::string::String,
    /// Custom metadata (key-value pairs)
    #[prost(map="string, string", tag="11")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Custom tags (key-value pairs)
    #[prost(map="string, string", tag="12")]
    pub tags: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Expiration time (when blob should be deleted)
    #[prost(message, optional, tag="13")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Creation time
    #[prost(message, optional, tag="14")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update time
    #[prost(message, optional, tag="15")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Blob storage configuration
///
/// ## Purpose
/// Configuration for S3-compatible blob storage backend (S3, MinIO, GCP, Azure).
/// Used for storing large binary objects with metadata management.
///
/// ## Usage
/// This config is typically included in RuntimeConfig for node-level configuration,
/// but can also be used standalone for service-specific configuration.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobConfig {
    /// Backend type (s3, minio, gcp, azure)
    #[prost(string, tag="1")]
    pub backend: ::prost::alloc::string::String,
    /// Bucket name
    #[prost(string, tag="2")]
    pub bucket: ::prost::alloc::string::String,
    /// Endpoint URL (for MinIO or custom S3-compatible)
    #[prost(string, tag="3")]
    pub endpoint: ::prost::alloc::string::String,
    /// Region (for S3/GCP/Azure)
    #[prost(string, tag="4")]
    pub region: ::prost::alloc::string::String,
    /// Access key ID
    #[prost(string, tag="5")]
    pub access_key_id: ::prost::alloc::string::String,
    /// Secret access key (should be from env var, not config file)
    #[prost(string, tag="6")]
    pub secret_access_key: ::prost::alloc::string::String,
    /// Use SSL/TLS
    #[prost(bool, tag="7")]
    pub use_ssl: bool,
    /// Path prefix for all blobs (default: /plexspaces)
    #[prost(string, tag="8")]
    pub prefix: ::prost::alloc::string::String,
    /// GCP-specific: Service account JSON (base64 encoded)
    #[prost(string, tag="9")]
    pub gcp_service_account_json: ::prost::alloc::string::String,
    /// Azure-specific: Account name
    #[prost(string, tag="10")]
    pub azure_account_name: ::prost::alloc::string::String,
    /// Azure-specific: Account key
    #[prost(string, tag="11")]
    pub azure_account_key: ::prost::alloc::string::String,
}
/// Upload blob request (HTTP multipart/form-data or raw body)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadBlobRequest {
    /// Tenant ID
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Blob name
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    /// Content type (optional, will be detected if not provided)
    #[prost(string, tag="4")]
    pub content_type: ::prost::alloc::string::String,
    /// Blob group (optional)
    #[prost(string, tag="5")]
    pub blob_group: ::prost::alloc::string::String,
    /// Blob kind (optional)
    #[prost(string, tag="6")]
    pub kind: ::prost::alloc::string::String,
    /// Custom metadata
    #[prost(map="string, string", tag="7")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Custom tags
    #[prost(map="string, string", tag="8")]
    pub tags: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Expiration duration (optional)
    #[prost(message, optional, tag="9")]
    pub expires_after: ::core::option::Option<::prost_types::Duration>,
    /// Blob data (for gRPC streaming or HTTP body)
    #[prost(bytes="vec", tag="10")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Upload blob response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadBlobResponse {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<BlobMetadata>,
}
/// Download blob request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadBlobRequest {
    /// Blob ID
    #[prost(string, tag="1")]
    pub blob_id: ::prost::alloc::string::String,
    /// Tenant ID (for authorization)
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace (for authorization)
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
}
/// Download blob response (streaming)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadBlobResponse {
    /// Blob metadata (sent first)
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<BlobMetadata>,
    /// Blob data chunks (streamed)
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Get blob metadata request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlobMetadataRequest {
    #[prost(string, tag="1")]
    pub blob_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
}
/// Get blob metadata response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlobMetadataResponse {
    #[prost(message, optional, tag="1")]
    pub metadata: ::core::option::Option<BlobMetadata>,
}
/// List blobs request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlobsRequest {
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Filter by name (prefix match)
    #[prost(string, tag="3")]
    pub name_prefix: ::prost::alloc::string::String,
    /// Filter by blob_group
    #[prost(string, tag="4")]
    pub blob_group: ::prost::alloc::string::String,
    /// Filter by kind
    #[prost(string, tag="5")]
    pub kind: ::prost::alloc::string::String,
    /// Filter by SHA256
    #[prost(string, tag="6")]
    pub sha256: ::prost::alloc::string::String,
    /// Pagination
    #[prost(message, optional, tag="7")]
    pub page: ::core::option::Option<super::super::common::v1::PageRequest>,
}
/// List blobs response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlobsResponse {
    #[prost(message, repeated, tag="1")]
    pub blobs: ::prost::alloc::vec::Vec<BlobMetadata>,
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// Delete blob request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBlobRequest {
    #[prost(string, tag="1")]
    pub blob_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
}
/// Delete blob response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBlobResponse {
}
/// Generate presigned URL request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratePresignedUrlRequest {
    #[prost(string, tag="1")]
    pub blob_id: ::prost::alloc::string::String,
    /// Operation: "GET" or "PUT"
    #[prost(string, tag="2")]
    pub operation: ::prost::alloc::string::String,
    /// Expiration duration (default: 1 hour)
    #[prost(message, optional, tag="3")]
    pub expires_after: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag="4")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub namespace: ::prost::alloc::string::String,
}
/// Generate presigned URL response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratePresignedUrlResponse {
    #[prost(string, tag="1")]
    pub url: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Shared relational database configuration
///
/// ## Purpose
/// Configuration for components that always use relational database:
/// - scheduler (crates/scheduler/migrations)
/// - workflow (crates/workflow/migrations)
/// - object-registry (via KeyValueStore SQL backend)
/// - journaling (crates/journaling/migrations)
/// - blob (crates/blob/migrations)
///
/// ## Convention
/// All these components share the same database connection by default.
/// Can be overridden per-component if needed.
///
/// ## Environment Variables
/// - PLEXSPACES_DATABASE_URL: Connection string (can use ${VAR} syntax)
/// - PLEXSPACES_DATABASE_POOL_SIZE: Connection pool size (default: 10)
/// - PLEXSPACES_DATABASE_AUTO_MIGRATE: Auto-migrate on startup (default: true)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedRelationalDbConfig {
    /// Connection string (can use environment variable: ${DATABASE_URL})
    /// Format: postgres://user:password@host:port/database
    ///          sqlite:///path/to/database.db
    ///          sqlite::memory:
    ///
    /// Security: Passwords should be in environment variables, not config files
    /// Example: "postgres://user:${DB_PASSWORD}@localhost:5432/plexspaces"
    #[prost(string, tag="1")]
    pub connection_string: ::prost::alloc::string::String,
    /// Connection pool size (default: 10)
    #[prost(uint32, tag="2")]
    pub pool_size: u32,
    /// Auto-migrate on startup (default: true)
    /// Runs migrations from migration_paths on node startup
    #[prost(bool, tag="3")]
    pub auto_migrate: bool,
    /// Migration paths (default: auto-discover from crates/*/migrations)
    /// Paths are relative to workspace root or absolute
    #[prost(string, repeated, tag="4")]
    pub migration_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Redis backend configuration
///
/// ## Purpose
/// Configuration for Redis-based backends (locks, channel, keyvalue, tuplespace).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedisBackendConfig {
    /// Redis connection URL
    /// Format: redis://\[password@\]host:port\[/database\]
    ///          redis://localhost:6379/0
    ///          redis://:password@redis-cluster:6379/0
    ///
    /// Security: Passwords should be in environment variables
    /// Example: "redis://:${REDIS_PASSWORD}@localhost:6379/0"
    #[prost(string, tag="1")]
    pub url: ::prost::alloc::string::String,
    /// Connection pool size (default: 10)
    #[prost(uint32, tag="2")]
    pub pool_size: u32,
    /// Key prefix for namespace isolation (default: "plexspaces:")
    /// All keys will be prefixed with this value
    #[prost(string, tag="3")]
    pub key_prefix: ::prost::alloc::string::String,
    /// Connection timeout (default: 5 seconds)
    #[prost(message, optional, tag="4")]
    pub connect_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Enable cluster mode (default: false)
    /// If true, url should be comma-separated list of nodes
    #[prost(bool, tag="5")]
    pub cluster_mode: bool,
}
/// DynamoDB backend configuration
///
/// ## Purpose
/// Configuration for AWS DynamoDB-based backends (locks, keyvalue, tuplespace).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamoDbBackendConfig {
    /// AWS region (e.g., "us-east-1")
    #[prost(string, tag="1")]
    pub region: ::prost::alloc::string::String,
    /// Table name prefix (default: "plexspaces-")
    /// Actual table names will be: {prefix}{component_name}
    #[prost(string, tag="2")]
    pub table_prefix: ::prost::alloc::string::String,
    /// Endpoint URL (for local testing with DynamoDB Local)
    /// Leave empty for production (uses AWS service)
    #[prost(string, tag="3")]
    pub endpoint_url: ::prost::alloc::string::String,
    /// AWS access key ID (should be from env var, not config file)
    #[prost(string, tag="4")]
    pub access_key_id: ::prost::alloc::string::String,
    /// AWS secret access key (should be from env var, not config file)
    #[prost(string, tag="5")]
    pub secret_access_key: ::prost::alloc::string::String,
}
/// Storage provider configuration
///
/// ## Purpose
/// Configuration for components that support multiple storage providers.
/// Uses provider pattern (similar to Kubernetes StorageClass) for cleaner design.
///
/// ## Industry Best Practices
/// - Provider-based: One provider per config (not oneof with all options)
/// - Explicit: Must specify provider (no magic defaults)
/// - Extensible: Easy to add new providers without breaking changes
///
/// ## Backend Selection Logic
/// 1. Provider must be explicitly specified (no auto-detection)
/// 2. If provider is UNSPECIFIED, use default based on component:
///     - locks: REDIS (if available), else POSTGRES
///     - channel: REDIS (if available), else MEMORY
///     - tuplespace: POSTGRES (if available), else MEMORY
/// 3. Validation: Fail if provider not available (feature flags)
///
/// ## Environment Variables
/// - PLEXSPACES_{COMPONENT}_PROVIDER: Provider type (e.g., "redis", "postgres")
/// - Provider-specific env vars follow pattern: PLEXSPACES_{COMPONENT}_{PROVIDER}_{SETTING}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageProviderConfig {
    /// Storage provider type (required)
    #[prost(enumeration="StorageProvider", tag="1")]
    pub provider: i32,
    /// Provider-specific configuration (oneof for type safety)
    #[prost(oneof="storage_provider_config::Config", tags="2, 3, 4, 5, 6, 7, 8")]
    pub config: ::core::option::Option<storage_provider_config::Config>,
}
/// Nested message and enum types in `StorageProviderConfig`.
pub mod storage_provider_config {
    /// Provider-specific configuration (oneof for type safety)
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// PostgreSQL configuration
        #[prost(message, tag="2")]
        Postgres(super::SharedRelationalDbConfig),
        /// SQLite configuration
        #[prost(message, tag="3")]
        Sqlite(super::SqliteBackendConfig),
        /// Redis configuration
        #[prost(message, tag="4")]
        Redis(super::RedisBackendConfig),
        /// DynamoDB configuration
        #[prost(message, tag="5")]
        Dynamodb(super::DynamoDbBackendConfig),
        /// Kafka configuration (for channel)
        #[prost(message, tag="6")]
        Kafka(super::KafkaBackendConfig),
        /// NATS configuration (for channel)
        #[prost(message, tag="7")]
        Nats(super::NatsBackendConfig),
        /// Memory configuration (no-op, just a marker)
        #[prost(message, tag="8")]
        Memory(super::MemoryBackendConfig),
    }
}
/// Kafka backend configuration (for channel)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KafkaBackendConfig {
    /// Kafka broker addresses
    #[prost(string, repeated, tag="1")]
    pub brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Topic name
    #[prost(string, tag="2")]
    pub topic: ::prost::alloc::string::String,
    /// Consumer group ID
    #[prost(string, tag="3")]
    pub consumer_group: ::prost::alloc::string::String,
    /// Number of partitions (for topic creation)
    #[prost(uint32, tag="4")]
    pub partitions: u32,
    /// Replication factor
    #[prost(uint32, tag="5")]
    pub replication_factor: u32,
    #[prost(enumeration="kafka_backend_config::CompressionType", tag="6")]
    pub compression: i32,
    #[prost(enumeration="kafka_backend_config::ProducerAcks", tag="7")]
    pub acks: i32,
    /// Batch size for producers
    #[prost(uint64, tag="8")]
    pub batch_size: u64,
    /// Linger time for batching
    #[prost(message, optional, tag="9")]
    pub linger_ms: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `KafkaBackendConfig`.
pub mod kafka_backend_config {
    /// Compression type
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CompressionType {
        CompressionTypeNone = 0,
        CompressionTypeGzip = 1,
        CompressionTypeSnappy = 2,
        CompressionTypeLz4 = 3,
        CompressionTypeZstd = 4,
    }
    impl CompressionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompressionType::CompressionTypeNone => "COMPRESSION_TYPE_NONE",
                CompressionType::CompressionTypeGzip => "COMPRESSION_TYPE_GZIP",
                CompressionType::CompressionTypeSnappy => "COMPRESSION_TYPE_SNAPPY",
                CompressionType::CompressionTypeLz4 => "COMPRESSION_TYPE_LZ4",
                CompressionType::CompressionTypeZstd => "COMPRESSION_TYPE_ZSTD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPRESSION_TYPE_NONE" => Some(Self::CompressionTypeNone),
                "COMPRESSION_TYPE_GZIP" => Some(Self::CompressionTypeGzip),
                "COMPRESSION_TYPE_SNAPPY" => Some(Self::CompressionTypeSnappy),
                "COMPRESSION_TYPE_LZ4" => Some(Self::CompressionTypeLz4),
                "COMPRESSION_TYPE_ZSTD" => Some(Self::CompressionTypeZstd),
                _ => None,
            }
        }
    }
    /// Producer acks
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ProducerAcks {
        ProducerAcksNone = 0,
        ProducerAcksLeader = 1,
        ProducerAcksAll = 2,
    }
    impl ProducerAcks {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProducerAcks::ProducerAcksNone => "PRODUCER_ACKS_NONE",
                ProducerAcks::ProducerAcksLeader => "PRODUCER_ACKS_LEADER",
                ProducerAcks::ProducerAcksAll => "PRODUCER_ACKS_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRODUCER_ACKS_NONE" => Some(Self::ProducerAcksNone),
                "PRODUCER_ACKS_LEADER" => Some(Self::ProducerAcksLeader),
                "PRODUCER_ACKS_ALL" => Some(Self::ProducerAcksAll),
                _ => None,
            }
        }
    }
}
/// NATS backend configuration (for channel)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NatsBackendConfig {
    /// NATS server URLs (comma-separated for clustering)
    #[prost(string, tag="1")]
    pub servers: ::prost::alloc::string::String,
    /// Subject/topic name
    #[prost(string, tag="2")]
    pub subject: ::prost::alloc::string::String,
    /// Queue group for load-balanced consumption
    #[prost(string, tag="3")]
    pub queue_group: ::prost::alloc::string::String,
    /// Enable JetStream for persistence
    #[prost(bool, tag="4")]
    pub jetstream_enabled: bool,
    /// JetStream stream name
    #[prost(string, tag="5")]
    pub jetstream_stream: ::prost::alloc::string::String,
    /// JetStream consumer name
    #[prost(string, tag="6")]
    pub jetstream_consumer: ::prost::alloc::string::String,
    /// Connection timeout
    #[prost(message, optional, tag="7")]
    pub connect_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Reconnect attempts (-1 for unlimited)
    #[prost(int32, tag="8")]
    pub reconnect_attempts: i32,
    /// Enable TLS
    #[prost(bool, tag="9")]
    pub tls_enabled: bool,
    /// TLS certificate path
    #[prost(string, tag="10")]
    pub tls_cert_path: ::prost::alloc::string::String,
    /// TLS key path
    #[prost(string, tag="11")]
    pub tls_key_path: ::prost::alloc::string::String,
    /// TLS CA certificate path
    #[prost(string, tag="12")]
    pub tls_ca_path: ::prost::alloc::string::String,
}
/// Memory backend configuration (testing/development only)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryBackendConfig {
    /// Initial capacity (for HashMap pre-allocation)
    #[prost(uint32, tag="1")]
    pub initial_capacity: u32,
}
/// SQLite backend configuration
///
/// ## Purpose
/// Configuration for SQLite-based backends (primarily for channel).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqliteBackendConfig {
    /// SQLite database path
    /// - ":memory:" for in-memory database
    /// - File path for persistent database
    #[prost(string, tag="1")]
    pub database_path: ::prost::alloc::string::String,
    /// Enable WAL mode for better concurrency (default: true)
    #[prost(bool, tag="2")]
    pub wal_mode: bool,
    /// Synchronous mode: "NORMAL", "FULL", "OFF" (default: "NORMAL")
    #[prost(string, tag="3")]
    pub synchronous: ::prost::alloc::string::String,
}
/// Framework information
///
/// ## Purpose
/// Runtime information about the PlexSpaces framework version and build.
/// Auto-populated at build time from Cargo.toml.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkInfo {
    /// Framework version (from Cargo.toml, e.g., "0.1.0")
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    /// Build date (ISO 8601 format, e.g., "2025-01-25T10:30:00Z")
    #[prost(string, tag="2")]
    pub build_date: ::prost::alloc::string::String,
    /// Git commit hash (if available)
    #[prost(string, tag="3")]
    pub git_commit: ::prost::alloc::string::String,
    /// Build target (e.g., "x86_64-unknown-linux-gnu")
    #[prost(string, tag="4")]
    pub build_target: ::prost::alloc::string::String,
}
/// Storage provider type
///
/// ## Purpose
/// Defines the storage provider type using industry-standard naming.
/// Follows Kubernetes-style provider pattern for consistency.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageProvider {
    StorageProviderUnspecified = 0,
    /// Relational database providers
    ///
    /// PostgreSQL
    StorageProviderPostgres = 1,
    /// SQLite (embedded)
    StorageProviderSqlite = 2,
    /// NoSQL providers
    ///
    /// Redis
    StorageProviderRedis = 3,
    /// AWS DynamoDB
    StorageProviderDynamodb = 4,
    /// Message queue providers (for channel)
    ///
    /// Apache Kafka
    StorageProviderKafka = 5,
    /// NATS
    StorageProviderNats = 6,
    /// In-memory (testing/development only)
    ///
    /// In-memory (no persistence)
    StorageProviderMemory = 7,
}
impl StorageProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StorageProvider::StorageProviderUnspecified => "STORAGE_PROVIDER_UNSPECIFIED",
            StorageProvider::StorageProviderPostgres => "STORAGE_PROVIDER_POSTGRES",
            StorageProvider::StorageProviderSqlite => "STORAGE_PROVIDER_SQLITE",
            StorageProvider::StorageProviderRedis => "STORAGE_PROVIDER_REDIS",
            StorageProvider::StorageProviderDynamodb => "STORAGE_PROVIDER_DYNAMODB",
            StorageProvider::StorageProviderKafka => "STORAGE_PROVIDER_KAFKA",
            StorageProvider::StorageProviderNats => "STORAGE_PROVIDER_NATS",
            StorageProvider::StorageProviderMemory => "STORAGE_PROVIDER_MEMORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_PROVIDER_UNSPECIFIED" => Some(Self::StorageProviderUnspecified),
            "STORAGE_PROVIDER_POSTGRES" => Some(Self::StorageProviderPostgres),
            "STORAGE_PROVIDER_SQLITE" => Some(Self::StorageProviderSqlite),
            "STORAGE_PROVIDER_REDIS" => Some(Self::StorageProviderRedis),
            "STORAGE_PROVIDER_DYNAMODB" => Some(Self::StorageProviderDynamodb),
            "STORAGE_PROVIDER_KAFKA" => Some(Self::StorageProviderKafka),
            "STORAGE_PROVIDER_NATS" => Some(Self::StorageProviderNats),
            "STORAGE_PROVIDER_MEMORY" => Some(Self::StorageProviderMemory),
            _ => None,
        }
    }
}
include!("plexspaces.storage.v1.tonic.rs");
// @@protoc_insertion_point(module)