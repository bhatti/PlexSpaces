// @generated
// This file is @generated by prost-build.
// NOTE: Actor IDs are represented as plain strings throughout PlexSpaces.
// Format: "{namespace}/{actor_name}" or "{node_id}/{actor_name}"
// - Simplifies API (no wrapper message needed)
// - Human-readable for debugging
// - Max length 255 chars, no whitespace
// - Case-sensitive, supports full UTF-8

/// Empty message (replacement for plexspaces.common.v1.Empty)
///
/// Used for RPC methods that don't return a meaningful value.
/// We define our own instead of using plexspaces.common.v1.Empty because
/// prost_types doesn't include it.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Empty {
}
/// Standard metadata for resources
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="3")]
    pub created_by: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub updated_by: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="5")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(map="string, message", tag="6")]
    pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Any>,
}
/// Standard error details
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetail {
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="3")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Any>,
}
/// Retry policy configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    #[prost(uint32, tag="1")]
    pub max_attempts: u32,
    #[prost(double, tag="2")]
    pub backoff_multiplier: f64,
    /// >= 1ms
    #[prost(message, optional, tag="3")]
    pub initial_delay: ::core::option::Option<::prost_types::Duration>,
    /// <= 1 hour
    #[prost(message, optional, tag="4")]
    pub max_delay: ::core::option::Option<::prost_types::Duration>,
}
/// Standard pagination request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageRequest {
    #[prost(int32, tag="1")]
    pub page_size: i32,
    #[prost(string, tag="2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub order_by: ::prost::alloc::string::String,
}
/// Standard pagination response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageResponse {
    #[prost(string, tag="1")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub total_size: i32,
}
// ============================================================================
// FACET SYSTEM - Core Extensibility Mechanism
// ============================================================================

/// Facet provides capabilities to actors and other resources
/// Philosophy: Facets augment core functionality without replacing it
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Facet {
    /// Facet type identifier (e.g., "virtual_actor", "otp_genserver", "durable_execution")
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    /// Configuration as key-value pairs (all values are strings for simplicity)
    #[prost(map="string, string", tag="2")]
    pub config: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Priority for facet execution ordering (higher = runs first)
    /// Common ranges:
    ///    1000+: Security/Auth facets
    ///    900-999: Logging/Tracing facets
    ///    800-899: Metrics facets
    ///    100-500: Domain logic facets
    ///    1-99: Persistence facets
    #[prost(int32, tag="3")]
    pub priority: i32,
    /// Facet state (for stateful facets)
    #[prost(map="string, message", tag="4")]
    pub state: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Any>,
    /// Metadata for facet instance
    #[prost(message, optional, tag="5")]
    pub metadata: ::core::option::Option<Metadata>,
}
/// Facet descriptor for registry/discovery
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetDescriptor {
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    /// e.g., "infrastructure", "virtual_actor", "otp", "workflow"
    #[prost(string, tag="3")]
    pub category: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub config_options: ::prost::alloc::vec::Vec<ConfigOption>,
    /// Other facets this depends on
    #[prost(string, repeated, tag="5")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Configuration option for a facet
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigOption {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub default_value: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub required: bool,
    /// "string", "int", "bool", "duration", etc.
    #[prost(string, tag="5")]
    pub value_type: ::prost::alloc::string::String,
}
// ============================================================================
// MULTI-TENANCY AND ISOLATION
// ============================================================================
//
// ## Purpose
// Provides tenant isolation and security boundaries for multi-tenant deployments.
// Enables hosting multiple customers/organizations on shared infrastructure while
// maintaining strict separation of resources, state, and access control.
//
// ## Design Philosophy
// - **Tenant = Customer/Organization**: Each tenant gets isolated environment
// - **Namespace = Sub-environment**: production, staging, dev within a tenant
// - **SecurityPolicy = Per-tenant rules**: What each tenant is allowed to do
// - **ResourceQuota = Per-tenant limits**: Prevent resource exhaustion
//
// ## Enforcement Points
// All PlexSpaces components enforce isolation at these levels:
// 1. **ActorRegistry**: Actors only visible within same IsolationContext
// 2. **Messaging**: Messages cannot cross tenant boundaries (unless explicit policy)
// 3. **TupleSpace**: Tuples isolated per tenant
// 4. **Journal**: Events stored with tenant_id for GDPR compliance
// 5. **Supervision**: Supervisors scoped to tenant
//
// ## Example Use Cases
//
// ### SaaS Multi-Tenancy
// ```protobuf
// IsolationContext {
//    tenant_id: { tenant_id: "customer-acme-corp" }
//    namespace: "production"
//    security_policy: {
//      allow_cross_namespace: false  // Production can't talk to staging
//      allow_tuplespace_read: true
//      allow_tuplespace_write: true
//      allow_remote_calls: true
//      max_message_size_bytes: 1048576  // 1MB max
//    }
//    resource_quota: {
//      max_actors: 10000
//      max_memory_mb: 8192  // 8GB
//      max_cpu_percent: 50.0  // 50% of node CPU
//      max_disk_mb: 10240  // 10GB
//      rate_limit_msg_per_sec: 10000
//    }
// }
// ```
//
// ### Development Environment Isolation
// ```protobuf
// IsolationContext {
//    tenant_id: { tenant_id: "internal-dev" }
//    namespace: "dev-alice"
//    security_policy: {
//      allow_cross_namespace: true  // Dev can talk to other dev environments
//      allow_tuplespace_read: true
//      allow_tuplespace_write: true
//      allow_remote_calls: false  // No external calls from dev
//      max_message_size_bytes: 10485760  // 10MB for testing
//    }
//    resource_quota: {
//      max_actors: 100
//      max_memory_mb: 512
//      max_cpu_percent: 10.0
//      max_disk_mb: 1024
//      rate_limit_msg_per_sec: 100
//    }
// }
// ```

/// Tenant identifier for multi-tenancy isolation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantId {
    /// Unique tenant identifier (e.g., "customer-acme", "org-123", "team-alpha")
    /// Format: lowercase alphanumeric + hyphens, max 64 chars
    /// Example: "customer-acme-corp", "internal-dev", "client-xyz"
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
}
/// Security policy for tenant isolation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicy {
    /// Can actors in this tenant send messages to actors in different namespaces?
    /// Example: production=false (strict isolation), staging=true (allow cross-talk)
    #[prost(bool, tag="1")]
    pub allow_cross_namespace: bool,
    /// Can actors in this tenant read from TupleSpace?
    #[prost(bool, tag="2")]
    pub allow_tuplespace_read: bool,
    /// Can actors in this tenant write to TupleSpace?
    #[prost(bool, tag="3")]
    pub allow_tuplespace_write: bool,
    /// Can actors in this tenant make remote calls to actors on other nodes?
    #[prost(bool, tag="4")]
    pub allow_remote_calls: bool,
    /// Maximum message size this tenant can send (bytes)
    /// Prevents DoS attacks via large messages
    ///
    /// 1KB to 100MB
    #[prost(uint64, tag="5")]
    pub max_message_size_bytes: u64,
    /// Allowed facet types this tenant can use
    /// Empty = all facets allowed, Non-empty = whitelist only
    #[prost(string, repeated, tag="6")]
    pub allowed_facet_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Custom security rules as key-value pairs
    /// Example: {"allow_wasm": "true", "encryption_required": "true"}
    #[prost(map="string, string", tag="7")]
    pub custom_rules: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Per-tenant resource quotas
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceQuota {
    /// Maximum number of actors this tenant can create
    /// 0 = unlimited (use with caution!)
    ///
    /// Max 1 million actors
    #[prost(uint32, tag="1")]
    pub max_actors: u32,
    /// Maximum memory this tenant can consume (MB)
    /// Enforced at actor creation and runtime monitoring
    ///
    /// Max 1TB
    #[prost(uint64, tag="2")]
    pub max_memory_mb: u64,
    /// Maximum CPU percentage this tenant can consume (0-100)
    /// Example: 50.0 = tenant limited to 50% of node CPU
    #[prost(double, tag="3")]
    pub max_cpu_percent: f64,
    /// Maximum disk space for journals/snapshots (MB)
    ///
    /// Max 10TB
    #[prost(uint64, tag="4")]
    pub max_disk_mb: u64,
    /// Maximum message throughput (messages per second)
    /// Enforced via rate limiting at message send
    ///
    /// Max 1M msgs/sec
    #[prost(uint64, tag="5")]
    pub rate_limit_msg_per_sec: u64,
    /// Maximum concurrent operations
    /// Limits concurrent handler executions across all actors
    ///
    /// Max 100K concurrent
    #[prost(uint32, tag="6")]
    pub max_concurrent_operations: u32,
    /// Custom quota limits as key-value pairs
    /// Example: {"max_tuplespace_entries": "10000"}
    #[prost(map="string, string", tag="7")]
    pub custom_quotas: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Complete isolation context for multi-tenancy
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsolationContext {
    /// Tenant identifier (REQUIRED)
    #[prost(message, optional, tag="1")]
    pub tenant_id: ::core::option::Option<TenantId>,
    /// Namespace within tenant (OPTIONAL)
    /// Common values: "production", "staging", "dev", "test"
    /// Format: lowercase alphanumeric + hyphens, max 32 chars
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Security policy for this isolation context
    #[prost(message, optional, tag="3")]
    pub security_policy: ::core::option::Option<SecurityPolicy>,
    /// Resource quota for this isolation context
    #[prost(message, optional, tag="4")]
    pub resource_quota: ::core::option::Option<ResourceQuota>,
    /// Additional metadata (labels, annotations)
    #[prost(message, optional, tag="5")]
    pub metadata: ::core::option::Option<Metadata>,
}
// ============================================================================
// RESOURCE SPECIFICATION
// ============================================================================
//
// ## Purpose
// Resource specification (CPU, memory, disk, GPU) shared by nodes, actors,
// and scheduling components. Enables resource-aware scheduling and capacity
// management.
//
// ## Usage
// - **Nodes**: Total and available capacity
// - **Actors**: Resource requirements for scheduling
// - **Scheduling**: Matching actors to nodes based on resources
//
// ## Design Decisions
// - **CPU as double**: Allows fractional cores (e.g., 0.5 = half core)
// - **Memory/Disk as uint64**: Bytes for precision, supports large values
// - **GPU as separate fields**: Count and type for heterogeneous clusters

/// Resource specification (CPU, memory, disk, GPU)
/// Shared by nodes, actors, and scheduling components
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSpec {
    /// CPU cores (fractional allowed, e.g., 0.5 = half core)
    /// Example: 2.5 = two and a half CPU cores
    #[prost(double, tag="1")]
    pub cpu_cores: f64,
    /// Memory in bytes
    /// Example: 1073741824 = 1GB
    #[prost(uint64, tag="2")]
    pub memory_bytes: u64,
    /// Disk space in bytes
    /// Example: 10737418240 = 10GB
    #[prost(uint64, tag="3")]
    pub disk_bytes: u64,
    /// GPU count (0 = no GPU)
    /// Example: 1 = one GPU
    #[prost(uint32, tag="4")]
    pub gpu_count: u32,
    /// GPU type (e.g., "H100", "A100", "L4", "T4")
    /// Empty string = any GPU type
    #[prost(string, tag="5")]
    pub gpu_type: ::prost::alloc::string::String,
}
/// Request Context (Go-style context.Context)
///
/// ## Purpose
/// Provides request-scoped context similar to Go's context.Context.
/// Carries tenant isolation, tracing, and request metadata through the call chain.
///
/// ## Design Philosophy
/// - **Tenant Isolation**: tenant_id is REQUIRED for all operations
/// - **Tracing**: request_id and correlation_id for distributed tracing
/// - **Extensible**: metadata map for additional context
/// - **Immutable**: Context should be passed by reference, not mutated
///
/// ## Usage Pattern
/// ```rust
/// // Create context from request
/// let ctx = RequestContext::new("tenant-123".to_string())
///      .with_namespace("production".to_string())
///      .with_user_id("user-456".to_string());
///
/// // Pass to repository/service
/// let result = repository.get(&ctx, "resource-id").await?;
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestContext {
    /// Tenant ID (REQUIRED for all operations)
    ///
    /// All operations are scoped to this tenant.
    /// Must be validated at service boundaries.
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace within tenant (optional, defaults to "default")
    ///
    /// Common values: "production", "staging", "dev", "test"
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// User ID (from JWT, optional)
    ///
    /// Extracted from JWT claims for audit logging and authorization.
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    /// Request ID (for tracing)
    ///
    /// Unique identifier for this request (ULID).
    /// Used for request tracing and correlation.
    #[prost(string, tag="4")]
    pub request_id: ::prost::alloc::string::String,
    /// Correlation ID (for distributed tracing)
    ///
    /// Links related requests across services.
    /// Propagated through gRPC metadata.
    #[prost(string, tag="5")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Request timestamp
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Metadata (extensible key-value pairs)
    ///
    /// Additional context for request processing.
    /// Examples: "source_ip", "user_agent", "api_version"
    #[prost(map="string, string", tag="7")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Quality of Service levels
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QoSLevel {
    QosLevelUnspecified = 0,
    QosLevelNone = 1,
    QosLevelBestEffort = 2,
    QosLevelGuaranteed = 3,
}
impl QoSLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            QoSLevel::QosLevelUnspecified => "QOS_LEVEL_UNSPECIFIED",
            QoSLevel::QosLevelNone => "QOS_LEVEL_NONE",
            QoSLevel::QosLevelBestEffort => "QOS_LEVEL_BEST_EFFORT",
            QoSLevel::QosLevelGuaranteed => "QOS_LEVEL_GUARANTEED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QOS_LEVEL_UNSPECIFIED" => Some(Self::QosLevelUnspecified),
            "QOS_LEVEL_NONE" => Some(Self::QosLevelNone),
            "QOS_LEVEL_BEST_EFFORT" => Some(Self::QosLevelBestEffort),
            "QOS_LEVEL_GUARANTEED" => Some(Self::QosLevelGuaranteed),
            _ => None,
        }
    }
}
/// Resource states
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceState {
    ResourceStateUnspecified = 0,
    ResourceStateCreating = 1,
    ResourceStateActive = 2,
    ResourceStateInactive = 3,
    ResourceStateUpdating = 4,
    ResourceStateDeleting = 5,
    ResourceStateFailed = 6,
    ResourceStateUnknown = 7,
}
impl ResourceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceState::ResourceStateUnspecified => "RESOURCE_STATE_UNSPECIFIED",
            ResourceState::ResourceStateCreating => "RESOURCE_STATE_CREATING",
            ResourceState::ResourceStateActive => "RESOURCE_STATE_ACTIVE",
            ResourceState::ResourceStateInactive => "RESOURCE_STATE_INACTIVE",
            ResourceState::ResourceStateUpdating => "RESOURCE_STATE_UPDATING",
            ResourceState::ResourceStateDeleting => "RESOURCE_STATE_DELETING",
            ResourceState::ResourceStateFailed => "RESOURCE_STATE_FAILED",
            ResourceState::ResourceStateUnknown => "RESOURCE_STATE_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_STATE_UNSPECIFIED" => Some(Self::ResourceStateUnspecified),
            "RESOURCE_STATE_CREATING" => Some(Self::ResourceStateCreating),
            "RESOURCE_STATE_ACTIVE" => Some(Self::ResourceStateActive),
            "RESOURCE_STATE_INACTIVE" => Some(Self::ResourceStateInactive),
            "RESOURCE_STATE_UPDATING" => Some(Self::ResourceStateUpdating),
            "RESOURCE_STATE_DELETING" => Some(Self::ResourceStateDeleting),
            "RESOURCE_STATE_FAILED" => Some(Self::ResourceStateFailed),
            "RESOURCE_STATE_UNKNOWN" => Some(Self::ResourceStateUnknown),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
