// @generated
// This file is @generated by prost-build.
/// Actor message for inter-actor communication.
///
/// ## Purpose
/// Represents a single message sent from one actor to another with metadata
/// for routing, priority, correlation, and time-to-live.
///
/// ## Why This Exists
/// - Enables asynchronous actor communication (fundamental to actor model)
/// - Supports message priority for control vs data plane separation (Quickwit-inspired)
/// - Provides correlation IDs for request-reply patterns (Erlang gen_server:call)
/// - TTL prevents message accumulation in failure scenarios
/// - Headers enable extensibility (tracing, auth, custom routing)
///
/// ## Design Notes
/// - sender_id is optional to support anonymous sends
/// - priority maps to 5-level system: Signal(100), System(75), High(50), Normal(25), Low(0)
/// - payload is opaque bytes, decoded by receiving actor's behavior
/// - headers provide extensibility without proto changes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Optional, but bounded
    #[prost(string, tag="2")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub message_type: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="5")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// 5-level system: 0=Low, 25=Normal, 50=High, 75=System, 100=Signal
    #[prost(int32, tag="7")]
    pub priority: i32,
    /// Max 24 hours
    #[prost(message, optional, tag="8")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
    #[prost(map="string, string", tag="9")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Optional idempotency key for message deduplication
    ///
    /// ## Purpose
    /// Prevents accidental double-processing of messages within a time window (e.g., 24 hours).
    /// If a message with the same idempotency_key is processed within the window, it's skipped.
    ///
    /// ## Usage
    /// - Client generates unique idempotency key (e.g., UUID, request ID)
    /// - System tracks processed keys in journal
    /// - Duplicate messages within time window return cached response (if available)
    /// - Fits durable execution model (Restate-inspired)
    ///
    /// ## Example
    /// ```protobuf
    /// Message {
    ///    id: "msg-123"
    ///    idempotency_key: "payment-request-abc-xyz"
    ///    receiver_id: "payment-processor"
    ///    payload: \[payment data\]
    /// }
    /// // If same idempotency_key processed within 24h, returns cached response
    /// ```
    #[prost(string, tag="10")]
    pub idempotency_key: ::prost::alloc::string::String,
    /// URI path for HTTP-based invocations (optional)
    /// Example: "/api/v1/actors/default/counter/metrics"
    /// Populated when message originates from HTTP InvokeActor RPC
    #[prost(string, tag="11")]
    pub uri_path: ::prost::alloc::string::String,
    /// HTTP method for HTTP-based invocations (optional)
    /// Example: "GET", "POST", "PUT", "DELETE"
    /// Populated when message originates from HTTP InvokeActor RPC
    #[prost(string, tag="12")]
    pub uri_method: ::prost::alloc::string::String,
}
/// Actor instance representation.
///
/// ## Purpose
/// Defines the complete state of a durable actor instance including its
/// identity, lifecycle state, configuration, resource usage, and attached capabilities.
///
/// ## Why This Exists
/// - Actors are the fundamental unit of computation in PlexSpaces (Pillar 2: Erlang/OTP)
/// - Supports durable actors that survive restarts (Pillar 3: Restate durability)
/// - Enables resource-aware scheduling (Quickwit-inspired resource contracts)
/// - Provides facet extensibility (Static vs Dynamic principle)
/// - Tracks metrics for monitoring and health checks
///
/// ## Design Notes
/// - actor_id uses ActorId from common.proto for consistency across services
/// - state tracks lifecycle for supervision and recovery logic
/// - node_id and vm_id support distributed placement and Firecracker isolation
/// - facets enable dynamic capability composition without changing core proto
/// - metrics enable health monitoring and auto-scaling decisions
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Actor {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(enumeration="ActorState", tag="3")]
    pub state: i32,
    #[prost(string, tag="4")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="6")]
    pub actor_state: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="7")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    #[prost(message, optional, tag="8")]
    pub config: ::core::option::Option<ActorConfig>,
    #[prost(message, optional, tag="9")]
    pub metrics: ::core::option::Option<ActorMetrics>,
    /// FACET EXTENSIBILITY: Attached facets provide additional capabilities
    /// Examples: virtual_actor, otp_genserver, otp_supervisor, durable_execution, workflow
    #[prost(message, repeated, tag="10")]
    pub facets: ::prost::alloc::vec::Vec<super::super::common::v1::Facet>,
    /// MULTI-TENANCY: Isolation context for tenant separation and security
    /// Enables hosting multiple customers/organizations on shared infrastructure
    /// while maintaining strict resource and security boundaries
    #[prost(message, optional, tag="11")]
    pub isolation: ::core::option::Option<super::super::common::v1::IsolationContext>,
    /// Schema version of actor_state serialization for format evolution
    ///
    /// ## Purpose
    /// Enables safe actor state evolution across deployments and restarts.
    /// Actors may be inactive for extended periods (days/weeks/months) and must
    /// safely load old state when reactivated with newer actor code.
    ///
    /// ## Why This Exists
    /// - Actor state schemas evolve over time (new fields, removed fields, type changes)
    /// - Actors persist state to disk via checkpoints (see journaling.proto)
    /// - Actors may migrate between nodes with different code versions
    /// - Loading incompatible state causes corruption or panics
    /// - Prevents data loss during rolling upgrades
    ///
    /// ## Version Rules
    /// - **Version 0** = unversioned (legacy actors, assume version 1, best-effort deserialization)
    /// - **Version >= 1** = explicit schema version tracked with actor state
    /// - **Same version** (e.g., both v2) → Load directly, no migration needed
    /// - **Older version** (state v1, actor v2) → Attempt migration if migration exists, else reject
    /// - **Newer version** (state v3, actor v2) → **REJECT** with error (upgrade actor code first)
    ///
    /// ## Migration Strategy
    /// ```
    /// Version 1 → 2: Add new field with default value (backward compatible, no migration)
    /// Version 2 → 3: Remove deprecated field (backward compatible, no migration)
    /// Version 3 → 4: Change field type (BREAKING - requires explicit migration function)
    /// Version 4 → 5: Restructure nested fields (BREAKING - requires migration)
    /// ```
    ///
    /// ## Example Usage
    /// ```rust
    /// // Actor implementation defines current schema version
    /// impl CounterActor {
    ///      const SCHEMA_VERSION: u32 = 2;
    ///
    ///      fn save_state(&self) -> Result<Actor, PersistenceError> {
    ///          Ok(Actor {
    ///              actor_id: self.id.clone(),
    ///              actor_state: serialize(&self.internal_state)?,
    ///              actor_state_schema_version: Self::SCHEMA_VERSION,
    ///              // ... other fields ...
    ///          })
    ///      }
    ///
    ///      fn load_state(actor: &Actor) -> Result<Self, PersistenceError> {
    ///          // Version compatibility check
    ///          match actor.actor_state_schema_version {
    ///              // Same version - direct load
    ///              v if v == Self::SCHEMA_VERSION => {
    ///                  let state: CounterState = deserialize(&actor.actor_state)?;
    ///                  Ok(Self::from_state(state))
    ///              }
    ///
    ///              // Older version - migrate forward
    ///              v if v < Self::SCHEMA_VERSION => {
    ///                  let migrated = migrate_counter_state(
    ///                      &actor.actor_state,
    ///                      v,
    ///                      Self::SCHEMA_VERSION,
    ///                  )?;
    ///                  let state: CounterState = deserialize(&migrated)?;
    ///                  Ok(Self::from_state(state))
    ///              }
    ///
    ///              // Newer version - reject (cannot load future state)
    ///              v => Err(PersistenceError::IncompatibleSchemaVersion {
    ///                  actor_version: Self::SCHEMA_VERSION,
    ///                  state_version: v,
    ///                  message: format!(
    ///                      "Actor state v{} is newer than actor code v{}. Upgrade actor first.",
    ///                      v, Self::SCHEMA_VERSION
    ///                  ),
    ///              }),
    ///          }
    ///      }
    /// }
    /// ```
    ///
    /// ## Integration with Checkpointing
    /// This field works in conjunction with `Checkpoint.state_schema_version` from journaling.proto:
    /// - **Actor.actor_state_schema_version**: Version of in-memory actor state (current)
    /// - **Checkpoint.state_schema_version**: Version of checkpointed actor state (persistent)
    ///
    /// When creating checkpoint:
    /// ```rust
    /// let checkpoint = Checkpoint {
    ///      actor_id: actor.actor_id.clone(),
    ///      state_data: actor.actor_state.clone(),
    ///      state_schema_version: actor.actor_state_schema_version,  // Copy version
    ///      // ...
    /// };
    /// ```
    ///
    /// ## See Also
    /// - `proto/plexspaces/v1/journaling.proto` - Checkpoint.state_schema_version (lines 241-321)
    /// - `docs/SCHEMA_VERSIONING_REVIEW.md` - Complete versioning strategy
    /// - Migration registry pattern for centralized v1→v2→v3 transitions
    #[prost(uint32, tag="12")]
    pub actor_state_schema_version: u32,
    /// Error message when actor is in FAILED state
    ///
    /// ## Purpose
    /// Provides error details when actor.state == ACTOR_STATE_FAILED.
    /// Used for debugging, logging, and supervisor restart decisions.
    ///
    /// ## Usage
    /// - Only populated when state == ACTOR_STATE_FAILED
    /// - Empty string when state != ACTOR_STATE_FAILED
    /// - Contains error message from actor crash or failure
    #[prost(string, tag="13")]
    pub error_message: ::prost::alloc::string::String,
}
/// Actor configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorConfig {
    /// Max 1 hour timeout
    #[prost(message, optional, tag="1")]
    pub mailbox_timeout: ::core::option::Option<::prost_types::Duration>,
    /// 1 to 1M messages
    #[prost(uint32, tag="2")]
    pub max_mailbox_size: u32,
    #[prost(bool, tag="3")]
    pub enable_persistence: bool,
    /// 1 second to 24 hours
    #[prost(message, optional, tag="4")]
    pub checkpoint_interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag="5")]
    pub restart_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    #[prost(enumeration="SupervisionStrategy", tag="6")]
    pub supervision_strategy: i32,
    #[prost(map="string, message", tag="7")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, ::prost_types::Any>,
    /// Orleans-inspired placement configuration
    #[prost(message, optional, tag="10")]
    pub placement_hint: ::core::option::Option<PlacementHint>,
    /// Orleans-inspired stateless worker configuration
    #[prost(message, optional, tag="11")]
    pub stateless_worker_config: ::core::option::Option<StatelessWorkerConfig>,
    /// Data-parallel actor configuration (if part of actor group)
    #[prost(message, optional, tag="12")]
    pub data_parallel_config: ::core::option::Option<DataParallelConfig>,
    /// State management mode (traditional vs lattice-based)
    #[prost(enumeration="StateMgmtMode", tag="13")]
    pub state_management_mode: i32,
    /// Consistency level for lattice-based actors
    #[prost(enumeration="ConsistencyLevel", tag="14")]
    pub consistency_level: i32,
    /// Resource-aware scheduling: Actor resource requirements
    #[prost(message, optional, tag="16")]
    pub resource_requirements: ::core::option::Option<ActorResourceRequirements>,
    /// Actor groups (for task routing and co-scheduling)
    #[prost(string, repeated, tag="17")]
    pub actor_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    // NOTE: Actors are ALWAYS isolated (Erlang/OTP principle)
    //
    // ## Design Decision: No Execution Isolation Modes
    // Unlike Swift (which has both classes and actors), PlexSpaces follows the pure
    // actor model (Erlang/OTP) where:
    // - ✅ Actors are ALWAYS isolated (single-threaded message processing)
    // - ✅ Communication is ALWAYS via message passing (mailbox)
    // - ✅ No shared mutable state between actors
    // - ❌ No "nonisolated" mode - isolation is inherent to actors
    //
    // Swift needed isolated/nonisolated because it has classes (shared state).
    // We don't have that problem - actors ARE the isolation boundary.
    //
    // For concurrent read-only operations, use:
    // - StatelessWorkerConfig (Orleans-inspired worker pools)
    // - DataParallelConfig (CRDT-based coordination-free parallelism)
    //
    // See PROTO_FIRST_AUDIT.md for why execution modes were removed.

    /// Schema version of properties map for configuration evolution
    ///
    /// ## Purpose
    /// Enables safe evolution of actor configuration across deployments.
    /// The `properties` map (field 7) contains opaque configuration that may
    /// change as actor types evolve, requiring versioning for compatibility.
    ///
    /// ## Why This Exists
    /// - Actor configuration schemas evolve (new config options, deprecated settings)
    /// - Actors may be created with old config and reactivated with new code
    /// - Configuration migration needed during rolling upgrades
    /// - Prevents invalid configuration causing actor startup failures
    ///
    /// ## Version Rules
    /// - **Version 0** = unversioned (legacy config, assume version 1)
    /// - **Version >= 1** = explicit config schema version
    /// - **Same version** → Use config directly
    /// - **Older version** → Migrate config forward (e.g., add new defaults, remove deprecated)
    /// - **Newer version** → REJECT (upgrade actor code first)
    ///
    /// ## Example Migration
    /// ```rust
    /// // Version 1: Simple timeout config
    /// properties: {"timeout_ms": 5000}
    ///
    /// // Version 2: Added retry config (backward compatible)
    /// properties: {
    ///      "timeout_ms": 5000,
    ///      "max_retries": 3,      // NEW: defaults to 3
    ///      "retry_backoff_ms": 100 // NEW: defaults to 100ms
    /// }
    ///
    /// // Migration v1→v2: Add defaults for new fields
    /// fn migrate_config_v1_to_v2(config: &mut ActorConfig) {
    ///      config.properties.entry("max_retries").or_insert(Any::from(3u32));
    ///      config.properties.entry("retry_backoff_ms").or_insert(Any::from(100u32));
    ///      config.config_schema_version = 2;
    /// }
    /// ```
    ///
    /// ## See Also
    /// - `Actor.actor_state_schema_version` - For actor state versioning
    /// - `docs/SCHEMA_VERSIONING_REVIEW.md` - Complete versioning strategy
    #[prost(uint32, tag="15")]
    pub config_schema_version: u32,
}
/// Resource requirements for placement
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRequirements {
    /// Max 1TB
    #[prost(uint64, tag="1")]
    pub min_memory_mb: u64,
    /// 0.1 to 128 cores
    #[prost(double, tag="2")]
    pub min_cpu_cores: f64,
    #[prost(string, repeated, tag="3")]
    pub required_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, string", tag="4")]
    pub custom_requirements: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Placement hint for actor activation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlacementHint {
    #[prost(enumeration="PlacementStrategy", tag="1")]
    pub strategy: i32,
    #[prost(string, tag="2")]
    pub preferred_node_id: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub affinity_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub requirements: ::core::option::Option<ResourceRequirements>,
}
/// Actor resource requirements for resource-aware scheduling
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorResourceRequirements {
    /// Required resources (CPU, memory, disk, GPU)
    #[prost(message, optional, tag="1")]
    pub resources: ::core::option::Option<super::super::common::v1::ResourceSpec>,
    /// Required node labels (Kubernetes-inspired label selector)
    /// All labels must match for node to be eligible
    #[prost(map="string, string", tag="2")]
    pub required_labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Placement preferences
    #[prost(message, optional, tag="3")]
    pub placement: ::core::option::Option<PlacementPreferences>,
    /// Actor groups (for task routing and co-scheduling)
    #[prost(string, repeated, tag="4")]
    pub actor_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Placement preferences for resource-aware scheduling
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlacementPreferences {
    /// Placement strategy
    #[prost(enumeration="PlacementStrategy", tag="1")]
    pub strategy: i32,
    /// Preferred node IDs (hint, not requirement)
    #[prost(string, repeated, tag="2")]
    pub preferred_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Avoid node IDs (anti-affinity)
    #[prost(string, repeated, tag="3")]
    pub avoid_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Stateless worker configuration (Orleans-inspired)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatelessWorkerConfig {
    /// Maximum number of concurrent instances
    #[prost(uint32, tag="1")]
    pub max_instances: u32,
    /// Minimum number of instances to keep warm
    #[prost(uint32, tag="2")]
    pub min_instances: u32,
    /// Load balancing strategy
    #[prost(enumeration="LoadBalancingStrategy", tag="3")]
    pub strategy: i32,
}
/// Data-parallel actor configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataParallelConfig {
    /// Actor group ID this actor belongs to
    #[prost(string, tag="1")]
    pub group_id: ::prost::alloc::string::String,
    /// Total number of shards in the group
    #[prost(uint32, tag="2")]
    pub shard_count: u32,
    /// This actor's shard ID (0 to shard_count-1)
    #[prost(uint32, tag="3")]
    pub shard_id: u32,
    /// Partitioning strategy
    #[prost(enumeration="PartitionStrategy", tag="4")]
    pub partition_strategy: i32,
    /// Rebalancing policy
    #[prost(enumeration="RebalancePolicy", tag="5")]
    pub rebalance_policy: i32,
}
/// Actor performance metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorMetrics {
    #[prost(uint64, tag="1")]
    pub messages_processed: u64,
    #[prost(uint64, tag="2")]
    pub messages_failed: u64,
    /// Max 1 hour per message
    #[prost(message, optional, tag="3")]
    pub average_processing_time: ::core::option::Option<::prost_types::Duration>,
    #[prost(uint64, tag="4")]
    pub restarts: u64,
    #[prost(message, optional, tag="5")]
    pub last_activity: ::core::option::Option<::prost_types::Timestamp>,
    /// Max 1TB
    #[prost(uint64, tag="6")]
    pub memory_usage_bytes: u64,
    #[prost(double, tag="7")]
    pub cpu_usage_percent: f64,
}
/// Request to create an actor
///
/// ## Design Principle
/// CreateActor ALWAYS creates actors locally on the node where the gRPC call is made.
/// There is no node_id field - the actor is always created on the node receiving the request.
///
/// To spawn an actor on a remote node:
/// 1. Call CreateActor on that remote node's ActorService directly, OR
/// 2. Use SpawnActor RPC (which also must be called on the target node)
///
/// ## Example
/// ```rust
/// // Create actor locally on node1
/// let client1 = ActorServiceClient::connect("<http://node1:9001">).await?;
/// let response = client1.create_actor(CreateActorRequest { actor_type: "worker", ... }).await?;
/// // Actor is created on node1
///
/// // Create actor on remote node2
/// let client2 = ActorServiceClient::connect("<http://node2:9002">).await?;
/// let response = client2.create_actor(CreateActorRequest { actor_type: "worker", ... }).await?;
/// // Actor is created on node2
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateActorRequest {
    #[prost(string, tag="1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="3")]
    pub initial_state: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="4")]
    pub config: ::core::option::Option<ActorConfig>,
    #[prost(map="string, string", tag="5")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateActorResponse {
    #[prost(message, optional, tag="1")]
    pub actor: ::core::option::Option<Actor>,
}
/// Request to spawn an actor on a specific remote node (Erlang spawn/4 equivalent)
///
/// ## Purpose
/// Spawns an actor on a specified remote node using pre-deployed actor type.
/// Returns an ActorRef for location-transparent messaging.
///
/// ## Erlang Philosophy
/// In Erlang:
/// ```erlang
/// % Local spawn (current node)
/// Pid = spawn(Module, Function, Args)
///
/// % Remote spawn (specific node)
/// Pid = spawn(Node, Module, Function, Args)
/// ```
/// - Node: Target node (atom, e.g., 'worker@host1')
/// - Module: Pre-compiled module on remote node (e.g., 'gen_server')
/// - Function: Exported function to run (e.g., 'start_link')
/// - Args: Arguments to function (e.g., \[initial_state\])
/// - Returns: Pid that works for local and remote sends (location transparent)
///
/// ## PlexSpaces Approach
/// ```rust
/// // Local spawn (current node)
/// let actor = node.spawn_actor("worker", state, config).await?;
///
/// // Remote spawn (specific node)
/// let actor_ref = node.spawn_remote("node2", "worker", state, config).await?;
/// ```
/// - target_node_id: Target node (string, e.g., "node2")
/// - actor_type: Pre-deployed actor type on remote node (string, e.g., "worker")
/// - initial_state: Serialized initial state (bytes)
/// - config: Actor configuration
/// - Returns: ActorRef in format "actor_id@node_id" for location-transparent messaging
///
/// ## Key Assumptions (Erlang-Compatible)
/// 1. **Code Pre-Deployed**: The actor_type must already exist on the target node
///     - Like Erlang: Module must be loaded on remote node
///     - Use CreateActor first to deploy actor type, or ensure it's in node's registry
/// 2. **Location Transparency**: Returned ActorRef works the same for local and remote sends
///     - Like Erlang: Pid works for both local send (Pid ! Msg) and remote send
///     - ActorRef.tell() / ActorRef.ask() automatically routes to correct node
///
/// ## Extensibility for WASM (Future - Week 11-12)
/// Phase 6 will add dynamic WASM deployment support via reserved fields:
/// ```protobuf
/// oneof code_source {
///    string actor_type = 2;        // Pre-deployed type (current)
///    WasmModule wasm_module = 10;  // Deploy WASM on-the-fly (future)
///    string wasm_url = 11;         // Fetch WASM from URL (future)
/// }
/// ```
/// This enables:
/// - **Pre-deployed**: spawn_remote("node2", "worker", ...) - code already on node2
/// - **Dynamic WASM**: spawn_remote_wasm("node2", wasm_bytes, ...) - deploy code + spawn
/// - **URL-based**: spawn_remote_url("node2", "<https://cdn/worker.wasm",> ...) - fetch + deploy + spawn
///
/// ## Use Cases
/// 1. **Distributed Testing**: Spawn Byzantine generals on specific nodes
///     ```rust
///     for (i, node) in nodes.iter().enumerate() {
///         node.spawn_remote(&node.id, "general", state, config).await?;
///     }
///     ```
/// 2. **Load Distribution**: Explicitly place workers across cluster
///     ```rust
///     let worker_node = pick_least_loaded_node();
///     worker_node.spawn_remote(&worker_node.id, "worker", state, config).await?;
///     ```
/// 3. **Data Locality**: Spawn actor near data source
///     ```rust
///     let db_node = find_node_with_shard(shard_id);
///     db_node.spawn_remote(&db_node.id, "processor", state, config).await?;
///     ```
/// 4. **Affinity**: Co-locate related actors on same node
///     ```rust
///     let parent_node = get_actor_node(&parent_id);
///     parent_node.spawn_remote(&parent_node.id, "child", state, config).await?;
///     ```
///
/// ## Comparison to CreateActor
/// | Feature | CreateActor | SpawnActor |
/// |---------|-------------|------------------|
/// | Node selection | Placement strategy / current node | Explicit target node |
/// | Use case | General actor creation | Explicit remote placement |
/// | Fallback | Can fall back to other nodes | Fails if target unavailable |
/// | Erlang equivalent | spawn/3 (local) | spawn/4 (remote) |
/// | Code deployment | Any node can have code | Target node must have code |
///
/// ## Implementation Flow
/// When node1 calls SpawnRemoteActor targeting node2:
/// 1. node1 validates target_node_id exists in registry
/// 2. node1 sends gRPC SpawnRemoteActor request to node2
/// 3. node2 validates actor_type exists in local registry
/// 4. node2 spawns actor locally: Actor::spawn(actor_type, state, config)
/// 5. node2 returns ActorRef with format "actor-123@node2"
/// 6. node1 caches remote ActorRef for future messaging
/// 7. Subsequent tell/ask automatically routes via gRPC to node2
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpawnActorRequest {
    /// Pre-deployed actor type name (REQUIRED)
    /// Must exist in target node's actor registry
    /// Examples: "worker", "general", "counter", "session"
    ///
    /// Future (Week 11-12): Will become part of `oneof code_source` to support WASM:
    /// - actor_type: Use pre-deployed type (current)
    /// - wasm_module: Deploy WASM bytecode on-the-fly
    /// - wasm_url: Fetch WASM from URL
    #[prost(string, tag="1")]
    pub actor_type: ::prost::alloc::string::String,
    /// Optional: Client-specified actor ID (for virtual actors)
    /// If provided: Use this ID (must be unique, format: "{actor_type}/{key}" or "{actor_type}@{key}")
    /// If not provided: Server generates ULID
    /// Examples: "user/123", "session/abc-xyz", "counter@node1"
    /// Industry standard: Client-specified IDs for virtual actors (Orleans pattern)
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Optional serialized initial state for actor
    /// Format depends on actor type (actor deserializes)
    #[prost(bytes="vec", tag="3")]
    pub initial_state: ::prost::alloc::vec::Vec<u8>,
    /// Optional actor configuration
    /// If not provided, target node uses default config for actor_type
    #[prost(message, optional, tag="4")]
    pub config: ::core::option::Option<ActorConfig>,
    /// Optional labels for tagging and filtering
    /// Examples: {"env": "prod", "team": "platform", "version": "v2"}
    #[prost(map="string, string", tag="5")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Response from SpawnActor
///
/// ## Purpose
/// Returns reference to newly spawned actor on the node receiving the request.
///
/// ## Design Notes
/// - actor_ref: String in format "actor_id@target_node_id"
///    - Can be used immediately for tell/ask operations
///    - Location transparent - same API as local actors
///    - Example: "actor-abc123@node2"
/// - actor: Full Actor details for inspection
///    - Contains state, config, metrics, etc.
///    - Useful for monitoring and debugging
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpawnActorResponse {
    /// Reference to spawned actor (format: "actor_id@node_id")
    /// Example: "general-1@node2", "worker-abc@prod-7"
    /// Use this for messaging: actor_ref.tell(msg), actor_ref.ask(msg)
    #[prost(string, tag="1")]
    pub actor_ref: ::prost::alloc::string::String,
    /// Full actor details (state, config, metrics)
    /// Useful for inspection and monitoring
    #[prost(message, optional, tag="2")]
    pub actor: ::core::option::Option<Actor>,
}
/// Request to get an actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorResponse {
    #[prost(message, optional, tag="1")]
    pub actor: ::core::option::Option<Actor>,
}
/// Request to list actors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActorsRequest {
    #[prost(message, optional, tag="1")]
    pub page_request: ::core::option::Option<super::super::common::v1::PageRequest>,
    #[prost(string, tag="2")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(enumeration="ActorState", tag="3")]
    pub state: i32,
    #[prost(string, tag="4")]
    pub node_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActorsResponse {
    #[prost(message, repeated, tag="1")]
    pub actors: ::prost::alloc::vec::Vec<Actor>,
    #[prost(message, optional, tag="2")]
    pub page_response: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// Request to send a message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageRequest {
    #[prost(message, optional, tag="1")]
    pub message: ::core::option::Option<Message>,
    #[prost(bool, tag="2")]
    pub wait_for_response: bool,
    /// Max 1 hour timeout
    #[prost(message, optional, tag="3")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageResponse {
    #[prost(string, tag="1")]
    pub message_id: ::prost::alloc::string::String,
    /// Only if wait_for_response = true
    #[prost(message, optional, tag="2")]
    pub response: ::core::option::Option<Message>,
}
/// Request for streaming messages (high-throughput)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamMessageRequest {
    #[prost(message, optional, tag="1")]
    pub message: ::core::option::Option<Message>,
    /// Sequence number for ordering (client-generated)
    #[prost(uint64, tag="2")]
    pub sequence: u64,
}
/// Response for streaming messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamMessageResponse {
    #[prost(string, tag="1")]
    pub message_id: ::prost::alloc::string::String,
    /// Acknowledgement of sequence number
    #[prost(uint64, tag="2")]
    pub sequence: u64,
    /// Status: "delivered", "failed", "queued"
    #[prost(string, tag="3")]
    pub status: ::prost::alloc::string::String,
    /// Optional error message
    #[prost(string, tag="4")]
    pub error: ::prost::alloc::string::String,
}
/// Request to activate/deactivate actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActorStateRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(enumeration="ActorState", tag="2")]
    pub target_state: i32,
    #[prost(bool, tag="3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActorStateResponse {
    #[prost(message, optional, tag="1")]
    pub actor: ::core::option::Option<Actor>,
}
/// Request to migrate actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub target_node_id: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub preserve_state: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateActorResponse {
    #[prost(message, optional, tag="1")]
    pub actor: ::core::option::Option<Actor>,
}
/// Request to delete actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub force: bool,
}
// NOTE: Facet management (AttachFacet, DetachFacet, etc.) is handled by
// FacetService in facets.proto to avoid duplication.

// ============================================================================
// Actor Lifecycle Events
// ============================================================================

/// Actor lifecycle event
///
/// ## Purpose
/// Represents a state transition in an actor's lifecycle. Used for monitoring,
/// observability, and triggering supervision actions.
///
/// ## Architecture Context
/// - Emitted by Actor implementation when state changes occur
/// - Consumed by Node for monitoring callbacks
/// - Consumed by observability systems (metrics, tracing, logging)
/// - Enables location-transparent monitoring (Erlang-style)
///
/// ## Design Decisions
/// - Proto-based for distributed type safety across nodes
/// - event_type as oneof for type-safe event variants
/// - Timestamp for event ordering and time-travel debugging
/// - Extensible for future event types without breaking changes
///
/// ## Usage
/// ```rust
/// // Actor emits event
/// let event = ActorLifecycleEvent {
///      actor_id: "worker@node1".to_string(),
///      timestamp: Some(Timestamp::now()),
///      event_type: Some(actor_lifecycle_event::EventType::Terminated(
///          ActorTerminated { reason: "normal".to_string() }
///      )),
/// };
/// node.handle_lifecycle_event(event).await?;
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorLifecycleEvent {
    /// Actor that emitted this event
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// When event occurred
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Event-specific data (oneof ensures type safety)
    #[prost(oneof="actor_lifecycle_event::EventType", tags="10, 11, 12, 13, 14, 15, 16, 17")]
    pub event_type: ::core::option::Option<actor_lifecycle_event::EventType>,
}
/// Nested message and enum types in `ActorLifecycleEvent`.
pub mod actor_lifecycle_event {
    /// Event-specific data (oneof ensures type safety)
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        #[prost(message, tag="10")]
        Created(super::ActorCreated),
        #[prost(message, tag="11")]
        Starting(super::ActorStarting),
        #[prost(message, tag="12")]
        Activated(super::ActorActivated),
        #[prost(message, tag="13")]
        Deactivating(super::ActorDeactivating),
        #[prost(message, tag="14")]
        Deactivated(super::ActorDeactivated),
        #[prost(message, tag="15")]
        Terminated(super::ActorTerminated),
        #[prost(message, tag="16")]
        Failed(super::ActorFailed),
        #[prost(message, tag="17")]
        Migrating(super::ActorMigrating),
    }
}
/// Actor created (construction complete, not yet started)
///
/// ## Purpose
/// Emitted after Actor::new() completes successfully.
///
/// ## State Transition
/// \[none\] -> Created
///
/// ## Supervisor Action
/// None (waiting for activation)
///
/// Reserved for future metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorCreated {
}
/// Actor starting (spawning message processing task)
///
/// ## Purpose
/// Emitted when Actor::start() is called, before tokio::spawn().
///
/// ## State Transition
/// Created -> Starting
///
/// ## Supervisor Action
/// None (normal startup)
///
/// Reserved for future metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorStarting {
}
/// Actor activated (ready to process messages)
///
/// ## Purpose
/// Emitted after actor's message loop starts and on_activate() hook completes.
///
/// ## State Transition
/// Starting -> Activated
///
/// ## Supervisor Action
/// None (actor running normally)
///
/// Reserved for future metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorActivated {
}
/// Actor deactivating (graceful shutdown initiated)
///
/// ## Purpose
/// Emitted when actor receives shutdown signal or supervisor requests stop.
///
/// ## State Transition
/// Activated -> Deactivating
///
/// ## Supervisor Action
/// None (expected shutdown)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorDeactivating {
    /// Why deactivation was initiated
    /// Examples: "supervisor_shutdown", "manual_stop", "timeout_idle"
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
}
/// Actor deactivated (shutdown complete, but not destroyed)
///
/// ## Purpose
/// Emitted after on_deactivate() hook completes. Actor can be reactivated.
///
/// ## State Transition
/// Deactivating -> Deactivated
///
/// ## Supervisor Action
/// None (actor cleanly stopped, can be restarted if needed)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorDeactivated {
    /// Why deactivation occurred
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
}
/// Actor terminated (permanently stopped, not restartable)
///
/// ## Purpose
/// Emitted when actor's task completes normally (loop exits without error).
/// Triggers monitoring callbacks (NotifyActorDown).
///
/// ## State Transition
/// Activated|Deactivating -> Terminated
///
/// ## Supervisor Action
/// - If restart strategy allows, restart actor
/// - Notify all monitors (local + remote via NotifyActorDown RPC)
///
/// ## Design Notes
/// - reason="normal": Graceful shutdown completed
/// - reason="shutdown": Supervisor-initiated shutdown
/// - reason="killed": Forcefully terminated
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorTerminated {
    /// Termination reason
    /// "normal": Graceful shutdown
    /// "shutdown": Supervisor-initiated
    /// "killed": Forcefully terminated
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
}
/// Actor failed (crashed, needs supervision action)
///
/// ## Purpose
/// Emitted when actor's task panics or returns error. Triggers supervision
/// restart logic and monitoring callbacks.
///
/// ## State Transition
/// Activated -> Failed
///
/// ## Supervisor Action
/// - Apply restart strategy (OneForOne, OneForAll, RestForOne)
/// - Notify all monitors with error details
/// - Increment failure counter for escalation
///
/// ## Design Notes
/// - error: Full panic/error message for debugging
/// - Supervision tree decides whether to restart based on restart strategy
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorFailed {
    /// Error/panic message
    /// Examples:
    /// - "panic: index out of bounds"
    /// - "error: timeout waiting for response"
    /// - "error: connection refused"
    #[prost(string, tag="1")]
    pub error: ::prost::alloc::string::String,
    /// Optional: Stack trace for debugging
    #[prost(string, tag="2")]
    pub stack_trace: ::prost::alloc::string::String,
}
/// Actor migrating (moving to different node)
///
/// ## Purpose
/// Emitted when mobile agent starts migration to another node.
///
/// ## State Transition
/// Activated -> Migrating
///
/// ## Supervisor Action
/// - Update actor location in registry
/// - If migration fails, restart on original node
///
/// ## Design Notes
/// - target_node: Destination node address (e.g., "node2")
/// - Future: Add migration_id for tracking migration progress
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorMigrating {
    /// Target node where actor is migrating
    #[prost(string, tag="1")]
    pub target_node: ::prost::alloc::string::String,
}
// ============================================================================
// Actor Monitoring (Erlang-style)
// ============================================================================

/// Request to monitor an actor (Erlang-style)
///
/// ## Purpose
/// Establishes a monitoring link from supervisor to actor. When actor terminates,
/// the node hosting the actor will call NotifyActorDown on the supervisor_callback.
///
/// ## Erlang Philosophy
/// Equivalent to: Ref = erlang:monitor(process, Pid)
/// Works the same for local and remote processes (location transparent).
///
/// ## Design Notes
/// - actor_id: The actor to monitor (can be "actor@node" for remote)
/// - supervisor_id: The supervisor that wants notifications (for logging/debugging)
/// - supervisor_callback: gRPC address where to send NotifyActorDown
///    (e.g., "<http://supervisor-node:9001">)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitorActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub supervisor_callback: ::prost::alloc::string::String,
}
/// Response to MonitorActor request
///
/// ## Purpose
/// Returns a monitor reference that can be used to demonitor in future.
///
/// ## Erlang Philosophy
/// Equivalent to the Ref returned by erlang:monitor(process, Pid).
///
/// ## Design Notes
/// - monitor_ref: Unique ID for this monitoring link (ULID)
/// - Can be used for future demonitor() operation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitorActorResponse {
    #[prost(string, tag="1")]
    pub monitor_ref: ::prost::alloc::string::String,
}
/// Notification that a monitored actor has terminated
///
/// ## Purpose
/// Sent by the node hosting the actor to the supervisor when actor terminates.
/// This is an internal message, not typically sent by user code.
///
/// ## Erlang Philosophy
/// Equivalent to receiving: {'DOWN', Ref, process, Pid, Reason}
/// Supervisor receives this asynchronously when monitored actor exits.
///
/// ## Design Notes
/// - actor_id: The actor that terminated
/// - supervisor_id: The supervisor that was monitoring (for routing)
/// - reason: Why actor terminated:
///    - "normal": Graceful shutdown
///    - "shutdown": Supervisor-initiated shutdown
///    - "killed": Forcefully terminated
///    - Error message: Crash reason (e.g., "panic: index out of bounds")
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorDownNotification {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub reason: ::prost::alloc::string::String,
}
/// / Actor link for two-way death propagation
/// /
/// / ## Purpose
/// / Represents a link between two actors. When one actor dies, the linked actor
/// / automatically dies (cascading failure). This is the foundation for supervision trees.
/// /
/// / ## Erlang Philosophy
/// / Equivalent to Erlang's `link/1` - creates a bidirectional link between processes.
/// / If either process dies abnormally, the other dies too.
/// /
/// / ## Design Notes
/// / - Links are bidirectional (if A links to B, B is linked to A)
/// / - Links propagate death (if A dies, B dies; if B dies, A dies)
/// / - Links are used internally by supervision (parent-child relationships)
/// / - Links can also be created explicitly via API
/// /
/// / ## Example
/// / ```rust
/// / // Link two actors
/// / node.link("actor-1", "actor-2").await?;
/// /
/// / // If actor-1 dies abnormally, actor-2 automatically dies
/// / // If actor-2 dies abnormally, actor-1 automatically dies
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorLink {
    /// / First actor in the link
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// / Second actor in the link (bidirectional)
    #[prost(string, tag="2")]
    pub linked_actor_id: ::prost::alloc::string::String,
    /// / Link creation timestamp (for observability)
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// / Metadata (optional, for debugging)
    #[prost(map="string, string", tag="4")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// / Link two actors (Erlang link/1 equivalent)
/// /
/// / ## Purpose
/// / Creates a bidirectional link between two actors. When one actor dies abnormally,
/// / the linked actor automatically dies (cascading failure).
/// /
/// / ## Erlang Philosophy
/// / Equivalent to Erlang's `link(Pid)` - creates bidirectional link.
/// / If either process dies abnormally, the other dies too.
/// /
/// / ## Design Notes
/// / - Links are bidirectional (if A links to B, B is linked to A)
/// / - Links only propagate abnormal deaths (not "normal" shutdowns)
/// / - Links are used internally by supervision (parent-child relationships)
/// / - Links can be created explicitly via this API
/// /
/// / ## Example
/// / ```rust
/// / // Link two actors
/// / node.link("actor-1", "actor-2").await?;
/// /
/// / // If actor-1 dies abnormally, actor-2 automatically dies
/// / // If actor-2 dies abnormally, actor-1 automatically dies
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub linked_actor_id: ::prost::alloc::string::String,
}
/// / Response to LinkActor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkActorResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// / Unlink two actors (Erlang unlink/1 equivalent)
/// /
/// / ## Purpose
/// / Removes the bidirectional link between two actors. After unlinking,
/// / actors can die independently without cascading failures.
/// /
/// / ## Erlang Philosophy
/// / Equivalent to Erlang's `unlink(Pid)` - removes bidirectional link.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlinkActorRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub linked_actor_id: ::prost::alloc::string::String,
}
/// / Response to UnlinkActor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlinkActorResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
}
// ============================================================================
// Lifecycle Event Channel (JavaNOW-inspired Pub/Sub for Observability)
// ============================================================================

// LifecycleEventChannel service - event streaming for observability
//
// ## Purpose
// Provides pub/sub channel for actor lifecycle events, inspired by JavaNOW's
// EntitySpace event notification and channel/subscriber architecture.
// This is the foundation for metrics, tracing, and monitoring integration.

/// Request to activate a virtual actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivateActorRequest {
    /// Actor ID to activate (must have VirtualActorFacet)
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Optional: Force activation even if already active
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// Response to activate actor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivateActorResponse {
    /// Activated actor instance
    /// Note: actor.state contains the actual lifecycle state (ActorState enum)
    #[prost(message, optional, tag="1")]
    pub actor: ::core::option::Option<Actor>,
    /// Optional activation metadata (timestamps, counts, etc.)
    /// This is metadata only - the actual state is in actor.state (ActorState enum)
    /// All actors (virtual or not) use the same ActorState enum for consistency
    #[prost(message, optional, tag="2")]
    pub lifecycle: ::core::option::Option<VirtualActorLifecycle>,
}
/// Request to deactivate a virtual actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateActorRequest {
    /// Actor ID to deactivate (must have VirtualActorFacet)
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Optional: Force deactivation even if actor has pending messages
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// Request to check if actor exists
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckActorExistsRequest {
    /// Actor ID to check
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
/// Response to check actor exists request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckActorExistsResponse {
    /// Actor exists (virtual or active)
    #[prost(bool, tag="1")]
    pub exists: bool,
    /// Actor is currently active (in memory)
    #[prost(bool, tag="2")]
    pub is_active: bool,
    /// Actor has VirtualActorFacet (is virtual)
    #[prost(bool, tag="3")]
    pub is_virtual: bool,
}
/// Request to get or activate a virtual actor (Orleans-style)
///
/// ## Purpose
/// Gets existing actor if active, or activates virtual actor if inactive.
/// This is the primary API for virtual actors (Orleans grains pattern).
///
/// ## Orleans Comparison
/// Orleans: `IGrainFactory.GetGrain<T>(key)` - always returns grain reference
/// PlexSpaces: `GetOrActivateActor(actor_id, factory)` - activates if needed
///
/// ## Behavior
/// 1. If actor exists and is active → Return existing ActorRef
/// 2. If actor exists but is inactive (virtual) → Activate and return ActorRef
/// 3. If actor doesn't exist → Create new actor (if factory provided) and return ActorRef
///
/// ## Virtual Actor Pattern
/// - Actor ID must be client-specified (e.g., "user/123", "session/abc")
/// - Actor must have VirtualActorFacet attached (enables lazy activation)
/// - First message triggers activation automatically
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrActivateActorRequest {
    /// Actor ID (client-specified, required)
    /// Format: "{actor_type}/{key}" or "{actor_type}@{key}"
    /// Examples: "user/123", "session/abc-xyz", "counter@node1"
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Actor type (required if actor doesn't exist)
    /// Used to create new actor if actor_id doesn't exist
    #[prost(string, tag="2")]
    pub actor_type: ::prost::alloc::string::String,
    /// Initial state (used if creating new actor)
    #[prost(bytes="vec", tag="3")]
    pub initial_state: ::prost::alloc::vec::Vec<u8>,
    /// Actor config (used if creating new actor)
    #[prost(message, optional, tag="4")]
    pub config: ::core::option::Option<ActorConfig>,
    /// Force activation even if already active
    #[prost(bool, tag="5")]
    pub force_activation: bool,
}
/// Response to get or activate actor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrActivateActorResponse {
    /// Actor reference (format: "actor_id@node_id")
    #[prost(string, tag="1")]
    pub actor_ref: ::prost::alloc::string::String,
    /// Full actor details
    #[prost(message, optional, tag="2")]
    pub actor: ::core::option::Option<Actor>,
    /// Was actor activated (true) or already active (false)
    #[prost(bool, tag="3")]
    pub was_activated: bool,
}
/// Request to invoke an actor via HTTP-like interface (FaaS-style)
///
/// ## Purpose
/// Enables FaaS-like invocation of actors via HTTP GET/POST/PUT/DELETE requests.
/// The tenant_id, namespace, and actor_type are extracted from the HTTP path.
///
/// ## HTTP Method Handling
/// - GET: Query parameters are converted to JSON and stored in payload as string
/// - POST: Request body becomes payload, HTTP headers become headers map
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeActorRequest {
    /// Tenant ID (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type} or /api/v1/actors/{namespace}/{actor_type})
    /// Default: "default" if not provided in path or if no authentication provided
    /// When using path without tenant_id, this field will be empty and should default to "default"
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Namespace (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type})
    /// Default: "default" if not specified
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor type (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type})
    /// Used to lookup actors via ActorRegistry discover_actors_by_type
    #[prost(string, tag="3")]
    pub actor_type: ::prost::alloc::string::String,
    /// HTTP method (GET, POST, PUT, or DELETE)
    /// GET/DELETE: Uses ask() (request-reply), POST/PUT: Uses tell() (fire-and-forget)
    #[prost(string, tag="4")]
    pub http_method: ::prost::alloc::string::String,
    /// Request payload
    /// For GET/DELETE: JSON string of query parameters
    /// For POST/PUT: Request body bytes
    #[prost(bytes="vec", tag="5")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// HTTP headers (for POST/PUT requests)
    /// Converted from HTTP request headers
    #[prost(map="string, string", tag="6")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Query parameters (for GET/DELETE requests)
    /// Converted to JSON and stored in payload
    #[prost(map="string, string", tag="7")]
    pub query_params: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Full HTTP path for the request (optional)
    /// Example: "/api/v1/actors/default/default/counter/custom/path"
    /// Allows actors to perform custom routing based on the complete URL
    #[prost(string, tag="9")]
    pub path: ::prost::alloc::string::String,
    /// Subpath after the actor_type segment (optional)
    /// Example: for "/api/v1/actors/default/default/counter/metrics/latest"
    ///           subpath = "metrics/latest"
    /// This will be used in future for advanced per-actor routing capabilities.
    #[prost(string, tag="10")]
    pub subpath: ::prost::alloc::string::String,
}
/// Response from invoking an actor
///
/// ## Purpose
/// Returns the result of actor invocation.
/// For GET (ask): Contains the reply message from actor
/// For POST (tell): Contains success status (fire-and-forget)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeActorResponse {
    /// Success status
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Response payload (for GET/ask requests)
    /// Contains the reply message from actor
    #[prost(bytes="vec", tag="2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Response headers (optional metadata)
    #[prost(map="string, string", tag="3")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Actor ID that was invoked (format: "actor_id@node_id")
    #[prost(string, tag="4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Error message (if success is false)
    #[prost(string, tag="5")]
    pub error_message: ::prost::alloc::string::String,
}
/// Lifecycle event filter for subscribers
///
/// ## Purpose
/// Defines what events a subscriber wants to receive. Supports filtering by:
/// - Event types (Created, Terminated, Failed, etc.)
/// - Actor ID patterns (regex)
/// - Node ID patterns (regex)
/// - Custom tags
///
/// ## Examples
/// ```
/// // Prometheus exporter - only care about actor spawn/terminate for counts
/// EventFilter {
///    event_types: \[ACTOR_CREATED, ACTOR_TERMINATED, ACTOR_FAILED\]
/// }
///
/// // Tracing system - want all events for specific actor group
/// EventFilter {
///    actor_id_pattern: "worker-.*@node1"
///    event_types: \[ACTOR_ACTIVATED, ACTOR_DEACTIVATED\]
/// }
///
/// // Monitoring dashboard - all critical events across cluster
/// EventFilter {
///    event_types: \[ACTOR_FAILED, ACTOR_MIGRATING\]
/// }
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecycleEventFilter {
    /// Subscription ID (ULID, generated by subscriber)
    /// Used for unsubscribe and tracking
    #[prost(string, tag="1")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Event types to receive (empty = all types)
    /// Maps to ActorLifecycleEvent.event_type oneof
    #[prost(enumeration="LifecycleEventType", repeated, tag="2")]
    pub event_types: ::prost::alloc::vec::Vec<i32>,
    /// Actor ID pattern (regex, empty = all actors)
    /// Example: "worker-.*@node1" matches all workers on node1
    #[prost(string, tag="3")]
    pub actor_id_pattern: ::prost::alloc::string::String,
    /// Node ID pattern (regex, empty = all nodes)
    /// Example: "prod-.*" matches all production nodes
    #[prost(string, tag="4")]
    pub node_id_pattern: ::prost::alloc::string::String,
    /// Custom tags filter (AND logic - event must have all tags)
    /// Example: {"env": "production", "team": "platform"}
    #[prost(map="string, string", tag="5")]
    pub required_tags: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Buffer size for slow subscriber (default: 1000 events)
    /// When buffer full, drop_policy determines behavior
    ///
    /// Max 100K events
    #[prost(uint32, tag="6")]
    pub buffer_size: u32,
    /// Drop policy when buffer full
    #[prost(enumeration="DropPolicy", tag="7")]
    pub drop_policy: i32,
}
/// Virtual Actor Lifecycle (Orleans-inspired)
///
/// ## Purpose
/// Tracks activation/deactivation state for virtual actors (actors that exist virtually,
/// activated on-demand). Virtual actors are always addressable but not always in memory.
///
/// ## When Used
/// Only present when actor has VirtualActorFacet attached (opt-in pattern).
/// Regular actors (explicit creation) don't have this lifecycle tracking.
///
/// ## Design Decision
/// Virtual actor lifecycle is tracked separately from core ActorState to maintain
/// simplicity: core actors are explicit, virtual actors are opt-in via facet.
///
/// ## Example
/// ```protobuf
/// Actor {
///    actor_id: "user-123"
///    state: ACTOR_STATE_INACTIVE  // Virtual actor, not in memory
///    facets: [
///      Facet {
///        type: "virtual_actor"
///        config: {
///          "idle_timeout": "5m",
///          "activation_strategy": "lazy"
///        }
///      }
///    ]
/// }
/// ```
/// Virtual Actor Lifecycle Metadata
///
/// ## Purpose
/// Provides metadata about virtual actor activation/deactivation (timestamps, counts, etc.).
/// This is METADATA only - the actual lifecycle state is tracked in Actor.state (ActorState enum).
///
/// ## Design Decision
/// All actors (virtual or not) use the same ActorState enum for state consistency.
/// VirtualActorLifecycle provides additional metadata useful for virtual actors:
/// - Activation timestamps (for monitoring/debugging)
/// - Activation counts (for metrics)
/// - Idle timeout configuration
/// - Pending message counts
///
/// ## Usage
/// - Actor.state: Source of truth for lifecycle state (CREATING, ACTIVE, INACTIVE, etc.)
/// - VirtualActorLifecycle: Optional metadata for virtual actors only
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualActorLifecycle {
    /// Last time actor was activated (loaded into memory)
    #[prost(message, optional, tag="1")]
    pub last_activated: ::core::option::Option<::prost_types::Timestamp>,
    /// Last time actor received a message or performed an operation
    #[prost(message, optional, tag="2")]
    pub last_accessed: ::core::option::Option<::prost_types::Timestamp>,
    /// Idle timeout before deactivation (from facet config)
    #[prost(message, optional, tag="3")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Number of times this actor has been activated
    #[prost(uint32, tag="4")]
    pub activation_count: u32,
    /// Is currently activating (prevents duplicate activations)
    #[prost(bool, tag="5")]
    pub is_activating: bool,
    /// Messages queued during activation (processed after activation completes)
    /// Note: This is a simplified representation - actual queue is in Node
    #[prost(uint32, tag="6")]
    pub pending_message_count: u32,
}
/// Virtual Actor Configuration (for VirtualActorFacet)
///
/// ## Purpose
/// Configuration for virtual actor behavior (activation strategy, idle timeout, etc.)
///
/// ## Usage
/// This config is stored in the VirtualActorFacet's config map:
/// ```protobuf
/// Facet {
///    type: "virtual_actor"
///    config: {
///      "idle_timeout": "5m",
///      "activation_strategy": "lazy"
///    }
/// }
/// ```
///
/// ## Design Decision
/// Config is stored as string map in Facet (simplicity, flexibility).
/// This message is for documentation and type safety in Rust code.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualActorConfig {
    /// Activation strategy
    #[prost(enumeration="ActivationStrategy", tag="1")]
    pub activation_strategy: i32,
    /// Idle timeout before deactivation
    #[prost(message, optional, tag="2")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Should actor persist state on deactivation?
    #[prost(bool, tag="3")]
    pub persist_on_deactivation: bool,
}
/// ActorRef error message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorRefError {
    #[prost(enumeration="ActorRefErrorCode", tag="1")]
    pub code: i32,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Optional: actor ID that caused error
    #[prost(string, tag="3")]
    pub actor_id: ::prost::alloc::string::String,
}
/// Resource contract for an actor
/// Declares resource requirements and limits upfront
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceContract {
    /// Maximum CPU usage as percentage (0.0 - 100.0)
    #[prost(float, tag="1")]
    pub max_cpu_percent: f32,
    /// Maximum memory usage in bytes
    #[prost(uint64, tag="2")]
    pub max_memory_bytes: u64,
    /// Maximum I/O operations per second
    #[prost(uint32, optional, tag="3")]
    pub max_io_ops_per_sec: ::core::option::Option<u32>,
    /// Guaranteed network bandwidth in Mbps
    #[prost(uint32, optional, tag="4")]
    pub guaranteed_bandwidth_mbps: ::core::option::Option<u32>,
    /// Maximum execution time per message
    #[prost(message, optional, tag="5")]
    pub max_execution_time: ::core::option::Option<::prost_types::Duration>,
}
/// Current resource usage of an actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceUsage {
    /// Current CPU usage percentage
    #[prost(float, tag="1")]
    pub cpu_percent: f32,
    /// Current memory usage in bytes
    #[prost(uint64, tag="2")]
    pub memory_bytes: u64,
    /// Current I/O operations per second
    #[prost(uint32, tag="3")]
    pub io_ops_per_sec: u32,
    /// Current network bandwidth in Mbps
    #[prost(uint32, tag="4")]
    pub network_mbps: u32,
}
/// Resource violation error message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceViolation {
    #[prost(enumeration="ResourceViolationCode", tag="1")]
    pub code: i32,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Allowed value (e.g., max_cpu_percent)
    #[prost(float, optional, tag="3")]
    pub allowed_value: ::core::option::Option<f32>,
    /// Actual value (e.g., current cpu_percent)
    #[prost(float, optional, tag="4")]
    pub actual_value: ::core::option::Option<f32>,
}
/// Actor health message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorHealth {
    #[prost(enumeration="ActorHealthStatus", tag="1")]
    pub status: i32,
    /// For STUCK status: how long actor has been stuck
    #[prost(message, optional, tag="2")]
    pub stuck_since: ::core::option::Option<::prost_types::Duration>,
    /// For FAILED status: reason for failure
    #[prost(string, optional, tag="3")]
    pub failure_reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Actor lifecycle states.
///
/// ## Purpose
/// Defines the state machine for actor lifecycle management and supervision.
///
/// ## Why This Exists
/// - Enables supervision to track actor health and make restart decisions
/// - Supports graceful activation/deactivation (Orbit-inspired auto-activation)
/// - Allows migration state tracking for mobile agents
/// - Provides clear state transitions for debugging and monitoring
///
/// ## State Transitions
/// ```
/// CREATING -> ACTIVATING -> ACTIVE -> DEACTIVATING -> INACTIVE
///                         \-> MIGRATING -> ACTIVE (on new node)
///                         \-> FAILED -> (supervisor restarts)
///                         \-> TERMINATED (permanent stop)
/// ```
///
/// ## Design Notes
/// - UNSPECIFIED should never occur in valid states (indicates error)
/// - ACTIVATING/DEACTIVATING enable graceful lifecycle management
/// - MIGRATING supports actor mobility between nodes
/// - FAILED triggers supervisor restart policies
/// - FAILED state includes error message for debugging (see Actor message for error details)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActorState {
    ActorStateUnspecified = 0,
    /// Actor is created but not yet started (replaces "Initializing")
    ActorStateCreating = 1,
    /// Actor is running and processing messages
    ActorStateActive = 2,
    /// Actor is suspended/not processing (replaces "Suspended")
    ActorStateInactive = 3,
    /// Actor is activating (loading state, running on_activate)
    ActorStateActivating = 4,
    /// Actor is deactivating (saving state, running on_deactivate)
    ActorStateDeactivating = 5,
    /// Actor is migrating to another node
    ActorStateMigrating = 6,
    /// Actor has crashed (error message in Actor.error_message field)
    ActorStateFailed = 7,
    /// Actor has permanently stopped (replaces "Stopped")
    ActorStateTerminated = 8,
}
impl ActorState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActorState::ActorStateUnspecified => "ACTOR_STATE_UNSPECIFIED",
            ActorState::ActorStateCreating => "ACTOR_STATE_CREATING",
            ActorState::ActorStateActive => "ACTOR_STATE_ACTIVE",
            ActorState::ActorStateInactive => "ACTOR_STATE_INACTIVE",
            ActorState::ActorStateActivating => "ACTOR_STATE_ACTIVATING",
            ActorState::ActorStateDeactivating => "ACTOR_STATE_DEACTIVATING",
            ActorState::ActorStateMigrating => "ACTOR_STATE_MIGRATING",
            ActorState::ActorStateFailed => "ACTOR_STATE_FAILED",
            ActorState::ActorStateTerminated => "ACTOR_STATE_TERMINATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTOR_STATE_UNSPECIFIED" => Some(Self::ActorStateUnspecified),
            "ACTOR_STATE_CREATING" => Some(Self::ActorStateCreating),
            "ACTOR_STATE_ACTIVE" => Some(Self::ActorStateActive),
            "ACTOR_STATE_INACTIVE" => Some(Self::ActorStateInactive),
            "ACTOR_STATE_ACTIVATING" => Some(Self::ActorStateActivating),
            "ACTOR_STATE_DEACTIVATING" => Some(Self::ActorStateDeactivating),
            "ACTOR_STATE_MIGRATING" => Some(Self::ActorStateMigrating),
            "ACTOR_STATE_FAILED" => Some(Self::ActorStateFailed),
            "ACTOR_STATE_TERMINATED" => Some(Self::ActorStateTerminated),
            _ => None,
        }
    }
}
/// Placement strategy for actor activation (Orleans-inspired)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlacementStrategy {
    PlacementStrategyUnspecified = 0,
    /// Random node selection
    PlacementStrategyRandom = 1,
    /// Co-locate with caller
    PlacementStrategyPreferLocal = 2,
    /// Balance by load
    PlacementStrategyLoadBased = 3,
    /// Based on resource availability
    PlacementStrategyResourceBased = 4,
    /// Affinity groups
    PlacementStrategyAffinity = 5,
    /// User-defined
    PlacementStrategyCustom = 99,
}
impl PlacementStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PlacementStrategy::PlacementStrategyUnspecified => "PLACEMENT_STRATEGY_UNSPECIFIED",
            PlacementStrategy::PlacementStrategyRandom => "PLACEMENT_STRATEGY_RANDOM",
            PlacementStrategy::PlacementStrategyPreferLocal => "PLACEMENT_STRATEGY_PREFER_LOCAL",
            PlacementStrategy::PlacementStrategyLoadBased => "PLACEMENT_STRATEGY_LOAD_BASED",
            PlacementStrategy::PlacementStrategyResourceBased => "PLACEMENT_STRATEGY_RESOURCE_BASED",
            PlacementStrategy::PlacementStrategyAffinity => "PLACEMENT_STRATEGY_AFFINITY",
            PlacementStrategy::PlacementStrategyCustom => "PLACEMENT_STRATEGY_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLACEMENT_STRATEGY_UNSPECIFIED" => Some(Self::PlacementStrategyUnspecified),
            "PLACEMENT_STRATEGY_RANDOM" => Some(Self::PlacementStrategyRandom),
            "PLACEMENT_STRATEGY_PREFER_LOCAL" => Some(Self::PlacementStrategyPreferLocal),
            "PLACEMENT_STRATEGY_LOAD_BASED" => Some(Self::PlacementStrategyLoadBased),
            "PLACEMENT_STRATEGY_RESOURCE_BASED" => Some(Self::PlacementStrategyResourceBased),
            "PLACEMENT_STRATEGY_AFFINITY" => Some(Self::PlacementStrategyAffinity),
            "PLACEMENT_STRATEGY_CUSTOM" => Some(Self::PlacementStrategyCustom),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoadBalancingStrategy {
    LoadBalancingUnspecified = 0,
    LoadBalancingRoundRobin = 1,
    LoadBalancingLeastLoaded = 2,
    LoadBalancingRandom = 3,
}
impl LoadBalancingStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LoadBalancingStrategy::LoadBalancingUnspecified => "LOAD_BALANCING_UNSPECIFIED",
            LoadBalancingStrategy::LoadBalancingRoundRobin => "LOAD_BALANCING_ROUND_ROBIN",
            LoadBalancingStrategy::LoadBalancingLeastLoaded => "LOAD_BALANCING_LEAST_LOADED",
            LoadBalancingStrategy::LoadBalancingRandom => "LOAD_BALANCING_RANDOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOAD_BALANCING_UNSPECIFIED" => Some(Self::LoadBalancingUnspecified),
            "LOAD_BALANCING_ROUND_ROBIN" => Some(Self::LoadBalancingRoundRobin),
            "LOAD_BALANCING_LEAST_LOADED" => Some(Self::LoadBalancingLeastLoaded),
            "LOAD_BALANCING_RANDOM" => Some(Self::LoadBalancingRandom),
            _ => None,
        }
    }
}
/// Partition strategy for data-parallel actors
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PartitionStrategy {
    PartitionStrategyUnspecified = 0,
    /// Hash-based partitioning (default)
    PartitionStrategyHash = 1,
    /// Range-based partitioning
    PartitionStrategyRange = 2,
    /// Consistent hashing
    PartitionStrategyConsistentHash = 3,
    /// User-defined partitioner
    PartitionStrategyCustom = 99,
}
impl PartitionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PartitionStrategy::PartitionStrategyUnspecified => "PARTITION_STRATEGY_UNSPECIFIED",
            PartitionStrategy::PartitionStrategyHash => "PARTITION_STRATEGY_HASH",
            PartitionStrategy::PartitionStrategyRange => "PARTITION_STRATEGY_RANGE",
            PartitionStrategy::PartitionStrategyConsistentHash => "PARTITION_STRATEGY_CONSISTENT_HASH",
            PartitionStrategy::PartitionStrategyCustom => "PARTITION_STRATEGY_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTITION_STRATEGY_UNSPECIFIED" => Some(Self::PartitionStrategyUnspecified),
            "PARTITION_STRATEGY_HASH" => Some(Self::PartitionStrategyHash),
            "PARTITION_STRATEGY_RANGE" => Some(Self::PartitionStrategyRange),
            "PARTITION_STRATEGY_CONSISTENT_HASH" => Some(Self::PartitionStrategyConsistentHash),
            "PARTITION_STRATEGY_CUSTOM" => Some(Self::PartitionStrategyCustom),
            _ => None,
        }
    }
}
/// Rebalancing policy for data-parallel actors
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RebalancePolicy {
    RebalancePolicyUnspecified = 0,
    /// No automatic rebalancing
    RebalancePolicyNone = 1,
    /// Rebalance when shards added/removed
    RebalancePolicyOnScale = 2,
    /// Rebalance based on load metrics
    RebalancePolicyLoadBased = 3,
}
impl RebalancePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RebalancePolicy::RebalancePolicyUnspecified => "REBALANCE_POLICY_UNSPECIFIED",
            RebalancePolicy::RebalancePolicyNone => "REBALANCE_POLICY_NONE",
            RebalancePolicy::RebalancePolicyOnScale => "REBALANCE_POLICY_ON_SCALE",
            RebalancePolicy::RebalancePolicyLoadBased => "REBALANCE_POLICY_LOAD_BASED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REBALANCE_POLICY_UNSPECIFIED" => Some(Self::RebalancePolicyUnspecified),
            "REBALANCE_POLICY_NONE" => Some(Self::RebalancePolicyNone),
            "REBALANCE_POLICY_ON_SCALE" => Some(Self::RebalancePolicyOnScale),
            "REBALANCE_POLICY_LOAD_BASED" => Some(Self::RebalancePolicyLoadBased),
            _ => None,
        }
    }
}
/// State management mode (lattice-based data-parallel actors)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StateMgmtMode {
    StateMgmtModeUnspecified = 0,
    /// Regular mutable state
    StateMgmtModeTraditional = 1,
    /// Coordination-free lattice state (CRDT)
    StateMgmtModeLattice = 2,
}
impl StateMgmtMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StateMgmtMode::StateMgmtModeUnspecified => "STATE_MGMT_MODE_UNSPECIFIED",
            StateMgmtMode::StateMgmtModeTraditional => "STATE_MGMT_MODE_TRADITIONAL",
            StateMgmtMode::StateMgmtModeLattice => "STATE_MGMT_MODE_LATTICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_MGMT_MODE_UNSPECIFIED" => Some(Self::StateMgmtModeUnspecified),
            "STATE_MGMT_MODE_TRADITIONAL" => Some(Self::StateMgmtModeTraditional),
            "STATE_MGMT_MODE_LATTICE" => Some(Self::StateMgmtModeLattice),
            _ => None,
        }
    }
}
/// Consistency level for lattice-based actors
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsistencyLevel {
    ConsistencyLevelUnspecified = 0,
    /// No ordering guarantees
    ConsistencyLevelEventual = 1,
    /// Causal consistency (vector clocks)
    ConsistencyLevelCausal = 2,
    /// Read committed isolation
    ConsistencyLevelReadCommitted = 3,
    /// Strict consistency (coordination required)
    ConsistencyLevelLinearizable = 4,
}
impl ConsistencyLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConsistencyLevel::ConsistencyLevelUnspecified => "CONSISTENCY_LEVEL_UNSPECIFIED",
            ConsistencyLevel::ConsistencyLevelEventual => "CONSISTENCY_LEVEL_EVENTUAL",
            ConsistencyLevel::ConsistencyLevelCausal => "CONSISTENCY_LEVEL_CAUSAL",
            ConsistencyLevel::ConsistencyLevelReadCommitted => "CONSISTENCY_LEVEL_READ_COMMITTED",
            ConsistencyLevel::ConsistencyLevelLinearizable => "CONSISTENCY_LEVEL_LINEARIZABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSISTENCY_LEVEL_UNSPECIFIED" => Some(Self::ConsistencyLevelUnspecified),
            "CONSISTENCY_LEVEL_EVENTUAL" => Some(Self::ConsistencyLevelEventual),
            "CONSISTENCY_LEVEL_CAUSAL" => Some(Self::ConsistencyLevelCausal),
            "CONSISTENCY_LEVEL_READ_COMMITTED" => Some(Self::ConsistencyLevelReadCommitted),
            "CONSISTENCY_LEVEL_LINEARIZABLE" => Some(Self::ConsistencyLevelLinearizable),
            _ => None,
        }
    }
}
/// Supervision strategies
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SupervisionStrategy {
    SupervisionStrategyUnspecified = 0,
    SupervisionStrategyOneForOne = 1,
    SupervisionStrategyOneForAll = 2,
    SupervisionStrategyRestForOne = 3,
}
impl SupervisionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SupervisionStrategy::SupervisionStrategyUnspecified => "SUPERVISION_STRATEGY_UNSPECIFIED",
            SupervisionStrategy::SupervisionStrategyOneForOne => "SUPERVISION_STRATEGY_ONE_FOR_ONE",
            SupervisionStrategy::SupervisionStrategyOneForAll => "SUPERVISION_STRATEGY_ONE_FOR_ALL",
            SupervisionStrategy::SupervisionStrategyRestForOne => "SUPERVISION_STRATEGY_REST_FOR_ONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUPERVISION_STRATEGY_UNSPECIFIED" => Some(Self::SupervisionStrategyUnspecified),
            "SUPERVISION_STRATEGY_ONE_FOR_ONE" => Some(Self::SupervisionStrategyOneForOne),
            "SUPERVISION_STRATEGY_ONE_FOR_ALL" => Some(Self::SupervisionStrategyOneForAll),
            "SUPERVISION_STRATEGY_REST_FOR_ONE" => Some(Self::SupervisionStrategyRestForOne),
            _ => None,
        }
    }
}
// ==================== Link Semantics (Erlang Pattern) ====================

/// / Monitor type (distinguishes Monitor from Link)
/// /
/// / ## Purpose
/// / Distinguishes between one-way monitoring (Monitor) and two-way death propagation (Link).
/// / This enables clear API separation and proper handling of each type.
/// /
/// / ## Erlang Philosophy
/// / - **MONITOR**: One-way notification (Erlang `monitor/2`)
/// /   - Supervisor gets notified when actor dies
/// /   - Supervisor does NOT die when actor dies
/// /   - Used for observability, health checks
/// /
/// / - **LINK**: Two-way death propagation (Erlang `link/1`)
/// /   - If actor1 dies, actor2 automatically dies (cascading)
/// /   - If actor2 dies, actor1 automatically dies (cascading)
/// /   - Used for tight coupling, supervision trees
/// /
/// / ## Design Notes
/// / - Monitors remain separate (existing functionality)
/// / - Links enable cascading failures (new functionality)
/// / - Supervision uses links internally (cohesive design)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MonitorType {
    MonitorTypeUnspecified = 0,
    /// / One-way monitoring (get notified, don't die)
    MonitorTypeMonitor = 1,
    /// / Two-way link (die together, cascading failures)
    MonitorTypeLink = 2,
}
impl MonitorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MonitorType::MonitorTypeUnspecified => "MONITOR_TYPE_UNSPECIFIED",
            MonitorType::MonitorTypeMonitor => "MONITOR_TYPE_MONITOR",
            MonitorType::MonitorTypeLink => "MONITOR_TYPE_LINK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MONITOR_TYPE_UNSPECIFIED" => Some(Self::MonitorTypeUnspecified),
            "MONITOR_TYPE_MONITOR" => Some(Self::MonitorTypeMonitor),
            "MONITOR_TYPE_LINK" => Some(Self::MonitorTypeLink),
            _ => None,
        }
    }
}
/// Lifecycle event types for filtering
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LifecycleEventType {
    LifecycleEventTypeUnspecified = 0,
    LifecycleEventTypeCreated = 1,
    LifecycleEventTypeStarting = 2,
    LifecycleEventTypeActivated = 3,
    LifecycleEventTypeDeactivating = 4,
    LifecycleEventTypeDeactivated = 5,
    LifecycleEventTypeTerminated = 6,
    LifecycleEventTypeFailed = 7,
    LifecycleEventTypeMigrating = 8,
}
impl LifecycleEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LifecycleEventType::LifecycleEventTypeUnspecified => "LIFECYCLE_EVENT_TYPE_UNSPECIFIED",
            LifecycleEventType::LifecycleEventTypeCreated => "LIFECYCLE_EVENT_TYPE_CREATED",
            LifecycleEventType::LifecycleEventTypeStarting => "LIFECYCLE_EVENT_TYPE_STARTING",
            LifecycleEventType::LifecycleEventTypeActivated => "LIFECYCLE_EVENT_TYPE_ACTIVATED",
            LifecycleEventType::LifecycleEventTypeDeactivating => "LIFECYCLE_EVENT_TYPE_DEACTIVATING",
            LifecycleEventType::LifecycleEventTypeDeactivated => "LIFECYCLE_EVENT_TYPE_DEACTIVATED",
            LifecycleEventType::LifecycleEventTypeTerminated => "LIFECYCLE_EVENT_TYPE_TERMINATED",
            LifecycleEventType::LifecycleEventTypeFailed => "LIFECYCLE_EVENT_TYPE_FAILED",
            LifecycleEventType::LifecycleEventTypeMigrating => "LIFECYCLE_EVENT_TYPE_MIGRATING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIFECYCLE_EVENT_TYPE_UNSPECIFIED" => Some(Self::LifecycleEventTypeUnspecified),
            "LIFECYCLE_EVENT_TYPE_CREATED" => Some(Self::LifecycleEventTypeCreated),
            "LIFECYCLE_EVENT_TYPE_STARTING" => Some(Self::LifecycleEventTypeStarting),
            "LIFECYCLE_EVENT_TYPE_ACTIVATED" => Some(Self::LifecycleEventTypeActivated),
            "LIFECYCLE_EVENT_TYPE_DEACTIVATING" => Some(Self::LifecycleEventTypeDeactivating),
            "LIFECYCLE_EVENT_TYPE_DEACTIVATED" => Some(Self::LifecycleEventTypeDeactivated),
            "LIFECYCLE_EVENT_TYPE_TERMINATED" => Some(Self::LifecycleEventTypeTerminated),
            "LIFECYCLE_EVENT_TYPE_FAILED" => Some(Self::LifecycleEventTypeFailed),
            "LIFECYCLE_EVENT_TYPE_MIGRATING" => Some(Self::LifecycleEventTypeMigrating),
            _ => None,
        }
    }
}
/// Drop policy for buffer overflow (JavaNOW-inspired backpressure)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DropPolicy {
    DropPolicyUnspecified = 0,
    /// Drop oldest events, keep newest (good for real-time)
    DropPolicyDropOldest = 1,
    /// Drop newest events, keep oldest (good for audit)
    DropPolicyDropNewest = 2,
    /// Block publisher until buffer drains (use carefully!)
    DropPolicyBlock = 3,
}
impl DropPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DropPolicy::DropPolicyUnspecified => "DROP_POLICY_UNSPECIFIED",
            DropPolicy::DropPolicyDropOldest => "DROP_POLICY_DROP_OLDEST",
            DropPolicy::DropPolicyDropNewest => "DROP_POLICY_DROP_NEWEST",
            DropPolicy::DropPolicyBlock => "DROP_POLICY_BLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DROP_POLICY_UNSPECIFIED" => Some(Self::DropPolicyUnspecified),
            "DROP_POLICY_DROP_OLDEST" => Some(Self::DropPolicyDropOldest),
            "DROP_POLICY_DROP_NEWEST" => Some(Self::DropPolicyDropNewest),
            "DROP_POLICY_BLOCK" => Some(Self::DropPolicyBlock),
            _ => None,
        }
    }
}
/// Activation strategy for virtual actors
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActivationStrategy {
    ActivationStrategyUnspecified = 0,
    /// Activate on first message (default)
    ActivationStrategyLazy = 1,
    /// Activate immediately on creation
    ActivationStrategyEager = 2,
    /// Pre-activate based on schedule
    ActivationStrategyPrewarm = 3,
}
impl ActivationStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActivationStrategy::ActivationStrategyUnspecified => "ACTIVATION_STRATEGY_UNSPECIFIED",
            ActivationStrategy::ActivationStrategyLazy => "ACTIVATION_STRATEGY_LAZY",
            ActivationStrategy::ActivationStrategyEager => "ACTIVATION_STRATEGY_EAGER",
            ActivationStrategy::ActivationStrategyPrewarm => "ACTIVATION_STRATEGY_PREWARM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTIVATION_STRATEGY_UNSPECIFIED" => Some(Self::ActivationStrategyUnspecified),
            "ACTIVATION_STRATEGY_LAZY" => Some(Self::ActivationStrategyLazy),
            "ACTIVATION_STRATEGY_EAGER" => Some(Self::ActivationStrategyEager),
            "ACTIVATION_STRATEGY_PREWARM" => Some(Self::ActivationStrategyPrewarm),
            _ => None,
        }
    }
}
// ============================================================================
// ActorRef Error Types (Proto-First Design)
// ============================================================================

/// ActorRef error codes
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActorRefErrorCode {
    ActorRefErrorCodeUnspecified = 0,
    ActorRefErrorCodeActorNotFound = 1,
    ActorRefErrorCodeSendFailed = 2,
    ActorRefErrorCodeMailboxFull = 3,
    ActorRefErrorCodeActorTerminated = 4,
    ActorRefErrorCodeTimeout = 5,
    ActorRefErrorCodeRemoteNotImplemented = 6,
}
impl ActorRefErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActorRefErrorCode::ActorRefErrorCodeUnspecified => "ACTOR_REF_ERROR_CODE_UNSPECIFIED",
            ActorRefErrorCode::ActorRefErrorCodeActorNotFound => "ACTOR_REF_ERROR_CODE_ACTOR_NOT_FOUND",
            ActorRefErrorCode::ActorRefErrorCodeSendFailed => "ACTOR_REF_ERROR_CODE_SEND_FAILED",
            ActorRefErrorCode::ActorRefErrorCodeMailboxFull => "ACTOR_REF_ERROR_CODE_MAILBOX_FULL",
            ActorRefErrorCode::ActorRefErrorCodeActorTerminated => "ACTOR_REF_ERROR_CODE_ACTOR_TERMINATED",
            ActorRefErrorCode::ActorRefErrorCodeTimeout => "ACTOR_REF_ERROR_CODE_TIMEOUT",
            ActorRefErrorCode::ActorRefErrorCodeRemoteNotImplemented => "ACTOR_REF_ERROR_CODE_REMOTE_NOT_IMPLEMENTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTOR_REF_ERROR_CODE_UNSPECIFIED" => Some(Self::ActorRefErrorCodeUnspecified),
            "ACTOR_REF_ERROR_CODE_ACTOR_NOT_FOUND" => Some(Self::ActorRefErrorCodeActorNotFound),
            "ACTOR_REF_ERROR_CODE_SEND_FAILED" => Some(Self::ActorRefErrorCodeSendFailed),
            "ACTOR_REF_ERROR_CODE_MAILBOX_FULL" => Some(Self::ActorRefErrorCodeMailboxFull),
            "ACTOR_REF_ERROR_CODE_ACTOR_TERMINATED" => Some(Self::ActorRefErrorCodeActorTerminated),
            "ACTOR_REF_ERROR_CODE_TIMEOUT" => Some(Self::ActorRefErrorCodeTimeout),
            "ACTOR_REF_ERROR_CODE_REMOTE_NOT_IMPLEMENTED" => Some(Self::ActorRefErrorCodeRemoteNotImplemented),
            _ => None,
        }
    }
}
// ============================================================================
// Resource Types (Proto-First Design)
// ============================================================================

/// Resource profile for an actor
/// Indicates what type of resources the actor primarily consumes
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceProfile {
    ResourceProfileUnspecified = 0,
    ResourceProfileCpuIntensive = 1,
    ResourceProfileMemoryIntensive = 2,
    ResourceProfileIoIntensive = 3,
    ResourceProfileNetworkIntensive = 4,
    ResourceProfileBalanced = 5,
}
impl ResourceProfile {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceProfile::ResourceProfileUnspecified => "RESOURCE_PROFILE_UNSPECIFIED",
            ResourceProfile::ResourceProfileCpuIntensive => "RESOURCE_PROFILE_CPU_INTENSIVE",
            ResourceProfile::ResourceProfileMemoryIntensive => "RESOURCE_PROFILE_MEMORY_INTENSIVE",
            ResourceProfile::ResourceProfileIoIntensive => "RESOURCE_PROFILE_IO_INTENSIVE",
            ResourceProfile::ResourceProfileNetworkIntensive => "RESOURCE_PROFILE_NETWORK_INTENSIVE",
            ResourceProfile::ResourceProfileBalanced => "RESOURCE_PROFILE_BALANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_PROFILE_UNSPECIFIED" => Some(Self::ResourceProfileUnspecified),
            "RESOURCE_PROFILE_CPU_INTENSIVE" => Some(Self::ResourceProfileCpuIntensive),
            "RESOURCE_PROFILE_MEMORY_INTENSIVE" => Some(Self::ResourceProfileMemoryIntensive),
            "RESOURCE_PROFILE_IO_INTENSIVE" => Some(Self::ResourceProfileIoIntensive),
            "RESOURCE_PROFILE_NETWORK_INTENSIVE" => Some(Self::ResourceProfileNetworkIntensive),
            "RESOURCE_PROFILE_BALANCED" => Some(Self::ResourceProfileBalanced),
            _ => None,
        }
    }
}
/// Resource violation error codes
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceViolationCode {
    ResourceViolationCodeUnspecified = 0,
    ResourceViolationCodeCpuExceeded = 1,
    ResourceViolationCodeMemoryExceeded = 2,
    ResourceViolationCodeIoExceeded = 3,
    ResourceViolationCodeNetworkExceeded = 4,
}
impl ResourceViolationCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceViolationCode::ResourceViolationCodeUnspecified => "RESOURCE_VIOLATION_CODE_UNSPECIFIED",
            ResourceViolationCode::ResourceViolationCodeCpuExceeded => "RESOURCE_VIOLATION_CODE_CPU_EXCEEDED",
            ResourceViolationCode::ResourceViolationCodeMemoryExceeded => "RESOURCE_VIOLATION_CODE_MEMORY_EXCEEDED",
            ResourceViolationCode::ResourceViolationCodeIoExceeded => "RESOURCE_VIOLATION_CODE_IO_EXCEEDED",
            ResourceViolationCode::ResourceViolationCodeNetworkExceeded => "RESOURCE_VIOLATION_CODE_NETWORK_EXCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_VIOLATION_CODE_UNSPECIFIED" => Some(Self::ResourceViolationCodeUnspecified),
            "RESOURCE_VIOLATION_CODE_CPU_EXCEEDED" => Some(Self::ResourceViolationCodeCpuExceeded),
            "RESOURCE_VIOLATION_CODE_MEMORY_EXCEEDED" => Some(Self::ResourceViolationCodeMemoryExceeded),
            "RESOURCE_VIOLATION_CODE_IO_EXCEEDED" => Some(Self::ResourceViolationCodeIoExceeded),
            "RESOURCE_VIOLATION_CODE_NETWORK_EXCEEDED" => Some(Self::ResourceViolationCodeNetworkExceeded),
            _ => None,
        }
    }
}
/// Actor health status
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActorHealthStatus {
    ActorHealthStatusUnspecified = 0,
    ActorHealthStatusHealthy = 1,
    ActorHealthStatusDegraded = 2,
    ActorHealthStatusStuck = 3,
    ActorHealthStatusFailed = 4,
}
impl ActorHealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActorHealthStatus::ActorHealthStatusUnspecified => "ACTOR_HEALTH_STATUS_UNSPECIFIED",
            ActorHealthStatus::ActorHealthStatusHealthy => "ACTOR_HEALTH_STATUS_HEALTHY",
            ActorHealthStatus::ActorHealthStatusDegraded => "ACTOR_HEALTH_STATUS_DEGRADED",
            ActorHealthStatus::ActorHealthStatusStuck => "ACTOR_HEALTH_STATUS_STUCK",
            ActorHealthStatus::ActorHealthStatusFailed => "ACTOR_HEALTH_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTOR_HEALTH_STATUS_UNSPECIFIED" => Some(Self::ActorHealthStatusUnspecified),
            "ACTOR_HEALTH_STATUS_HEALTHY" => Some(Self::ActorHealthStatusHealthy),
            "ACTOR_HEALTH_STATUS_DEGRADED" => Some(Self::ActorHealthStatusDegraded),
            "ACTOR_HEALTH_STATUS_STUCK" => Some(Self::ActorHealthStatusStuck),
            "ACTOR_HEALTH_STATUS_FAILED" => Some(Self::ActorHealthStatusFailed),
            _ => None,
        }
    }
}
include!("plexspaces.actor.v1.tonic.rs");
// @@protoc_insertion_point(module)