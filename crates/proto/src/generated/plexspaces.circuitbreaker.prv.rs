// @generated
// This file is @generated by prost-build.
/// Circuit breaker configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerConfig {
    /// Circuit breaker name (unique identifier)
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Failure detection strategy
    #[prost(enumeration="FailureStrategy", tag="2")]
    pub failure_strategy: i32,
    /// Failure threshold to open circuit
    /// - For CONSECUTIVE: Number of consecutive failures
    /// - For SLIDING_WINDOW: Number of failures in window
    /// - For ERROR_RATE: Percentage (0.0 to 1.0)
    #[prost(uint32, tag="3")]
    pub failure_threshold: u32,
    /// Success threshold to close circuit from half-open
    #[prost(uint32, tag="4")]
    pub success_threshold: u32,
    /// Timeout before transitioning to half-open
    #[prost(message, optional, tag="5")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Half-open state configuration
    #[prost(message, optional, tag="6")]
    pub half_open_config: ::core::option::Option<HalfOpenConfig>,
    /// Sliding window configuration (for SLIDING_WINDOW strategy)
    #[prost(message, optional, tag="7")]
    pub sliding_window: ::core::option::Option<SlidingWindowConfig>,
    /// Request timeout (how long to wait before marking as failure)
    #[prost(message, optional, tag="8")]
    pub request_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum concurrent requests in half-open state
    #[prost(uint32, tag="9")]
    pub max_half_open_requests: u32,
}
/// Half-open state configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HalfOpenConfig {
    /// Maximum requests to allow through in half-open state
    #[prost(uint32, tag="1")]
    pub max_requests: u32,
    /// Duration to stay in half-open state before re-evaluating
    #[prost(message, optional, tag="2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration="half_open_config::SelectionStrategy", tag="3")]
    pub selection_strategy: i32,
    /// Percentage for PERCENTAGE strategy (0.0 to 1.0)
    #[prost(double, tag="4")]
    pub sample_percentage: f64,
}
/// Nested message and enum types in `HalfOpenConfig`.
pub mod half_open_config {
    /// Strategy for selecting requests in half-open
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SelectionStrategy {
        /// First N requests
        SelectionStrategyFirstN = 0,
        /// Random sampling
        SelectionStrategySample = 1,
        /// Allow X% of requests
        SelectionStrategyPercentage = 2,
    }
    impl SelectionStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SelectionStrategy::SelectionStrategyFirstN => "SELECTION_STRATEGY_FIRST_N",
                SelectionStrategy::SelectionStrategySample => "SELECTION_STRATEGY_SAMPLE",
                SelectionStrategy::SelectionStrategyPercentage => "SELECTION_STRATEGY_PERCENTAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SELECTION_STRATEGY_FIRST_N" => Some(Self::SelectionStrategyFirstN),
                "SELECTION_STRATEGY_SAMPLE" => Some(Self::SelectionStrategySample),
                "SELECTION_STRATEGY_PERCENTAGE" => Some(Self::SelectionStrategyPercentage),
                _ => None,
            }
        }
    }
}
/// Sliding window configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlidingWindowConfig {
    /// Window size (number of requests to track)
    #[prost(uint32, tag="1")]
    pub window_size: u32,
    /// Window duration (time-based window)
    #[prost(message, optional, tag="2")]
    pub window_duration: ::core::option::Option<::prost_types::Duration>,
    /// Minimum requests before circuit can trip
    #[prost(uint32, tag="3")]
    pub minimum_requests: u32,
}
/// Circuit breaker metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerMetrics {
    /// Circuit breaker name
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Current state
    #[prost(enumeration="CircuitState", tag="2")]
    pub state: i32,
    /// Total requests
    #[prost(uint64, tag="3")]
    pub total_requests: u64,
    /// Successful requests
    #[prost(uint64, tag="4")]
    pub successful_requests: u64,
    /// Failed requests
    #[prost(uint64, tag="5")]
    pub failed_requests: u64,
    /// Rejected requests (circuit open)
    #[prost(uint64, tag="6")]
    pub rejected_requests: u64,
    /// Current error rate (0.0 to 1.0)
    #[prost(double, tag="7")]
    pub error_rate: f64,
    /// Consecutive failures
    #[prost(uint32, tag="8")]
    pub consecutive_failures: u32,
    /// Consecutive successes (in half-open)
    #[prost(uint32, tag="9")]
    pub consecutive_successes: u32,
    /// Time circuit opened
    #[prost(message, optional, tag="10")]
    pub last_opened: ::core::option::Option<::prost_types::Timestamp>,
    /// Time circuit closed
    #[prost(message, optional, tag="11")]
    pub last_closed: ::core::option::Option<::prost_types::Timestamp>,
    /// Duration in current state
    #[prost(message, optional, tag="12")]
    pub time_in_state: ::core::option::Option<::prost_types::Duration>,
    /// Number of times circuit has opened
    #[prost(uint64, tag="13")]
    pub trip_count: u64,
    /// Average response time (milliseconds)
    #[prost(uint64, tag="14")]
    pub avg_response_time_ms: u64,
    /// Sliding window metrics (if applicable)
    #[prost(message, optional, tag="15")]
    pub sliding_window_metrics: ::core::option::Option<SlidingWindowMetrics>,
}
/// Sliding window metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlidingWindowMetrics {
    /// Requests in current window
    #[prost(uint32, tag="1")]
    pub window_requests: u32,
    /// Failures in current window
    #[prost(uint32, tag="2")]
    pub window_failures: u32,
    /// Window start time
    #[prost(message, optional, tag="3")]
    pub window_start: ::core::option::Option<::prost_types::Timestamp>,
    /// Window end time
    #[prost(message, optional, tag="4")]
    pub window_end: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request result for circuit breaker tracking
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestResult {
    /// Request ID (for tracking)
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
    /// Success or failure
    #[prost(bool, tag="2")]
    pub success: bool,
    /// Error message (if failed)
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
    /// Response time (milliseconds)
    #[prost(uint64, tag="4")]
    pub response_time_ms: u64,
    /// Request timestamp
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Custom metadata
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Circuit breaker event
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerEvent {
    #[prost(enumeration="circuit_breaker_event::EventType", tag="1")]
    pub event_type: i32,
    #[prost(string, tag="2")]
    pub circuit_name: ::prost::alloc::string::String,
    #[prost(enumeration="CircuitState", tag="3")]
    pub previous_state: i32,
    #[prost(enumeration="CircuitState", tag="4")]
    pub new_state: i32,
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="6")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag="7")]
    pub metrics: ::core::option::Option<CircuitBreakerMetrics>,
}
/// Nested message and enum types in `CircuitBreakerEvent`.
pub mod circuit_breaker_event {
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EventType {
        EventTypeStateChanged = 0,
        EventTypeThresholdExceeded = 1,
        EventTypeRecoveryStarted = 2,
        EventTypeRecoverySucceeded = 3,
        EventTypeRecoveryFailed = 4,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EventType::EventTypeStateChanged => "EVENT_TYPE_STATE_CHANGED",
                EventType::EventTypeThresholdExceeded => "EVENT_TYPE_THRESHOLD_EXCEEDED",
                EventType::EventTypeRecoveryStarted => "EVENT_TYPE_RECOVERY_STARTED",
                EventType::EventTypeRecoverySucceeded => "EVENT_TYPE_RECOVERY_SUCCEEDED",
                EventType::EventTypeRecoveryFailed => "EVENT_TYPE_RECOVERY_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_STATE_CHANGED" => Some(Self::EventTypeStateChanged),
                "EVENT_TYPE_THRESHOLD_EXCEEDED" => Some(Self::EventTypeThresholdExceeded),
                "EVENT_TYPE_RECOVERY_STARTED" => Some(Self::EventTypeRecoveryStarted),
                "EVENT_TYPE_RECOVERY_SUCCEEDED" => Some(Self::EventTypeRecoverySucceeded),
                "EVENT_TYPE_RECOVERY_FAILED" => Some(Self::EventTypeRecoveryFailed),
                _ => None,
            }
        }
    }
}
/// CreateCircuitBreaker request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCircuitBreakerRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<CircuitBreakerConfig>,
}
/// CreateCircuitBreaker response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCircuitBreakerResponse {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
    #[prost(enumeration="CircuitState", tag="2")]
    pub initial_state: i32,
}
/// ExecuteRequest request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteRequestRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
/// ExecuteRequest response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteRequestResponse {
    #[prost(oneof="execute_request_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<execute_request_response::Result>,
}
/// Nested message and enum types in `ExecuteRequestResponse`.
pub mod execute_request_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(bool, tag="1")]
        Allowed(bool),
        #[prost(message, tag="2")]
        CircuitOpen(super::CircuitOpenError),
    }
}
/// Circuit open error
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitOpenError {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub retry_after: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub metrics: ::core::option::Option<CircuitBreakerMetrics>,
}
/// RecordResult request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordResultRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub result: ::core::option::Option<RequestResult>,
}
/// RecordResult response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordResultResponse {
    #[prost(enumeration="CircuitState", tag="1")]
    pub new_state: i32,
    #[prost(bool, tag="2")]
    pub state_changed: bool,
}
/// TripCircuit request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TripCircuitRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
}
/// TripCircuit response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TripCircuitResponse {
    #[prost(bool, tag="1")]
    pub tripped: bool,
    #[prost(enumeration="CircuitState", tag="2")]
    pub previous_state: i32,
}
/// ResetCircuit request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetCircuitRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
}
/// ResetCircuit response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetCircuitResponse {
    #[prost(bool, tag="1")]
    pub reset: bool,
    #[prost(enumeration="CircuitState", tag="2")]
    pub previous_state: i32,
}
/// GetState request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
}
/// GetState response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    #[prost(enumeration="CircuitState", tag="1")]
    pub state: i32,
    #[prost(message, optional, tag="2")]
    pub state_since: ::core::option::Option<::prost_types::Timestamp>,
}
/// GetMetrics request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
}
/// GetMetrics response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsResponse {
    #[prost(message, optional, tag="1")]
    pub metrics: ::core::option::Option<CircuitBreakerMetrics>,
}
/// WatchEvents request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchEventsRequest {
    /// Empty for all circuits
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
}
/// ListCircuitBreakers request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCircuitBreakersRequest {
    /// Optional filter by state
    #[prost(enumeration="CircuitState", repeated, tag="1")]
    pub states: ::prost::alloc::vec::Vec<i32>,
}
/// ListCircuitBreakers response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCircuitBreakersResponse {
    #[prost(message, repeated, tag="1")]
    pub circuits: ::prost::alloc::vec::Vec<CircuitBreakerInfo>,
}
/// Circuit breaker info
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerInfo {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration="CircuitState", tag="2")]
    pub state: i32,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<CircuitBreakerConfig>,
    #[prost(message, optional, tag="4")]
    pub metrics: ::core::option::Option<CircuitBreakerMetrics>,
}
/// DeleteCircuitBreaker request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCircuitBreakerRequest {
    #[prost(string, tag="1")]
    pub circuit_name: ::prost::alloc::string::String,
}
/// DeleteCircuitBreaker response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCircuitBreakerResponse {
    #[prost(bool, tag="1")]
    pub deleted: bool,
}
/// Circuit breaker state
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CircuitState {
    /// Closed: Normal operation, requests pass through
    CircuitStateClosed = 0,
    /// Open: Circuit is tripped, requests fail fast
    CircuitStateOpen = 1,
    /// Half-Open: Testing if service recovered, limited requests allowed
    CircuitStateHalfOpen = 2,
    /// Disabled: Circuit breaker disabled, all requests pass
    CircuitStateDisabled = 3,
}
impl CircuitState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CircuitState::CircuitStateClosed => "CIRCUIT_STATE_CLOSED",
            CircuitState::CircuitStateOpen => "CIRCUIT_STATE_OPEN",
            CircuitState::CircuitStateHalfOpen => "CIRCUIT_STATE_HALF_OPEN",
            CircuitState::CircuitStateDisabled => "CIRCUIT_STATE_DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CIRCUIT_STATE_CLOSED" => Some(Self::CircuitStateClosed),
            "CIRCUIT_STATE_OPEN" => Some(Self::CircuitStateOpen),
            "CIRCUIT_STATE_HALF_OPEN" => Some(Self::CircuitStateHalfOpen),
            "CIRCUIT_STATE_DISABLED" => Some(Self::CircuitStateDisabled),
            _ => None,
        }
    }
}
/// Failure detection strategy
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FailureStrategy {
    /// Count consecutive failures
    FailureStrategyConsecutive = 0,
    /// Count failures in sliding window
    FailureStrategySlidingWindow = 1,
    /// Error rate percentage
    FailureStrategyErrorRate = 2,
    /// Custom strategy
    FailureStrategyCustom = 3,
}
impl FailureStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FailureStrategy::FailureStrategyConsecutive => "FAILURE_STRATEGY_CONSECUTIVE",
            FailureStrategy::FailureStrategySlidingWindow => "FAILURE_STRATEGY_SLIDING_WINDOW",
            FailureStrategy::FailureStrategyErrorRate => "FAILURE_STRATEGY_ERROR_RATE",
            FailureStrategy::FailureStrategyCustom => "FAILURE_STRATEGY_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FAILURE_STRATEGY_CONSECUTIVE" => Some(Self::FailureStrategyConsecutive),
            "FAILURE_STRATEGY_SLIDING_WINDOW" => Some(Self::FailureStrategySlidingWindow),
            "FAILURE_STRATEGY_ERROR_RATE" => Some(Self::FailureStrategyErrorRate),
            "FAILURE_STRATEGY_CUSTOM" => Some(Self::FailureStrategyCustom),
            _ => None,
        }
    }
}
include!("plexspaces.circuitbreaker.prv.tonic.rs");
// @@protoc_insertion_point(module)