// @generated
// This file is @generated by prost-build.
/// Get request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequest {
    /// Key to get
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Get response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResponse {
    /// Value if key exists
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Whether key exists
    #[prost(bool, tag="2")]
    pub exists: bool,
}
/// Put request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRequest {
    /// Key to put
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Value to store
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="3")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Put response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// Delete request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    /// Key to delete
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Delete response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteResponse {
    /// Whether key was deleted (false if key didn't exist)
    #[prost(bool, tag="1")]
    pub deleted: bool,
}
/// Exists request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistsRequest {
    /// Key to check
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Exists response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistsResponse {
    /// Whether key exists
    #[prost(bool, tag="1")]
    pub exists: bool,
}
/// List request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRequest {
    /// Prefix to list keys with
    #[prost(string, tag="1")]
    pub prefix: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// List response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResponse {
    /// List of keys matching prefix
    #[prost(string, repeated, tag="1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MultiGet request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiGetRequest {
    /// Keys to get
    #[prost(string, repeated, tag="1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// MultiGet response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiGetResponse {
    /// Values (same order as request, None for missing keys)
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<KeyValueEntry>,
}
/// Key-value entry
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValueEntry {
    /// Key
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Value if exists
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Whether key exists
    #[prost(bool, tag="3")]
    pub exists: bool,
}
/// MultiPut request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiPutRequest {
    /// Key-value pairs to put
    #[prost(message, repeated, tag="1")]
    pub pairs: ::prost::alloc::vec::Vec<KeyValuePair>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Key-value pair
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValuePair {
    /// Key
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Value
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// MultiPut response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiPutResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// PutWithTtl request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutWithTtlRequest {
    /// Key to put
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Value to store
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Time-to-live
    #[prost(message, optional, tag="3")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="4")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// PutWithTtl response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutWithTtlResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// RefreshTtl request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTtlRequest {
    /// Key to refresh
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// New TTL
    #[prost(message, optional, tag="2")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="3")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// RefreshTtl response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTtlResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// GetTtl request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTtlRequest {
    /// Key to check
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// GetTtl response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTtlResponse {
    /// TTL remaining if key exists with TTL
    #[prost(message, optional, tag="1")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
    /// Whether key exists
    #[prost(bool, tag="2")]
    pub exists: bool,
}
/// Cas request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CasRequest {
    /// Key for CAS operation
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Expected value (None means key must not exist)
    ///
    /// Empty bytes = None
    #[prost(bytes="vec", tag="2")]
    pub expected_value: ::prost::alloc::vec::Vec<u8>,
    /// New value
    #[prost(bytes="vec", tag="3")]
    pub new_value: ::prost::alloc::vec::Vec<u8>,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="4")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Cas response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CasResponse {
    /// Whether swap succeeded
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// Increment request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncrementRequest {
    /// Key for counter
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Delta to add
    #[prost(int64, tag="2")]
    pub delta: i64,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="3")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Increment response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncrementResponse {
    /// New value after increment
    #[prost(int64, tag="1")]
    pub value: i64,
}
/// Decrement request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecrementRequest {
    /// Key for counter
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Delta to subtract
    #[prost(int64, tag="2")]
    pub delta: i64,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="3")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// Decrement response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecrementResponse {
    /// New value after decrement
    #[prost(int64, tag="1")]
    pub value: i64,
}
/// ClearPrefix request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearPrefixRequest {
    /// Prefix to clear
    #[prost(string, tag="1")]
    pub prefix: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// ClearPrefix response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearPrefixResponse {
    /// Number of keys deleted
    #[prost(uint64, tag="1")]
    pub deleted_count: u64,
}
/// CountPrefix request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountPrefixRequest {
    /// Prefix to count
    #[prost(string, tag="1")]
    pub prefix: ::prost::alloc::string::String,
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="2")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// CountPrefix response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountPrefixResponse {
    /// Number of keys with prefix
    #[prost(uint64, tag="1")]
    pub count: u64,
}
/// GetStats request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatsRequest {
    /// Request context (contains tenant_id, namespace, user_id)
    #[prost(message, optional, tag="1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
}
/// GetStats response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatsResponse {
    /// Total number of keys
    #[prost(uint64, tag="1")]
    pub total_keys: u64,
    /// Total size in bytes (approximate)
    #[prost(uint64, tag="2")]
    pub total_size_bytes: u64,
    /// Backend type (e.g., "InMemory", "SQLite", "Redis", "PostgreSQL")
    #[prost(string, tag="3")]
    pub backend_type: ::prost::alloc::string::String,
}
include!("plexspaces.keyvalue.v1.tonic.rs");
// @@protoc_insertion_point(module)