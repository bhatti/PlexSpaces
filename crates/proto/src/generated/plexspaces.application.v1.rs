// @generated
// This file is @generated by prost-build.
/// Application configuration from TOML \[[applications]\] section.
///
/// ## Purpose
/// Configuration for a single application loaded from TOML or API.
///
/// ## TOML Example
/// ```toml
/// \[[applications]\]
/// name = "genomics-coordinator"
/// version = "0.1.0"
/// enabled = true
/// auto_start = true
/// shutdown_timeout_seconds = 60
/// shutdown_strategy = "graceful"
/// dependencies = \[\]
/// ```
///
/// ## Design Notes
/// - enabled = false prevents application from loading
/// - auto_start = false allows manual start via API (future)
/// - dependencies ensures start order (dependencies start first)
/// - metadata allows custom tags/labels for application discovery
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationConfig {
    /// Application name (unique identifier within node)
    ///
    /// Examples: "genomics-coordinator", "finance-risk-workers"
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Application version (semantic versioning)
    ///
    /// Examples: "0.1.0", "1.2.3"
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    /// Whether application is enabled (false = skip loading)
    ///
    /// Default: true
    #[prost(bool, tag="3")]
    pub enabled: bool,
    /// Whether to start application automatically on node boot
    ///
    /// Default: true
    /// Future: false allows manual start via ApplicationService API
    #[prost(bool, tag="4")]
    pub auto_start: bool,
    /// Shutdown timeout (force kill if exceeded)
    ///
    /// Default: 60 seconds
    #[prost(message, optional, tag="5")]
    pub shutdown_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Shutdown strategy (graceful or immediate)
    ///
    /// Default: GRACEFUL
    #[prost(enumeration="ShutdownStrategy", tag="6")]
    pub shutdown_strategy: i32,
    /// Application dependencies (start these first)
    ///
    /// Example: \["database-app", "cache-app"\]
    /// These applications must start successfully before this app starts
    #[prost(string, repeated, tag="7")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Application metadata (tags, labels, annotations)
    ///
    /// Examples:
    /// - environment: "production"
    /// - team: "genomics"
    /// - criticality: "high"
    #[prost(message, optional, tag="8")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
}
/// Application specification (Erlang/OTP .app file equivalent)
///
/// ## Purpose
/// Complete definition of a PlexSpaces application. Analogous to
/// Erlang .app files, defines metadata, dependencies, supervision tree.
///
/// ## Why This Exists
/// - Reusable components with clear boundaries
/// - Dependency management (start in correct order)
/// - Declarative supervision tree
/// - Supports both library and active applications
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationSpec {
    /// Application metadata
    ///
    /// e.g., "byzantine-generals"
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Semantic version (e.g., "0.1.0")
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    /// Human-readable description
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Application type
    #[prost(enumeration="ApplicationType", tag="4")]
    pub r#type: i32,
    /// Dependencies (other applications that must start first)
    /// e.g., \["plexspaces-core", "plexspaces-tuplespace"\]
    #[prost(string, repeated, tag="5")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Application-level environment variables
    #[prost(map="string, string", tag="6")]
    pub env: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Supervision tree (only for active applications)
    #[prost(message, optional, tag="7")]
    pub supervisor: ::core::option::Option<SupervisorSpec>,
}
/// Supervisor specification (Erlang/OTP supervisor)
///
/// ## Purpose
/// Defines a supervision tree node. Supervisors manage child processes
/// (workers or other supervisors) with fault tolerance strategies.
///
/// ## Why This Exists
/// - Fault tolerance (automatic restarts)
/// - Organized process hierarchy
/// - Declarative restart strategies
/// - Local supervision only (simpler than distributed)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisorSpec {
    /// Supervision strategy
    #[prost(enumeration="SupervisionStrategy", tag="1")]
    pub strategy: i32,
    /// Maximum restarts allowed
    #[prost(uint32, tag="2")]
    pub max_restarts: u32,
    /// Time window for restart counting (seconds)
    #[prost(message, optional, tag="3")]
    pub max_restart_window: ::core::option::Option<::prost_types::Duration>,
    /// Child processes
    #[prost(message, repeated, tag="4")]
    pub children: ::prost::alloc::vec::Vec<ChildSpec>,
}
/// Child process specification
///
/// ## Purpose
/// Defines a child process (worker or supervisor) managed by a supervisor.
///
/// ## Why This Exists
/// - Clear child identity and lifecycle
/// - Restart policy per child
/// - Shutdown timeout specification
/// - Support for nested supervisors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildSpec {
    /// Unique child identifier
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Child type (worker or supervisor)
    #[prost(enumeration="ChildType", tag="2")]
    pub r#type: i32,
    /// Arguments to pass to start function
    #[prost(map="string, string", tag="3")]
    pub args: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Restart policy
    #[prost(enumeration="RestartPolicy", tag="4")]
    pub restart: i32,
    /// Shutdown timeout
    #[prost(message, optional, tag="5")]
    pub shutdown_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Nested supervisor (if type=SUPERVISOR)
    #[prost(message, optional, tag="6")]
    pub supervisor: ::core::option::Option<SupervisorSpec>,
    /// Facet configuration (for automatic attachment during actor creation)
    /// Facets are attached in priority order (high priority first) before actor.init() is called
    /// All facets are automatically restored during supervisor restart
    /// Phase 1: Unified Lifecycle - Multiple facets support
    #[prost(message, repeated, tag="7")]
    pub facets: ::prost::alloc::vec::Vec<super::super::common::v1::Facet>,
}
/// Application instance (runtime representation).
///
/// ## Purpose
/// Runtime state of a running application instance.
///
/// ## Design Notes
/// - config: Static configuration from TOML
/// - state: Current lifecycle state
/// - health: Current health status
/// - started_at: When application started
/// - statistics: Runtime metrics (messages processed, actors spawned, etc.)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Application {
    /// Application configuration
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<ApplicationConfig>,
    /// Current lifecycle state
    #[prost(enumeration="ApplicationState", tag="2")]
    pub state: i32,
    /// Current health status
    #[prost(enumeration="HealthStatus", tag="3")]
    pub health: i32,
    /// When application started
    #[prost(message, optional, tag="4")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Application statistics (runtime metrics)
    #[prost(message, optional, tag="5")]
    pub statistics: ::core::option::Option<ApplicationStatistics>,
}
/// Application runtime statistics.
///
/// ## Purpose
/// Track runtime metrics for monitoring and debugging.
///
/// ## Design Notes
/// - Counters are cumulative since application start
/// - Gauges represent current state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationStatistics {
    /// Number of actors spawned by this application
    #[prost(uint64, tag="1")]
    pub actors_spawned: u64,
    /// Number of actors currently active
    #[prost(uint64, tag="2")]
    pub actors_active: u64,
    /// Number of messages processed
    #[prost(uint64, tag="3")]
    pub messages_processed: u64,
    /// Number of errors encountered
    #[prost(uint64, tag="4")]
    pub errors_total: u64,
    /// Number of restarts (if supervised)
    #[prost(uint32, tag="5")]
    pub restarts: u32,
}
/// Application state (runtime) - for deployment service
///
/// ## Purpose
/// Represents runtime state of a running application.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationRuntimeState {
    /// Application name
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Current state
    #[prost(enumeration="ApplicationStatus", tag="2")]
    pub status: i32,
    /// Start timestamp
    #[prost(int64, tag="3")]
    pub start_timestamp_ms: i64,
    /// Root supervisor PID (if active application)
    #[prost(string, optional, tag="4")]
    pub supervisor_pid: ::core::option::Option<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map="string, string", tag="5")]
    pub env: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Deploy application request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployApplicationRequest {
    /// Application identifier (unique per node)
    #[prost(string, tag="1")]
    pub application_id: ::prost::alloc::string::String,
    /// Application name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Application version
    #[prost(string, tag="3")]
    pub version: ::prost::alloc::string::String,
    /// WASM module (if WASM application)
    /// If provided, application code is loaded from WASM.
    /// If not provided, application must be pre-registered (native Rust).
    #[prost(message, optional, tag="4")]
    pub wasm_module: ::core::option::Option<super::super::wasm::v1::WasmModule>,
    /// Application configuration
    /// Defines supervision tree, dependencies, environment variables, etc.
    #[prost(message, optional, tag="5")]
    pub config: ::core::option::Option<ApplicationSpec>,
    /// Release configuration (optional)
    /// If provided, application is deployed with release-level settings.
    /// Similar to how applications are loaded from release.toml.
    /// If not provided, uses defaults or application-level config only.
    #[prost(message, optional, tag="6")]
    pub release_config: ::core::option::Option<super::super::node::v1::ReleaseSpec>,
    /// Initial state (optional, for stateful applications)
    /// Passed to application's start() method.
    #[prost(bytes="vec", tag="7")]
    pub initial_state: ::prost::alloc::vec::Vec<u8>,
}
/// Deploy application response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployApplicationResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Application ID (may differ from request if auto-generated)
    #[prost(string, tag="2")]
    pub application_id: ::prost::alloc::string::String,
    /// Application status after deployment
    #[prost(enumeration="ApplicationStatus", tag="3")]
    pub status: i32,
    /// Error details (if success=false)
    #[prost(string, optional, tag="4")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
/// Undeploy application request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployApplicationRequest {
    /// Application ID to undeploy
    #[prost(string, tag="1")]
    pub application_id: ::prost::alloc::string::String,
    /// Graceful shutdown timeout (optional, uses app config default if not provided)
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Undeploy application response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployApplicationResponse {
    /// Success flag
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Error details (if success=false)
    #[prost(string, optional, tag="2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
/// List applications request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApplicationsRequest {
    /// Filter by status (optional, empty = all applications)
    #[prost(enumeration="ApplicationStatus", optional, tag="1")]
    pub status_filter: ::core::option::Option<i32>,
}
/// List applications response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApplicationsResponse {
    /// List of deployed applications
    #[prost(message, repeated, tag="1")]
    pub applications: ::prost::alloc::vec::Vec<ApplicationInfo>,
}
/// Application information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationInfo {
    /// Application ID
    #[prost(string, tag="1")]
    pub application_id: ::prost::alloc::string::String,
    /// Application name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Application version
    #[prost(string, tag="3")]
    pub version: ::prost::alloc::string::String,
    /// Current status
    #[prost(enumeration="ApplicationStatus", tag="4")]
    pub status: i32,
    /// When the application was deployed
    #[prost(message, optional, tag="5")]
    pub deployed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Application metrics (optional)
    #[prost(message, optional, tag="6")]
    pub metrics: ::core::option::Option<ApplicationMetrics>,
}
/// Application metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationMetrics {
    /// Number of actors in the application
    #[prost(uint32, tag="1")]
    pub actor_count: u32,
    /// Number of supervisors
    #[prost(uint32, tag="2")]
    pub supervisor_count: u32,
    /// Uptime in seconds
    #[prost(uint64, tag="3")]
    pub uptime_seconds: u64,
}
/// Get application status request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApplicationStatusRequest {
    /// Application ID
    #[prost(string, tag="1")]
    pub application_id: ::prost::alloc::string::String,
}
/// Get application status response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApplicationStatusResponse {
    /// Application information
    #[prost(message, optional, tag="1")]
    pub application: ::core::option::Option<ApplicationInfo>,
    /// Detailed application state
    #[prost(message, optional, tag="2")]
    pub state: ::core::option::Option<ApplicationRuntimeState>,
    /// Error if application not found
    #[prost(string, optional, tag="3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request to start an application (legacy).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartApplicationRequest {
    /// Application name to start
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
/// Response from starting an application (legacy).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartApplicationResponse {
    /// Started application instance
    #[prost(message, optional, tag="1")]
    pub application: ::core::option::Option<Application>,
}
/// Request to stop an application (legacy).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopApplicationRequest {
    /// Application name to stop
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Force immediate shutdown (ignore graceful strategy)
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// Response from stopping an application (legacy).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopApplicationResponse {
    /// Stopped application instance
    #[prost(message, optional, tag="1")]
    pub application: ::core::option::Option<Application>,
}
/// Application type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplicationType {
    /// Unspecified (invalid)
    ApplicationTypeUnspecified = 0,
    /// Library application (just modules, no processes)
    /// e.g., plexspaces-core
    ApplicationTypeLibrary = 1,
    /// Active application (has supervision tree and processes)
    /// e.g., byzantine-generals, heat-diffusion
    ApplicationTypeActive = 2,
}
impl ApplicationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ApplicationType::ApplicationTypeUnspecified => "APPLICATION_TYPE_UNSPECIFIED",
            ApplicationType::ApplicationTypeLibrary => "APPLICATION_TYPE_LIBRARY",
            ApplicationType::ApplicationTypeActive => "APPLICATION_TYPE_ACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPLICATION_TYPE_UNSPECIFIED" => Some(Self::ApplicationTypeUnspecified),
            "APPLICATION_TYPE_LIBRARY" => Some(Self::ApplicationTypeLibrary),
            "APPLICATION_TYPE_ACTIVE" => Some(Self::ApplicationTypeActive),
            _ => None,
        }
    }
}
/// Supervision strategy (Erlang/OTP)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SupervisionStrategy {
    /// Unspecified (default to one_for_one)
    SupervisionStrategyUnspecified = 0,
    /// One-for-One: Only restart failed child
    /// If child A crashes, restart only A
    SupervisionStrategyOneForOne = 1,
    /// One-for-All: Restart all children if one fails
    /// If child A crashes, restart A, B, C
    SupervisionStrategyOneForAll = 2,
    /// Rest-for-One: Restart failed child and those started after it
    /// If child B crashes (started after A), restart B, C (not A)
    SupervisionStrategyRestForOne = 3,
}
impl SupervisionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SupervisionStrategy::SupervisionStrategyUnspecified => "SUPERVISION_STRATEGY_UNSPECIFIED",
            SupervisionStrategy::SupervisionStrategyOneForOne => "SUPERVISION_STRATEGY_ONE_FOR_ONE",
            SupervisionStrategy::SupervisionStrategyOneForAll => "SUPERVISION_STRATEGY_ONE_FOR_ALL",
            SupervisionStrategy::SupervisionStrategyRestForOne => "SUPERVISION_STRATEGY_REST_FOR_ONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUPERVISION_STRATEGY_UNSPECIFIED" => Some(Self::SupervisionStrategyUnspecified),
            "SUPERVISION_STRATEGY_ONE_FOR_ONE" => Some(Self::SupervisionStrategyOneForOne),
            "SUPERVISION_STRATEGY_ONE_FOR_ALL" => Some(Self::SupervisionStrategyOneForAll),
            "SUPERVISION_STRATEGY_REST_FOR_ONE" => Some(Self::SupervisionStrategyRestForOne),
            _ => None,
        }
    }
}
/// Child type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChildType {
    /// Unspecified (invalid)
    ChildTypeUnspecified = 0,
    /// Worker process (actor)
    ChildTypeWorker = 1,
    /// Supervisor process (manages other children)
    ChildTypeSupervisor = 2,
}
impl ChildType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChildType::ChildTypeUnspecified => "CHILD_TYPE_UNSPECIFIED",
            ChildType::ChildTypeWorker => "CHILD_TYPE_WORKER",
            ChildType::ChildTypeSupervisor => "CHILD_TYPE_SUPERVISOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHILD_TYPE_UNSPECIFIED" => Some(Self::ChildTypeUnspecified),
            "CHILD_TYPE_WORKER" => Some(Self::ChildTypeWorker),
            "CHILD_TYPE_SUPERVISOR" => Some(Self::ChildTypeSupervisor),
            _ => None,
        }
    }
}
/// Restart policy (Erlang/OTP)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RestartPolicy {
    /// Unspecified (default to permanent)
    RestartPolicyUnspecified = 0,
    /// Permanent: Always restart on failure
    /// Use for critical long-running processes
    RestartPolicyPermanent = 1,
    /// Transient: Restart only if abnormal exit (error)
    /// Don't restart if normal exit (shutdown)
    /// Use for tasks that may complete successfully
    RestartPolicyTransient = 2,
    /// Temporary: Never restart
    /// Use for one-shot tasks
    RestartPolicyTemporary = 3,
}
impl RestartPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RestartPolicy::RestartPolicyUnspecified => "RESTART_POLICY_UNSPECIFIED",
            RestartPolicy::RestartPolicyPermanent => "RESTART_POLICY_PERMANENT",
            RestartPolicy::RestartPolicyTransient => "RESTART_POLICY_TRANSIENT",
            RestartPolicy::RestartPolicyTemporary => "RESTART_POLICY_TEMPORARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESTART_POLICY_UNSPECIFIED" => Some(Self::RestartPolicyUnspecified),
            "RESTART_POLICY_PERMANENT" => Some(Self::RestartPolicyPermanent),
            "RESTART_POLICY_TRANSIENT" => Some(Self::RestartPolicyTransient),
            "RESTART_POLICY_TEMPORARY" => Some(Self::RestartPolicyTemporary),
            _ => None,
        }
    }
}
/// Shutdown strategy for application.
///
/// ## Purpose
/// Determines how application shutdown is handled.
///
/// ## Strategies
/// - GRACEFUL: Wait for in-flight work to complete (up to timeout)
/// - IMMEDIATE: Stop immediately without draining work
///
/// ## Design Notes
/// - Default is GRACEFUL for production safety
/// - IMMEDIATE useful for dev/test or when work is not critical
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShutdownStrategy {
    /// Unspecified (defaults to GRACEFUL)
    ShutdownStrategyUnspecified = 0,
    /// Wait for in-flight work to complete (up to shutdown_timeout)
    ///
    /// Shutdown sequence:
    /// 1. Stop accepting new work
    /// 2. Drain in-flight messages/tasks
    /// 3. Save durable state (if applicable)
    /// 4. Stop supervision tree and actors
    /// 5. Disconnect from external services
    ShutdownStrategyGraceful = 1,
    /// Stop immediately without draining work
    ///
    /// Shutdown sequence:
    /// 1. Stop supervision tree immediately
    /// 2. Terminate actors (may lose in-flight work)
    /// 3. Exit
    ShutdownStrategyImmediate = 2,
}
impl ShutdownStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ShutdownStrategy::ShutdownStrategyUnspecified => "SHUTDOWN_STRATEGY_UNSPECIFIED",
            ShutdownStrategy::ShutdownStrategyGraceful => "SHUTDOWN_STRATEGY_GRACEFUL",
            ShutdownStrategy::ShutdownStrategyImmediate => "SHUTDOWN_STRATEGY_IMMEDIATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHUTDOWN_STRATEGY_UNSPECIFIED" => Some(Self::ShutdownStrategyUnspecified),
            "SHUTDOWN_STRATEGY_GRACEFUL" => Some(Self::ShutdownStrategyGraceful),
            "SHUTDOWN_STRATEGY_IMMEDIATE" => Some(Self::ShutdownStrategyImmediate),
            _ => None,
        }
    }
}
/// Health status for application.
///
/// ## Purpose
/// Represents the health state of an application for monitoring and orchestration.
/// Used for Kubernetes liveness/readiness probes and load balancing decisions.
///
/// ## States
/// - HEALTHY: Application functioning normally (ready to accept traffic)
/// - DEGRADED: Running but reduced capacity (e.g., some workers down, still accepts traffic)
/// - UNHEALTHY: Not functioning (should trigger restart/failover, do not route traffic)
///
/// ## Design Notes
/// - Maps to Kubernetes probe states (healthy = ready, unhealthy = not ready)
/// - DEGRADED allows partial operation (some failures tolerated)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    /// Unspecified (should not be used, defaults to UNHEALTHY for safety)
    HealthStatusUnspecified = 0,
    /// Application is functioning normally
    ///
    /// - All critical components running
    /// - Can accept full workload
    /// - Ready for traffic
    HealthStatusHealthy = 1,
    /// Application is running but with reduced capacity
    ///
    /// - Some non-critical components failed
    /// - Still accepting work but at reduced rate
    /// - Example: 2 of 5 workers down (still functional)
    HealthStatusDegraded = 2,
    /// Application is not functioning
    ///
    /// - Critical components failed
    /// - Cannot process work reliably
    /// - Should trigger restart or failover
    HealthStatusUnhealthy = 3,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HealthStatus::HealthStatusUnspecified => "HEALTH_STATUS_UNSPECIFIED",
            HealthStatus::HealthStatusHealthy => "HEALTH_STATUS_HEALTHY",
            HealthStatus::HealthStatusDegraded => "HEALTH_STATUS_DEGRADED",
            HealthStatus::HealthStatusUnhealthy => "HEALTH_STATUS_UNHEALTHY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::HealthStatusUnspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::HealthStatusHealthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::HealthStatusDegraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::HealthStatusUnhealthy),
            _ => None,
        }
    }
}
/// Application state in lifecycle.
///
/// ## Purpose
/// Track application lifecycle state for management and monitoring.
///
/// ## State Transitions
/// ```
/// CREATED -> STARTING -> RUNNING -> STOPPING -> STOPPED
///                           |
///                           +-> FAILED (restart or stop)
/// ```
///
/// ## Design Notes
/// - CREATED: Config loaded, not yet started
/// - STARTING: start() called, spawning resources
/// - RUNNING: Fully operational
/// - STOPPING: stop() called, draining work
/// - STOPPED: Cleanly shut down
/// - FAILED: Crashed or failed health checks
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplicationState {
    /// Unspecified
    ApplicationStateUnspecified = 0,
    /// Configuration loaded, not yet started
    ApplicationStateCreated = 1,
    /// start() called, spawning supervision tree and actors
    ApplicationStateStarting = 2,
    /// Fully operational and processing work
    ApplicationStateRunning = 3,
    /// stop() called, draining in-flight work
    ApplicationStateStopping = 4,
    /// Cleanly shut down
    ApplicationStateStopped = 5,
    /// Crashed or failed health checks (may restart)
    ApplicationStateFailed = 6,
}
impl ApplicationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ApplicationState::ApplicationStateUnspecified => "APPLICATION_STATE_UNSPECIFIED",
            ApplicationState::ApplicationStateCreated => "APPLICATION_STATE_CREATED",
            ApplicationState::ApplicationStateStarting => "APPLICATION_STATE_STARTING",
            ApplicationState::ApplicationStateRunning => "APPLICATION_STATE_RUNNING",
            ApplicationState::ApplicationStateStopping => "APPLICATION_STATE_STOPPING",
            ApplicationState::ApplicationStateStopped => "APPLICATION_STATE_STOPPED",
            ApplicationState::ApplicationStateFailed => "APPLICATION_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPLICATION_STATE_UNSPECIFIED" => Some(Self::ApplicationStateUnspecified),
            "APPLICATION_STATE_CREATED" => Some(Self::ApplicationStateCreated),
            "APPLICATION_STATE_STARTING" => Some(Self::ApplicationStateStarting),
            "APPLICATION_STATE_RUNNING" => Some(Self::ApplicationStateRunning),
            "APPLICATION_STATE_STOPPING" => Some(Self::ApplicationStateStopping),
            "APPLICATION_STATE_STOPPED" => Some(Self::ApplicationStateStopped),
            "APPLICATION_STATE_FAILED" => Some(Self::ApplicationStateFailed),
            _ => None,
        }
    }
}
/// Application status (for deployment service)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplicationStatus {
    /// Unspecified
    ApplicationStatusUnspecified = 0,
    /// Loading (reading config)
    ApplicationStatusLoading = 1,
    /// Starting (calling start())
    ApplicationStatusStarting = 2,
    /// Running (active)
    ApplicationStatusRunning = 3,
    /// Stopping (graceful shutdown)
    ApplicationStatusStopping = 4,
    /// Stopped (gracefully)
    ApplicationStatusStopped = 5,
    /// Failed (error during start/run)
    ApplicationStatusFailed = 6,
}
impl ApplicationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ApplicationStatus::ApplicationStatusUnspecified => "APPLICATION_STATUS_UNSPECIFIED",
            ApplicationStatus::ApplicationStatusLoading => "APPLICATION_STATUS_LOADING",
            ApplicationStatus::ApplicationStatusStarting => "APPLICATION_STATUS_STARTING",
            ApplicationStatus::ApplicationStatusRunning => "APPLICATION_STATUS_RUNNING",
            ApplicationStatus::ApplicationStatusStopping => "APPLICATION_STATUS_STOPPING",
            ApplicationStatus::ApplicationStatusStopped => "APPLICATION_STATUS_STOPPED",
            ApplicationStatus::ApplicationStatusFailed => "APPLICATION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPLICATION_STATUS_UNSPECIFIED" => Some(Self::ApplicationStatusUnspecified),
            "APPLICATION_STATUS_LOADING" => Some(Self::ApplicationStatusLoading),
            "APPLICATION_STATUS_STARTING" => Some(Self::ApplicationStatusStarting),
            "APPLICATION_STATUS_RUNNING" => Some(Self::ApplicationStatusRunning),
            "APPLICATION_STATUS_STOPPING" => Some(Self::ApplicationStatusStopping),
            "APPLICATION_STATUS_STOPPED" => Some(Self::ApplicationStatusStopped),
            "APPLICATION_STATUS_FAILED" => Some(Self::ApplicationStatusFailed),
            _ => None,
        }
    }
}
include!("plexspaces.application.v1.tonic.rs");
// @@protoc_insertion_point(module)