// @generated
// This file is @generated by prost-build.
// ============================================================================
// VM Configuration Messages
// ============================================================================

/// VM configuration specification
///
/// ## Purpose
/// Defines complete configuration for a Firecracker microVM including
/// resources, boot parameters, and networking.
///
/// ## Why This Exists
/// - Type-safe VM specification
/// - Version-compatible VM configs
/// - Enables VM templates
/// - Supports resource quotas
///
/// ## Design Notes
/// - vm_id uses ULID for sortability
/// - vcpu_count limited to 1-32 (Firecracker limit)
/// - mem_size_mib limited to 128-32768 (practical limits)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmConfig {
    /// VM identifier (ULID format)
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    /// Number of vCPUs (1-32)
    #[prost(uint32, tag="2")]
    pub vcpu_count: u32,
    /// Memory size in MiB (128-32768)
    #[prost(uint32, tag="3")]
    pub mem_size_mib: u32,
    /// Kernel configuration
    #[prost(message, optional, tag="4")]
    pub boot_source: ::core::option::Option<BootSource>,
    /// Root filesystem drive
    #[prost(message, optional, tag="5")]
    pub rootfs: ::core::option::Option<Drive>,
    /// Additional drives (data, logs, etc.)
    #[prost(message, repeated, tag="6")]
    pub drives: ::prost::alloc::vec::Vec<Drive>,
    /// Network interfaces
    #[prost(message, repeated, tag="7")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// VM metadata (labels, annotations)
    #[prost(message, optional, tag="8")]
    pub metadata: ::core::option::Option<super::super::common::v1::Metadata>,
    /// Resource limits and quotas
    #[prost(message, optional, tag="9")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// Enable SMT (Simultaneous Multithreading)
    #[prost(bool, tag="10")]
    pub smt: bool,
    /// Track dirty pages for live migration
    #[prost(bool, tag="11")]
    pub track_dirty_pages: bool,
}
/// Boot source configuration (kernel + initrd)
///
/// ## Purpose
/// Specifies kernel image and boot parameters for VM.
///
/// ## Why This Exists
/// - Different VMs may use different kernels
/// - Boot args customize VM behavior
/// - Initrd optional for faster boot
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootSource {
    /// Path to kernel image on host
    #[prost(string, tag="1")]
    pub kernel_image_path: ::prost::alloc::string::String,
    /// Kernel boot arguments
    #[prost(string, tag="2")]
    pub boot_args: ::prost::alloc::string::String,
    /// Path to initrd image (optional)
    #[prost(string, tag="3")]
    pub initrd_path: ::prost::alloc::string::String,
}
/// Drive configuration (rootfs, data drives)
///
/// ## Purpose
/// Defines disk drives attached to VM (root filesystem, data volumes).
///
/// ## Why This Exists
/// - VMs need persistent storage
/// - Separate system (rootfs) from data drives
/// - Support read-only drives (immutable infrastructure)
/// - Enable drive snapshots
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Drive {
    /// Drive identifier
    #[prost(string, tag="1")]
    pub drive_id: ::prost::alloc::string::String,
    /// Path to drive image on host
    #[prost(string, tag="2")]
    pub path_on_host: ::prost::alloc::string::String,
    /// Is this the root device?
    #[prost(bool, tag="3")]
    pub is_root_device: bool,
    /// Is drive read-only?
    #[prost(bool, tag="4")]
    pub is_read_only: bool,
    /// Rate limiter for I/O throttling
    #[prost(message, optional, tag="5")]
    pub rate_limiter: ::core::option::Option<RateLimiter>,
}
/// Network interface configuration
///
/// ## Purpose
/// Defines TAP device attachment for VM networking.
///
/// ## Why This Exists
/// - VMs need network connectivity
/// - TAP devices provide L2 bridging
/// - MAC address for ARP/DHCP
/// - Rate limiting for fair sharing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    /// Interface identifier (e.g., "eth0")
    #[prost(string, tag="1")]
    pub iface_id: ::prost::alloc::string::String,
    /// TAP device name on host (e.g., "tap-vm001")
    #[prost(string, tag="2")]
    pub host_dev_name: ::prost::alloc::string::String,
    /// Guest MAC address (e.g., "AA:FC:00:00:00:01")
    #[prost(string, tag="3")]
    pub guest_mac: ::prost::alloc::string::String,
    /// RX rate limiter
    #[prost(message, optional, tag="4")]
    pub rx_rate_limiter: ::core::option::Option<RateLimiter>,
    /// TX rate limiter
    #[prost(message, optional, tag="5")]
    pub tx_rate_limiter: ::core::option::Option<RateLimiter>,
}
/// Rate limiter configuration (token bucket algorithm)
///
/// ## Purpose
/// Implements token bucket rate limiting for network/disk I/O.
///
/// ## Why This Exists
/// - Prevent noisy neighbor problems
/// - Fair resource sharing
/// - QoS guarantees
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimiter {
    /// Bandwidth limit (bytes/second)
    #[prost(message, optional, tag="1")]
    pub bandwidth: ::core::option::Option<TokenBucket>,
    /// Operations limit (ops/second)
    #[prost(message, optional, tag="2")]
    pub ops: ::core::option::Option<TokenBucket>,
}
/// Token bucket for rate limiting
///
/// ## Purpose
/// Defines token bucket parameters for rate limiting.
///
/// ## Why This Exists
/// - Industry standard algorithm (used by Linux tc)
/// - Allows bursts while limiting average rate
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenBucket {
    /// Bucket size (maximum burst)
    #[prost(uint64, tag="1")]
    pub size: u64,
    /// Refill rate (tokens per millisecond)
    #[prost(uint64, tag="2")]
    pub refill_time: u64,
}
/// Resource limits and quotas
///
/// ## Purpose
/// Enforces resource limits on VMs to prevent resource exhaustion.
///
/// ## Why This Exists
/// - Multi-tenancy requires isolation
/// - Prevent single VM from consuming all resources
/// - Enable capacity planning
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// Maximum memory (MiB)
    #[prost(uint32, tag="1")]
    pub max_memory_mib: u32,
    /// Maximum vCPUs
    #[prost(uint32, tag="2")]
    pub max_vcpus: u32,
    /// Maximum network bandwidth (MB/s)
    #[prost(uint32, tag="3")]
    pub max_network_bandwidth_mbps: u32,
    /// Maximum disk I/O (MB/s)
    #[prost(uint32, tag="4")]
    pub max_disk_io_mbps: u32,
    /// VM idle timeout (stop if idle)
    #[prost(message, optional, tag="5")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
}
/// VM instance metadata
///
/// ## Purpose
/// Represents a running or stopped VM instance with full state.
///
/// ## Why This Exists
/// - Track VM lifecycle
/// - Monitor resource usage
/// - Enable VM discovery
/// - Support debugging
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmInstance {
    /// VM identifier (ULID)
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    /// Current VM state
    #[prost(enumeration="VmState", tag="2")]
    pub state: i32,
    /// VM configuration
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<VmConfig>,
    /// Creation timestamp
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Boot timestamp
    #[prost(message, optional, tag="5")]
    pub booted_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Node hosting this VM
    #[prost(string, tag="6")]
    pub node_id: ::prost::alloc::string::String,
    /// Process ID of Firecracker process
    #[prost(uint32, tag="7")]
    pub process_id: u32,
    /// Socket path for Firecracker API
    #[prost(string, tag="8")]
    pub socket_path: ::prost::alloc::string::String,
    /// Application deployed to this VM (if any)
    ///
    /// ## Purpose
    /// Tracks which application is running in this VM.
    /// VMs contain entire applications, not individual actors.
    #[prost(string, tag="9")]
    pub application_id: ::prost::alloc::string::String,
    /// Resource usage
    #[prost(message, optional, tag="10")]
    pub resource_usage: ::core::option::Option<ResourceUsage>,
    /// Last error (if state == FAILED)
    #[prost(string, tag="11")]
    pub error_message: ::prost::alloc::string::String,
}
/// Resource usage metrics
///
/// ## Purpose
/// Tracks actual resource consumption by VM.
///
/// ## Why This Exists
/// - Capacity planning
/// - Cost allocation
/// - Anomaly detection
/// - Scaling decisions
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceUsage {
    /// Memory used (MiB)
    #[prost(uint32, tag="1")]
    pub memory_used_mib: u32,
    /// CPU utilization (0-100%)
    #[prost(float, tag="2")]
    pub cpu_utilization: f32,
    /// Network RX bytes
    #[prost(uint64, tag="3")]
    pub network_rx_bytes: u64,
    /// Network TX bytes
    #[prost(uint64, tag="4")]
    pub network_tx_bytes: u64,
    /// Disk read bytes
    #[prost(uint64, tag="5")]
    pub disk_read_bytes: u64,
    /// Disk write bytes
    #[prost(uint64, tag="6")]
    pub disk_write_bytes: u64,
    /// Uptime
    #[prost(message, optional, tag="7")]
    pub uptime: ::core::option::Option<::prost_types::Duration>,
}
// ============================================================================
// gRPC Request/Response Messages
// ============================================================================

/// CreateVm request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVmRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<VmConfig>,
}
/// CreateVm response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub socket_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// BootVm request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootVmRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
}
/// BootVm response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootVmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(enumeration="VmState", tag="2")]
    pub state: i32,
    #[prost(message, optional, tag="3")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// PauseVm request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseVmRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
}
/// PauseVm response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseVmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(enumeration="VmState", tag="2")]
    pub state: i32,
    #[prost(message, optional, tag="3")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// ResumeVm request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeVmRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
}
/// ResumeVm response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeVmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(enumeration="VmState", tag="2")]
    pub state: i32,
    #[prost(message, optional, tag="3")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// StopVm request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopVmRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    /// Force kill if graceful shutdown fails
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// StopVm response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopVmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, optional, tag="2")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// GetVmState request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVmStateRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
}
/// GetVmState response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVmStateResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, optional, tag="2")]
    pub vm: ::core::option::Option<VmInstance>,
    #[prost(message, optional, tag="3")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// ListVms request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVmsRequest {
    /// Filter by state (empty = all)
    #[prost(enumeration="VmState", repeated, tag="1")]
    pub states: ::prost::alloc::vec::Vec<i32>,
    /// Filter by node
    #[prost(string, tag="2")]
    pub node_id: ::prost::alloc::string::String,
    /// Pagination
    #[prost(uint32, tag="3")]
    pub page_size: u32,
    #[prost(string, tag="4")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListVms response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVmsResponse {
    #[prost(message, repeated, tag="1")]
    pub vms: ::prost::alloc::vec::Vec<VmInstance>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub total_count: u32,
}
/// DeployApplication request
///
/// ## Purpose
/// Deploys a complete PlexSpaces application to a VM.
/// Application includes framework runtime, WASM modules, and configuration.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployApplicationRequest {
    /// VM identifier
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    /// Application identifier
    #[prost(string, tag="2")]
    pub application_id: ::prost::alloc::string::String,
    /// Application bundle (framework + actors + config)
    ///
    /// Contains:
    /// - Framework runtime binary
    /// - WASM modules (actor implementations)
    /// - Application configuration
    /// - Dependencies
    #[prost(bytes="vec", tag="3")]
    pub application_bundle: ::prost::alloc::vec::Vec<u8>,
    /// Application configuration (optional, can be in bundle)
    ///
    /// Max 1MB
    #[prost(string, tag="4")]
    pub application_config_json: ::prost::alloc::string::String,
}
/// DeployApplication response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployApplicationResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub application_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub error: ::core::option::Option<FirecrackerError>,
}
/// UndeployApplication request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployApplicationRequest {
    #[prost(string, tag="1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub application_id: ::prost::alloc::string::String,
    /// Force undeploy even if actors are running
    #[prost(bool, tag="3")]
    pub force: bool,
}
/// UndeployApplication response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployApplicationResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, optional, tag="2")]
    pub error: ::core::option::Option<FirecrackerError>,
}
// ============================================================================
// Error Messages
// ============================================================================

/// Firecracker error
///
/// ## Purpose
/// Structured error information for VM operations.
///
/// ## Why This Exists
/// - Type-safe error handling
/// - Localized error messages
/// - Error categorization
/// - Debugging context
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirecrackerError {
    #[prost(enumeration="FirecrackerErrorCode", tag="1")]
    pub code: i32,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
// ============================================================================
// VM State and Lifecycle
// ============================================================================

/// VM state enumeration
///
/// ## Purpose
/// Tracks VM lifecycle state for management and monitoring.
///
/// ## State Transitions
/// Created -> Booting -> Running -> \[Paused -> Running\]
///                                 -> \[Stopping -> Stopped\]
///                                 -> \[Failed\]
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VmState {
    VmStateUnspecified = 0,
    /// VM created, not yet booted
    VmStateCreated = 1,
    /// Kernel loading
    VmStateBooting = 2,
    /// Fully operational
    VmStateRunning = 3,
    /// Execution paused (can resume)
    VmStatePaused = 4,
    /// Shutdown in progress
    VmStateStopping = 5,
    /// Fully stopped
    VmStateStopped = 6,
    /// Failed to boot or crashed
    VmStateFailed = 7,
}
impl VmState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VmState::VmStateUnspecified => "VM_STATE_UNSPECIFIED",
            VmState::VmStateCreated => "VM_STATE_CREATED",
            VmState::VmStateBooting => "VM_STATE_BOOTING",
            VmState::VmStateRunning => "VM_STATE_RUNNING",
            VmState::VmStatePaused => "VM_STATE_PAUSED",
            VmState::VmStateStopping => "VM_STATE_STOPPING",
            VmState::VmStateStopped => "VM_STATE_STOPPED",
            VmState::VmStateFailed => "VM_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VM_STATE_UNSPECIFIED" => Some(Self::VmStateUnspecified),
            "VM_STATE_CREATED" => Some(Self::VmStateCreated),
            "VM_STATE_BOOTING" => Some(Self::VmStateBooting),
            "VM_STATE_RUNNING" => Some(Self::VmStateRunning),
            "VM_STATE_PAUSED" => Some(Self::VmStatePaused),
            "VM_STATE_STOPPING" => Some(Self::VmStateStopping),
            "VM_STATE_STOPPED" => Some(Self::VmStateStopped),
            "VM_STATE_FAILED" => Some(Self::VmStateFailed),
            _ => None,
        }
    }
}
/// Firecracker error codes
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FirecrackerErrorCode {
    FirecrackerErrorCodeOk = 0,
    FirecrackerErrorCodeVmCreationFailed = 1,
    FirecrackerErrorCodeVmBootFailed = 2,
    FirecrackerErrorCodeVmOperationFailed = 3,
    FirecrackerErrorCodeVmNotFound = 4,
    FirecrackerErrorCodeNetworkSetupFailed = 5,
    FirecrackerErrorCodeConfigurationError = 6,
    FirecrackerErrorCodeApiError = 7,
    FirecrackerErrorCodeResourceExhausted = 8,
    FirecrackerErrorCodePermissionDenied = 9,
    FirecrackerErrorCodeTimeout = 10,
}
impl FirecrackerErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FirecrackerErrorCode::FirecrackerErrorCodeOk => "FIRECRACKER_ERROR_CODE_OK",
            FirecrackerErrorCode::FirecrackerErrorCodeVmCreationFailed => "FIRECRACKER_ERROR_CODE_VM_CREATION_FAILED",
            FirecrackerErrorCode::FirecrackerErrorCodeVmBootFailed => "FIRECRACKER_ERROR_CODE_VM_BOOT_FAILED",
            FirecrackerErrorCode::FirecrackerErrorCodeVmOperationFailed => "FIRECRACKER_ERROR_CODE_VM_OPERATION_FAILED",
            FirecrackerErrorCode::FirecrackerErrorCodeVmNotFound => "FIRECRACKER_ERROR_CODE_VM_NOT_FOUND",
            FirecrackerErrorCode::FirecrackerErrorCodeNetworkSetupFailed => "FIRECRACKER_ERROR_CODE_NETWORK_SETUP_FAILED",
            FirecrackerErrorCode::FirecrackerErrorCodeConfigurationError => "FIRECRACKER_ERROR_CODE_CONFIGURATION_ERROR",
            FirecrackerErrorCode::FirecrackerErrorCodeApiError => "FIRECRACKER_ERROR_CODE_API_ERROR",
            FirecrackerErrorCode::FirecrackerErrorCodeResourceExhausted => "FIRECRACKER_ERROR_CODE_RESOURCE_EXHAUSTED",
            FirecrackerErrorCode::FirecrackerErrorCodePermissionDenied => "FIRECRACKER_ERROR_CODE_PERMISSION_DENIED",
            FirecrackerErrorCode::FirecrackerErrorCodeTimeout => "FIRECRACKER_ERROR_CODE_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIRECRACKER_ERROR_CODE_OK" => Some(Self::FirecrackerErrorCodeOk),
            "FIRECRACKER_ERROR_CODE_VM_CREATION_FAILED" => Some(Self::FirecrackerErrorCodeVmCreationFailed),
            "FIRECRACKER_ERROR_CODE_VM_BOOT_FAILED" => Some(Self::FirecrackerErrorCodeVmBootFailed),
            "FIRECRACKER_ERROR_CODE_VM_OPERATION_FAILED" => Some(Self::FirecrackerErrorCodeVmOperationFailed),
            "FIRECRACKER_ERROR_CODE_VM_NOT_FOUND" => Some(Self::FirecrackerErrorCodeVmNotFound),
            "FIRECRACKER_ERROR_CODE_NETWORK_SETUP_FAILED" => Some(Self::FirecrackerErrorCodeNetworkSetupFailed),
            "FIRECRACKER_ERROR_CODE_CONFIGURATION_ERROR" => Some(Self::FirecrackerErrorCodeConfigurationError),
            "FIRECRACKER_ERROR_CODE_API_ERROR" => Some(Self::FirecrackerErrorCodeApiError),
            "FIRECRACKER_ERROR_CODE_RESOURCE_EXHAUSTED" => Some(Self::FirecrackerErrorCodeResourceExhausted),
            "FIRECRACKER_ERROR_CODE_PERMISSION_DENIED" => Some(Self::FirecrackerErrorCodePermissionDenied),
            "FIRECRACKER_ERROR_CODE_TIMEOUT" => Some(Self::FirecrackerErrorCodeTimeout),
            _ => None,
        }
    }
}
include!("plexspaces.firecracker.v1.tonic.rs");
// @@protoc_insertion_point(module)