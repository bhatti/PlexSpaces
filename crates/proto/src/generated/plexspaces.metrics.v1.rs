// @generated
// This file is @generated by prost-build.
/// Metric definition (registry of available metrics)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricDefinition {
    /// Metric name (e.g., "plexspaces_actor_spawn_total")
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Metric type
    #[prost(enumeration="MetricType", tag="2")]
    pub r#type: i32,
    /// Help text describing the metric
    #[prost(string, tag="3")]
    pub help: ::prost::alloc::string::String,
    /// Label names (e.g., \["node_id", "actor_type"\])
    #[prost(string, repeated, tag="4")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Histogram buckets (for histogram metrics)
    #[prost(double, repeated, tag="5")]
    pub buckets: ::prost::alloc::vec::Vec<f64>,
}
/// Metric value with labels
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metric {
    /// Metric name
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Labels (key-value pairs)
    #[prost(map="string, string", tag="2")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// When metric was recorded
    #[prost(message, optional, tag="20")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Metric value
    #[prost(oneof="metric::Value", tags="10, 11, 12, 13")]
    pub value: ::core::option::Option<metric::Value>,
}
/// Nested message and enum types in `Metric`.
pub mod metric {
    /// Metric value
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(double, tag="10")]
        CounterValue(f64),
        #[prost(double, tag="11")]
        GaugeValue(f64),
        #[prost(message, tag="12")]
        HistogramValue(super::HistogramValue),
        #[prost(message, tag="13")]
        SummaryValue(super::SummaryValue),
    }
}
/// Histogram value
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramValue {
    #[prost(uint64, tag="1")]
    pub count: u64,
    #[prost(double, tag="2")]
    pub sum: f64,
    #[prost(message, repeated, tag="3")]
    pub buckets: ::prost::alloc::vec::Vec<histogram_value::Bucket>,
}
/// Nested message and enum types in `HistogramValue`.
pub mod histogram_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Bucket {
        #[prost(double, tag="1")]
        pub upper_bound: f64,
        #[prost(uint64, tag="2")]
        pub count: u64,
    }
}
/// Summary value
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummaryValue {
    #[prost(uint64, tag="1")]
    pub count: u64,
    #[prost(double, tag="2")]
    pub sum: f64,
    #[prost(message, repeated, tag="3")]
    pub quantiles: ::prost::alloc::vec::Vec<summary_value::Quantile>,
}
/// Nested message and enum types in `SummaryValue`.
pub mod summary_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Quantile {
        /// e.g., 0.5, 0.9, 0.99
        #[prost(double, tag="1")]
        pub quantile: f64,
        #[prost(double, tag="2")]
        pub value: f64,
    }
}
// ============================================================================
// REQUEST/RESPONSE MESSAGES
// ============================================================================

/// Empty - exports all metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPrometheusRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPrometheusResponse {
    /// Prometheus text format
    #[prost(string, tag="1")]
    pub content: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    /// Filter by metric name pattern (e.g., "plexspaces_actor_*")
    #[prost(string, tag="1")]
    pub name_pattern: ::prost::alloc::string::String,
    /// Filter by labels
    #[prost(map="string, string", tag="2")]
    pub label_filter: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsResponse {
    #[prost(message, repeated, tag="1")]
    pub metrics: ::prost::alloc::vec::Vec<Metric>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetricDefinitionsRequest {
    /// Filter by name pattern
    #[prost(string, tag="1")]
    pub name_pattern: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetricDefinitionsResponse {
    #[prost(message, repeated, tag="1")]
    pub definitions: ::prost::alloc::vec::Vec<MetricDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMetricRequest {
    /// Metric to record
    #[prost(message, optional, tag="1")]
    pub metric: ::core::option::Option<Metric>,
}
/// Request to get actor metrics
///
/// Empty - returns metrics for the local ActorService
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorMetricsRequest {
}
/// Request to get node metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeMetricsRequest {
    /// Node ID (empty = local node)
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
}
// ============================================================================
// STANDARD METRIC DEFINITIONS
// ============================================================================
// These are the built-in metrics that all PlexSpaces services emit.
// Services can register additional custom metrics as needed.

/// Standard actor metrics (high-level, for ActorService)
/// Note: Detailed actor/message metrics are in the ActorMetrics message below
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorServiceMetrics {
    /// Total actors spawned
    #[prost(uint64, tag="1")]
    pub spawn_total: u64,
    /// Currently active actors
    #[prost(uint64, tag="2")]
    pub active: u64,
    /// Total messages received
    #[prost(uint64, tag="3")]
    pub message_received_total: u64,
    /// Total messages processed
    #[prost(uint64, tag="4")]
    pub message_processed_total: u64,
    /// Total errors
    #[prost(uint64, tag="5")]
    pub error_total: u64,
    /// Message processing latency (histogram)
    #[prost(message, optional, tag="6")]
    pub message_processed_duration: ::core::option::Option<HistogramValue>,
}
/// Standard supervision metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisionMetrics {
    /// Total restarts by strategy
    ///
    /// key = strategy name
    #[prost(map="string, uint64", tag="1")]
    pub restart_total: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    /// Total child failures
    #[prost(uint64, tag="2")]
    pub child_failure_total: u64,
    /// Recovery duration (histogram)
    #[prost(message, optional, tag="3")]
    pub recovery_duration: ::core::option::Option<HistogramValue>,
}
/// Standard remoting metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemotingMetrics {
    /// Total remote messages sent
    #[prost(uint64, tag="1")]
    pub message_sent_total: u64,
    /// Total remote messages received
    #[prost(uint64, tag="2")]
    pub message_received_total: u64,
    /// Remote message latency (histogram)
    #[prost(message, optional, tag="3")]
    pub message_latency: ::core::option::Option<HistogramValue>,
    /// Total registry lookups
    #[prost(uint64, tag="4")]
    pub registry_lookup_total: u64,
    /// Registry lookup duration (histogram)
    #[prost(message, optional, tag="5")]
    pub registry_lookup_duration: ::core::option::Option<HistogramValue>,
}
/// Actor and message routing/delivery metrics
///
/// ## Purpose
/// Tracks actor lifecycle and message routing/delivery metrics that can be updated by ActorRegistry
/// without depending on Node. These metrics are also synced to NodeMetrics
/// via NodeMetricsUpdater for backward compatibility.
///
/// ## Design
/// Proto-first design: All actor/message metrics are defined in proto for:
/// - Wire compatibility (gRPC metrics APIs)
/// - Language-agnostic observability
/// - Consistent metrics semantics across implementations
///
/// ## Metrics Categories
/// - Actor lifecycle: Spawned, active, errors
/// - Message routing: Total messages routed
/// - Delivery metrics: Local, remote, and failed deliveries
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorMetrics {
    /// Total actors spawned
    #[prost(uint64, tag="1")]
    pub spawn_total: u64,
    /// Currently active actors
    #[prost(uint64, tag="2")]
    pub active: u64,
    /// Total messages routed through this node/registry
    #[prost(uint64, tag="3")]
    pub messages_routed: u64,
    /// Local message deliveries (same node)
    #[prost(uint64, tag="4")]
    pub local_deliveries: u64,
    /// Remote message deliveries (different node)
    #[prost(uint64, tag="5")]
    pub remote_deliveries: u64,
    /// Failed message deliveries
    #[prost(uint64, tag="6")]
    pub failed_deliveries: u64,
    /// Total errors
    #[prost(uint64, tag="7")]
    pub error_total: u64,
}
// ============================================================================
// SYSTEM METRICS (Detailed)
// ============================================================================
// Detailed system performance metrics following industry standards
// (OpenTelemetry/Prometheus-inspired)

/// System metrics snapshot
///
/// ## Purpose
/// Comprehensive system performance metrics for observability.
/// Follows OpenTelemetry/Prometheus best practices with structured metrics.
///
/// ## Design Notes
/// - Timestamped snapshot of system state
/// - Nested messages for logical grouping (CPU, memory, disk, network, components)
/// - Can be converted to Prometheus metrics via labels
/// - Supports both structured (this message) and flat (Prometheus) formats
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemMetrics {
    /// When this metrics snapshot was taken
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// CPU metrics
    #[prost(message, optional, tag="2")]
    pub cpu: ::core::option::Option<CpuMetrics>,
    /// Memory metrics
    #[prost(message, optional, tag="3")]
    pub memory: ::core::option::Option<MemoryMetrics>,
    /// Disk metrics
    #[prost(message, optional, tag="4")]
    pub disk: ::core::option::Option<DiskMetrics>,
    /// Network metrics
    #[prost(message, optional, tag="5")]
    pub network: ::core::option::Option<NetworkMetrics>,
    /// Component metrics (actors, workflows, etc.)
    #[prost(message, optional, tag="6")]
    pub components: ::core::option::Option<ComponentMetrics>,
}
/// CPU performance metrics
///
/// ## Prometheus Mapping
/// - `plexspaces_system_cpu_usage_percent` (gauge)
/// - `plexspaces_system_cpu_load_average_1m` (gauge)
/// - `plexspaces_system_cpu_load_average_5m` (gauge)
/// - `plexspaces_system_cpu_load_average_15m` (gauge)
/// - `plexspaces_system_cpu_active_processes` (gauge)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuMetrics {
    /// CPU usage percentage (0.0 to 100.0)
    #[prost(double, tag="1")]
    pub usage_percent: f64,
    /// Load average over 1 minute
    #[prost(double, tag="2")]
    pub load_average_1m: f64,
    /// Load average over 5 minutes
    #[prost(double, tag="3")]
    pub load_average_5m: f64,
    /// Load average over 15 minutes
    #[prost(double, tag="4")]
    pub load_average_15m: f64,
    /// Number of active processes
    #[prost(int32, tag="5")]
    pub active_processes: i32,
}
/// Memory performance metrics
///
/// ## Prometheus Mapping
/// - `plexspaces_system_memory_total_bytes` (gauge)
/// - `plexspaces_system_memory_used_bytes` (gauge)
/// - `plexspaces_system_memory_free_bytes` (gauge)
/// - `plexspaces_system_memory_cached_bytes` (gauge)
/// - `plexspaces_system_memory_usage_percent` (gauge)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryMetrics {
    /// Total memory in megabytes
    #[prost(uint64, tag="1")]
    pub total_mb: u64,
    /// Used memory in megabytes
    #[prost(uint64, tag="2")]
    pub used_mb: u64,
    /// Free memory in megabytes
    #[prost(uint64, tag="3")]
    pub free_mb: u64,
    /// Cached memory in megabytes
    #[prost(uint64, tag="4")]
    pub cached_mb: u64,
    /// Memory usage percentage (0.0 to 100.0)
    #[prost(double, tag="5")]
    pub usage_percent: f64,
}
/// Disk performance metrics
///
/// ## Prometheus Mapping
/// - `plexspaces_system_disk_total_bytes` (gauge)
/// - `plexspaces_system_disk_used_bytes` (gauge)
/// - `plexspaces_system_disk_free_bytes` (gauge)
/// - `plexspaces_system_disk_usage_percent` (gauge)
/// - `plexspaces_system_disk_read_ops_per_sec` (gauge)
/// - `plexspaces_system_disk_write_ops_per_sec` (gauge)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskMetrics {
    /// Total disk space in gigabytes
    #[prost(uint64, tag="1")]
    pub total_gb: u64,
    /// Used disk space in gigabytes
    #[prost(uint64, tag="2")]
    pub used_gb: u64,
    /// Free disk space in gigabytes
    #[prost(uint64, tag="3")]
    pub free_gb: u64,
    /// Disk usage percentage (0.0 to 100.0)
    #[prost(double, tag="4")]
    pub usage_percent: f64,
    /// Disk read operations per second
    #[prost(uint64, tag="5")]
    pub read_ops_per_sec: u64,
    /// Disk write operations per second
    #[prost(uint64, tag="6")]
    pub write_ops_per_sec: u64,
}
/// Network performance metrics
///
/// ## Prometheus Mapping
/// - `plexspaces_system_network_bytes_received_per_sec` (gauge)
/// - `plexspaces_system_network_bytes_sent_per_sec` (gauge)
/// - `plexspaces_system_network_packets_received_per_sec` (gauge)
/// - `plexspaces_system_network_packets_sent_per_sec` (gauge)
/// - `plexspaces_system_network_active_connections` (gauge)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkMetrics {
    /// Bytes received per second
    #[prost(uint64, tag="1")]
    pub bytes_received_per_sec: u64,
    /// Bytes sent per second
    #[prost(uint64, tag="2")]
    pub bytes_sent_per_sec: u64,
    /// Packets received per second
    #[prost(uint64, tag="3")]
    pub packets_received_per_sec: u64,
    /// Packets sent per second
    #[prost(uint64, tag="4")]
    pub packets_sent_per_sec: u64,
    /// Number of active network connections
    #[prost(uint32, tag="5")]
    pub active_connections: u32,
}
/// Component metrics (PlexSpaces-specific)
///
/// ## Purpose
/// Tracks PlexSpaces-specific component counts and sizes.
///
/// ## Design
/// Uses maps to support extensible actor types and component types without schema changes.
/// Actor types are strings (e.g., "counter", "worker", "virtual_actor", "genserver", "workflow").
///
/// ## Prometheus Mapping
/// - `plexspaces_components_active_actors_by_type{actor_type="counter"}` (gauge)
/// - `plexspaces_components_active_actors_by_type{actor_type="worker"}` (gauge)
/// - `plexspaces_components_active_vms` (gauge)
/// - `plexspaces_components_tuplespace_size` (gauge)
/// - `plexspaces_components_active_subscriptions` (gauge)
/// - `plexspaces_components_active_transactions` (gauge)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComponentMetrics {
    /// Active actors by type (supports all actor types: "counter", "worker", "virtual_actor", "genserver", "workflow", etc.)
    /// Key: actor type (string), Value: count of active actors of that type
    /// Examples:
    ///    - "counter" -> 10
    ///    - "worker" -> 50
    ///    - "virtual_actor" -> 100
    ///    - "genserver" -> 25
    ///    - "workflow" -> 5
    #[prost(map="string, uint32", tag="1")]
    pub active_actors_by_type: ::std::collections::HashMap<::prost::alloc::string::String, u32>,
    /// Number of active VMs
    #[prost(uint32, tag="2")]
    pub active_vms: u32,
    /// TupleSpace size (number of tuples)
    #[prost(uint64, tag="3")]
    pub tuplespace_size: u64,
    /// Number of active subscriptions
    #[prost(uint32, tag="4")]
    pub active_subscriptions: u32,
    /// Number of active transactions
    #[prost(uint32, tag="5")]
    pub active_transactions: u32,
}
// ============================================================================
// COORDINATION VS COMPUTE METRICS
// ============================================================================
// Tracks coordination overhead vs actual computation time for HPC workloads.
// Per CLAUDE.md Design Principle #6: Computation Cost >> Communication Cost
//
// ## Purpose
// Measure granularity ratio (compute / coordinate) to ensure efficient parallelism.
// Golden Rule: compute_time / coordinate_time >= 10x (minimum), ideally >= 100x
//
// ## Usage
// Start tracking with start_compute() / start_coordinate(), then finalize() to get metrics.
// This helps identify bottlenecks and optimize actor granularity.

/// Coordination vs Compute metrics for workflow/actor execution
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoordinationComputeMetrics {
    /// Workflow/actor ID being tracked
    #[prost(string, tag="1")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Time spent on actual computation (ms)
    #[prost(uint64, tag="2")]
    pub compute_duration_ms: u64,
    /// Time spent on coordination (message passing, barriers, scheduling) (ms)
    #[prost(uint64, tag="3")]
    pub coordinate_duration_ms: u64,
    /// Number of messages sent between actors
    #[prost(uint64, tag="4")]
    pub message_count: u64,
    /// Number of barrier synchronizations
    #[prost(uint64, tag="5")]
    pub barrier_count: u64,
    /// Total execution duration (ms)
    #[prost(uint64, tag="6")]
    pub total_duration_ms: u64,
    /// Granularity ratio (compute / coordinate)
    /// Should be >= 10.0, ideally >= 100.0
    #[prost(double, tag="7")]
    pub granularity_ratio: f64,
    /// Efficiency (compute / total)
    /// Closer to 1.0 means less coordination overhead
    #[prost(double, tag="8")]
    pub efficiency: f64,
    /// Step-by-step breakdown (optional)
    #[prost(message, repeated, tag="9")]
    pub step_metrics: ::prost::alloc::vec::Vec<StepMetrics>,
}
/// Metrics for individual workflow step
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepMetrics {
    /// Step name
    #[prost(string, tag="1")]
    pub step_name: ::prost::alloc::string::String,
    /// Computation time for this step (ms)
    #[prost(uint64, tag="2")]
    pub compute_ms: u64,
    /// Coordination time for this step (ms)
    #[prost(uint64, tag="3")]
    pub coordinate_ms: u64,
    /// Number of messages sent in this step
    #[prost(uint64, tag="4")]
    pub message_count: u64,
}
// ============================================================================
// METRIC TYPES
// ============================================================================

/// Metric type enumeration
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetricType {
    MetricTypeUnspecified = 0,
    /// Monotonically increasing value
    MetricTypeCounter = 1,
    /// Can go up and down
    MetricTypeGauge = 2,
    /// Distribution of values
    MetricTypeHistogram = 3,
    /// Similar to histogram but with quantiles
    MetricTypeSummary = 4,
}
impl MetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MetricType::MetricTypeUnspecified => "METRIC_TYPE_UNSPECIFIED",
            MetricType::MetricTypeCounter => "METRIC_TYPE_COUNTER",
            MetricType::MetricTypeGauge => "METRIC_TYPE_GAUGE",
            MetricType::MetricTypeHistogram => "METRIC_TYPE_HISTOGRAM",
            MetricType::MetricTypeSummary => "METRIC_TYPE_SUMMARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "METRIC_TYPE_UNSPECIFIED" => Some(Self::MetricTypeUnspecified),
            "METRIC_TYPE_COUNTER" => Some(Self::MetricTypeCounter),
            "METRIC_TYPE_GAUGE" => Some(Self::MetricTypeGauge),
            "METRIC_TYPE_HISTOGRAM" => Some(Self::MetricTypeHistogram),
            "METRIC_TYPE_SUMMARY" => Some(Self::MetricTypeSummary),
            _ => None,
        }
    }
}
include!("plexspaces.metrics.v1.tonic.rs");
// @@protoc_insertion_point(module)