// @generated
// This file is @generated by prost-build.
/// Pool configuration (Erlang poolboy-inspired)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolConfig {
    /// Pool name (unique identifier)
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Minimum pool size (always maintained)
    #[prost(uint32, tag="2")]
    pub min_size: u32,
    /// Maximum pool size (overflow limit)
    #[prost(uint32, tag="3")]
    pub max_size: u32,
    /// Initial pool size (on startup)
    #[prost(uint32, tag="4")]
    pub initial_size: u32,
    /// Scaling thresholds
    ///
    /// Scale up when load > this (default: 0.8)
    #[prost(double, tag="5")]
    pub scaling_threshold: f64,
    /// Scale down when load < this (default: 0.3)
    #[prost(double, tag="6")]
    pub scale_down_threshold: f64,
    /// Idle timeout (kill idle workers after this duration)
    #[prost(message, optional, tag="7")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Checkout timeout (max time to wait for available actor)
    #[prost(message, optional, tag="8")]
    pub checkout_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Health check interval
    #[prost(message, optional, tag="9")]
    pub health_check_interval: ::core::option::Option<::prost_types::Duration>,
    /// Scaling check interval
    #[prost(message, optional, tag="10")]
    pub scaling_check_interval: ::core::option::Option<::prost_types::Duration>,
    /// Scaling policies
    #[prost(message, optional, tag="11")]
    pub scaling_policy: ::core::option::Option<ScalingPolicy>,
    /// Actor configuration (behavior-specific)
    #[prost(message, optional, tag="12")]
    pub actor_config: ::core::option::Option<ActorConfig>,
    /// Circuit breaker configuration (optional)
    #[prost(message, optional, tag="13")]
    pub circuit_breaker: ::core::option::Option<CircuitBreakerConfig>,
}
/// Scaling policy
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalingPolicy {
    #[prost(enumeration="scaling_policy::Strategy", tag="1")]
    pub strategy: i32,
    /// For percentage strategy: how much to scale (e.g., 0.5 = 50%)
    #[prost(double, tag="2")]
    pub scale_factor: f64,
    /// Cooldown period after scaling (prevent thrashing)
    #[prost(message, optional, tag="3")]
    pub cooldown: ::core::option::Option<::prost_types::Duration>,
    /// Minimum workers to add/remove at a time
    #[prost(uint32, tag="4")]
    pub min_scale_step: u32,
    /// Maximum workers to add/remove at a time
    #[prost(uint32, tag="5")]
    pub max_scale_step: u32,
}
/// Nested message and enum types in `ScalingPolicy`.
pub mod scaling_policy {
    /// Scaling strategy
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Strategy {
        /// Add/remove workers one at a time
        StrategyIncremental = 0,
        /// Add/remove a percentage of current size
        StrategyPercentage = 1,
        /// Double/halve pool size
        StrategyExponential = 2,
        /// Custom scaling function
        StrategyCustom = 3,
    }
    impl Strategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Strategy::StrategyIncremental => "STRATEGY_INCREMENTAL",
                Strategy::StrategyPercentage => "STRATEGY_PERCENTAGE",
                Strategy::StrategyExponential => "STRATEGY_EXPONENTIAL",
                Strategy::StrategyCustom => "STRATEGY_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRATEGY_INCREMENTAL" => Some(Self::StrategyIncremental),
                "STRATEGY_PERCENTAGE" => Some(Self::StrategyPercentage),
                "STRATEGY_EXPONENTIAL" => Some(Self::StrategyExponential),
                "STRATEGY_CUSTOM" => Some(Self::StrategyCustom),
                _ => None,
            }
        }
    }
}
/// Actor configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorConfig {
    /// Actor behavior type (e.g., "DbConnectionActor", "HttpClientActor")
    #[prost(string, tag="1")]
    pub actor_type: ::prost::alloc::string::String,
    /// Actor initialization arguments (serialized)
    #[prost(bytes="vec", tag="2")]
    pub init_args: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="actor_config::RestartPolicy", tag="3")]
    pub restart_policy: i32,
    /// Actor shutdown timeout
    #[prost(message, optional, tag="4")]
    pub shutdown_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum restarts per time window
    #[prost(uint32, tag="5")]
    pub max_restarts: u32,
    #[prost(message, optional, tag="6")]
    pub restart_window: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `ActorConfig`.
pub mod actor_config {
    /// Actor restart policy
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum RestartPolicy {
        /// Always restart
        RestartPolicyPermanent = 0,
        /// Never restart
        RestartPolicyTemporary = 1,
        /// Restart only on abnormal exit
        RestartPolicyTransient = 2,
    }
    impl RestartPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RestartPolicy::RestartPolicyPermanent => "RESTART_POLICY_PERMANENT",
                RestartPolicy::RestartPolicyTemporary => "RESTART_POLICY_TEMPORARY",
                RestartPolicy::RestartPolicyTransient => "RESTART_POLICY_TRANSIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESTART_POLICY_PERMANENT" => Some(Self::RestartPolicyPermanent),
                "RESTART_POLICY_TEMPORARY" => Some(Self::RestartPolicyTemporary),
                "RESTART_POLICY_TRANSIENT" => Some(Self::RestartPolicyTransient),
                _ => None,
            }
        }
    }
}
/// Circuit breaker configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerConfig {
    /// Failure threshold to open circuit
    #[prost(uint32, tag="1")]
    pub failure_threshold: u32,
    /// Success threshold to close circuit
    #[prost(uint32, tag="2")]
    pub success_threshold: u32,
    /// Timeout before trying to close circuit
    #[prost(message, optional, tag="3")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Half-open state: allow some requests through
    #[prost(uint32, tag="4")]
    pub half_open_max_requests: u32,
}
/// Pool metrics (for monitoring and auto-scaling decisions)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolMetrics {
    /// Pool name
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Current state
    #[prost(enumeration="ScalingState", tag="2")]
    pub scaling_state: i32,
    /// Actor counts
    #[prost(uint32, tag="3")]
    pub total_actors: u32,
    #[prost(uint32, tag="4")]
    pub available_actors: u32,
    #[prost(uint32, tag="5")]
    pub busy_actors: u32,
    #[prost(uint32, tag="6")]
    pub idle_actors: u32,
    #[prost(uint32, tag="7")]
    pub failed_actors: u32,
    /// Queue metrics
    #[prost(uint32, tag="8")]
    pub waiting_requests: u32,
    #[prost(uint32, tag="9")]
    pub total_checkouts: u32,
    #[prost(uint32, tag="10")]
    pub total_checkins: u32,
    #[prost(uint32, tag="11")]
    pub total_timeouts: u32,
    /// Load metrics (0.0 to 1.0)
    #[prost(double, tag="12")]
    pub current_load: f64,
    #[prost(double, tag="13")]
    pub avg_load_1m: f64,
    #[prost(double, tag="14")]
    pub avg_load_5m: f64,
    /// Latency metrics (microseconds)
    #[prost(uint64, tag="15")]
    pub avg_checkout_latency: u64,
    #[prost(uint64, tag="16")]
    pub p95_checkout_latency: u64,
    #[prost(uint64, tag="17")]
    pub p99_checkout_latency: u64,
    /// Actor usage metrics
    #[prost(uint64, tag="18")]
    pub avg_actor_usage_time: u64,
    #[prost(uint64, tag="19")]
    pub avg_actor_idle_time: u64,
    /// Circuit breaker state
    ///
    /// "closed", "open", "half-open"
    #[prost(string, tag="20")]
    pub circuit_state: ::prost::alloc::string::String,
    /// Last scaling event
    #[prost(message, optional, tag="21")]
    pub last_scale_up: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="22")]
    pub last_scale_down: ::core::option::Option<::prost_types::Timestamp>,
    /// Custom metrics (backend-specific)
    #[prost(map="string, double", tag="23")]
    pub custom_metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
}
/// Actor handle (returned from checkout)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorHandle {
    /// Actor ID
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Pool name
    #[prost(string, tag="2")]
    pub pool_name: ::prost::alloc::string::String,
    /// Checkout timestamp
    #[prost(message, optional, tag="3")]
    pub checkout_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Checkout ID (for tracking)
    #[prost(string, tag="4")]
    pub checkout_id: ::prost::alloc::string::String,
    /// Actor metadata
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// CreatePool request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePoolRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<PoolConfig>,
}
/// CreatePool response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePoolResponse {
    #[prost(string, tag="1")]
    pub pool_id: ::prost::alloc::string::String,
}
/// Checkout request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckoutRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// For tracking/correlation
    #[prost(map="string, string", tag="3")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Checkout response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckoutResponse {
    #[prost(oneof="checkout_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<checkout_response::Result>,
}
/// Nested message and enum types in `CheckoutResponse`.
pub mod checkout_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Actor(super::ActorHandle),
        #[prost(message, tag="2")]
        Error(super::CheckoutError),
    }
}
/// Checkout error
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckoutError {
    #[prost(enumeration="checkout_error::ErrorType", tag="1")]
    pub r#type: i32,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CheckoutError`.
pub mod checkout_error {
    #[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ErrorType {
        ErrorTypeTimeout = 0,
        ErrorTypePoolExhausted = 1,
        ErrorTypeCircuitOpen = 2,
        ErrorTypePoolDraining = 3,
        ErrorTypePoolNotFound = 4,
    }
    impl ErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorType::ErrorTypeTimeout => "ERROR_TYPE_TIMEOUT",
                ErrorType::ErrorTypePoolExhausted => "ERROR_TYPE_POOL_EXHAUSTED",
                ErrorType::ErrorTypeCircuitOpen => "ERROR_TYPE_CIRCUIT_OPEN",
                ErrorType::ErrorTypePoolDraining => "ERROR_TYPE_POOL_DRAINING",
                ErrorType::ErrorTypePoolNotFound => "ERROR_TYPE_POOL_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_TYPE_TIMEOUT" => Some(Self::ErrorTypeTimeout),
                "ERROR_TYPE_POOL_EXHAUSTED" => Some(Self::ErrorTypePoolExhausted),
                "ERROR_TYPE_CIRCUIT_OPEN" => Some(Self::ErrorTypeCircuitOpen),
                "ERROR_TYPE_POOL_DRAINING" => Some(Self::ErrorTypePoolDraining),
                "ERROR_TYPE_POOL_NOT_FOUND" => Some(Self::ErrorTypePoolNotFound),
                _ => None,
            }
        }
    }
}
/// Checkin request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckinRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub checkout_id: ::prost::alloc::string::String,
    /// Optional: actor health status
    #[prost(bool, tag="4")]
    pub healthy: bool,
}
/// Checkin response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckinResponse {
    #[prost(bool, tag="1")]
    pub checked_in: bool,
}
/// GetStats request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatsRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
}
/// GetStats response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatsResponse {
    #[prost(message, optional, tag="1")]
    pub metrics: ::core::option::Option<PoolMetrics>,
}
/// Scale request (manual scaling)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaleRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    #[prost(oneof="scale_request::ScaleType", tags="2, 3")]
    pub scale_type: ::core::option::Option<scale_request::ScaleType>,
}
/// Nested message and enum types in `ScaleRequest`.
pub mod scale_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ScaleType {
        /// Set to exact size
        #[prost(uint32, tag="2")]
        AbsoluteSize(u32),
        /// Add/remove N actors
        #[prost(int32, tag="3")]
        RelativeSize(i32),
    }
}
/// Scale response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaleResponse {
    #[prost(uint32, tag="1")]
    pub new_size: u32,
    #[prost(uint32, tag="2")]
    pub actors_added: u32,
    #[prost(uint32, tag="3")]
    pub actors_removed: u32,
}
/// PauseScaling request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseScalingRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
}
/// PauseScaling response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseScalingResponse {
    #[prost(bool, tag="1")]
    pub paused: bool,
}
/// ResumeScaling request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeScalingRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
}
/// ResumeScaling response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeScalingResponse {
    #[prost(bool, tag="1")]
    pub resumed: bool,
}
/// Drain request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrainRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    /// Wait for actors to finish
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Drain response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrainResponse {
    #[prost(bool, tag="1")]
    pub drained: bool,
    #[prost(uint32, tag="2")]
    pub actors_drained: u32,
}
/// DeletePool request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePoolRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    /// Force delete even with busy actors
    #[prost(bool, tag="2")]
    pub force: bool,
}
/// DeletePool response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePoolResponse {
    #[prost(bool, tag="1")]
    pub deleted: bool,
}
/// StreamMetrics request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamMetricsRequest {
    #[prost(string, tag="1")]
    pub pool_name: ::prost::alloc::string::String,
    /// Update frequency
    #[prost(message, optional, tag="2")]
    pub interval: ::core::option::Option<::prost_types::Duration>,
}
/// Pool scaling state
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScalingState {
    ScalingStateStable = 0,
    ScalingStateScalingUp = 1,
    ScalingStateScalingDown = 2,
    /// Manual override
    ScalingStatePaused = 3,
}
impl ScalingState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ScalingState::ScalingStateStable => "SCALING_STATE_STABLE",
            ScalingState::ScalingStateScalingUp => "SCALING_STATE_SCALING_UP",
            ScalingState::ScalingStateScalingDown => "SCALING_STATE_SCALING_DOWN",
            ScalingState::ScalingStatePaused => "SCALING_STATE_PAUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCALING_STATE_STABLE" => Some(Self::ScalingStateStable),
            "SCALING_STATE_SCALING_UP" => Some(Self::ScalingStateScalingUp),
            "SCALING_STATE_SCALING_DOWN" => Some(Self::ScalingStateScalingDown),
            "SCALING_STATE_PAUSED" => Some(Self::ScalingStatePaused),
            _ => None,
        }
    }
}
/// Actor state in pool
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PoolActorState {
    PoolActorStateAvailable = 0,
    PoolActorStateBusy = 1,
    PoolActorStateIdle = 2,
    PoolActorStateFailed = 3,
}
impl PoolActorState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PoolActorState::PoolActorStateAvailable => "POOL_ACTOR_STATE_AVAILABLE",
            PoolActorState::PoolActorStateBusy => "POOL_ACTOR_STATE_BUSY",
            PoolActorState::PoolActorStateIdle => "POOL_ACTOR_STATE_IDLE",
            PoolActorState::PoolActorStateFailed => "POOL_ACTOR_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POOL_ACTOR_STATE_AVAILABLE" => Some(Self::PoolActorStateAvailable),
            "POOL_ACTOR_STATE_BUSY" => Some(Self::PoolActorStateBusy),
            "POOL_ACTOR_STATE_IDLE" => Some(Self::PoolActorStateIdle),
            "POOL_ACTOR_STATE_FAILED" => Some(Self::PoolActorStateFailed),
            _ => None,
        }
    }
}
// ==================== Error Types ====================

/// Elastic pool error types
///
/// ## Purpose
/// Defines error types for elastic pool operations.
/// Used in error responses and for error handling in pool service.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ElasticPoolError {
    ElasticPoolErrorUnspecified = 0,
    /// Pool not found
    ElasticPoolErrorPoolNotFound = 1,
    /// Checkout timeout (waited too long for actor)
    ElasticPoolErrorCheckoutTimeout = 2,
    /// Pool exhausted (all actors busy, max size reached)
    ElasticPoolErrorPoolExhausted = 3,
    /// Circuit open (too many failures)
    ElasticPoolErrorCircuitOpen = 4,
    /// Pool draining (not accepting new requests)
    ElasticPoolErrorPoolDraining = 5,
    /// Invalid configuration
    ElasticPoolErrorInvalidConfig = 6,
    /// Actor error
    ElasticPoolErrorActorError = 7,
}
impl ElasticPoolError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ElasticPoolError::ElasticPoolErrorUnspecified => "ELASTIC_POOL_ERROR_UNSPECIFIED",
            ElasticPoolError::ElasticPoolErrorPoolNotFound => "ELASTIC_POOL_ERROR_POOL_NOT_FOUND",
            ElasticPoolError::ElasticPoolErrorCheckoutTimeout => "ELASTIC_POOL_ERROR_CHECKOUT_TIMEOUT",
            ElasticPoolError::ElasticPoolErrorPoolExhausted => "ELASTIC_POOL_ERROR_POOL_EXHAUSTED",
            ElasticPoolError::ElasticPoolErrorCircuitOpen => "ELASTIC_POOL_ERROR_CIRCUIT_OPEN",
            ElasticPoolError::ElasticPoolErrorPoolDraining => "ELASTIC_POOL_ERROR_POOL_DRAINING",
            ElasticPoolError::ElasticPoolErrorInvalidConfig => "ELASTIC_POOL_ERROR_INVALID_CONFIG",
            ElasticPoolError::ElasticPoolErrorActorError => "ELASTIC_POOL_ERROR_ACTOR_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ELASTIC_POOL_ERROR_UNSPECIFIED" => Some(Self::ElasticPoolErrorUnspecified),
            "ELASTIC_POOL_ERROR_POOL_NOT_FOUND" => Some(Self::ElasticPoolErrorPoolNotFound),
            "ELASTIC_POOL_ERROR_CHECKOUT_TIMEOUT" => Some(Self::ElasticPoolErrorCheckoutTimeout),
            "ELASTIC_POOL_ERROR_POOL_EXHAUSTED" => Some(Self::ElasticPoolErrorPoolExhausted),
            "ELASTIC_POOL_ERROR_CIRCUIT_OPEN" => Some(Self::ElasticPoolErrorCircuitOpen),
            "ELASTIC_POOL_ERROR_POOL_DRAINING" => Some(Self::ElasticPoolErrorPoolDraining),
            "ELASTIC_POOL_ERROR_INVALID_CONFIG" => Some(Self::ElasticPoolErrorInvalidConfig),
            "ELASTIC_POOL_ERROR_ACTOR_ERROR" => Some(Self::ElasticPoolErrorActorError),
            _ => None,
        }
    }
}
include!("plexspaces.pool.v1.tonic.rs");
// @@protoc_insertion_point(module)