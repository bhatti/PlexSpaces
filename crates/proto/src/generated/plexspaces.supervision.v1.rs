// @generated
// This file is @generated by prost-build.
/// Child specification
///
/// ## Erlang/OTP Equivalent
/// This maps to Erlang's child_spec:
/// ```erlang
/// #{id => ChildId,
///    start => {Module, Function, Args},
///    restart => permanent | temporary | transient,
///    shutdown => brutal_kill | Timeout | infinity,
///    type => worker | supervisor,
///    modules => \[Module\]}
/// ```
///
/// ## Design: Unified Child Reference
/// In PlexSpaces, both actors and supervisors are identified by ID.
/// - For actors: `actor_or_supervisor_id` is the actor ID
/// - For supervisors: `actor_or_supervisor_id` is the supervisor ID
/// - The `child_type` field distinguishes them
///
/// This follows Erlang's approach where supervisors are just special processes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildSpec {
    /// Unique identifier for this child within the supervisor
    /// This is the child's local name, like "worker1" or "db_supervisor"
    #[prost(string, tag="1")]
    pub child_id: ::prost::alloc::string::String,
    /// ID of the actor or supervisor to supervise
    /// - For actors: actor ID (e.g., "worker1@localhost")
    /// - For supervisors: supervisor ID (e.g., "db-supervisor")
    /// The supervisor monitors this process regardless of its type
    #[prost(string, tag="2")]
    pub actor_or_supervisor_id: ::prost::alloc::string::String,
    /// How to handle child failures
    #[prost(enumeration="RestartStrategy", tag="3")]
    pub restart_strategy: i32,
    /// Shutdown timeout for graceful termination
    /// - None/0 = brutal_kill (immediate)
    /// - Some(ms) = graceful shutdown with timeout
    /// - For supervisors: typically set high or infinity to allow children to shutdown
    ///
    /// Max 5 minutes
    #[prost(message, optional, tag="4")]
    pub shutdown_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Child type: actor (worker) or supervisor
    #[prost(enumeration="ChildType", tag="5")]
    pub child_type: i32,
    /// Metadata for child configuration
    /// Can include:
    /// - "start_module": Module name for recreation
    /// - "start_function": Function to call
    /// - "supervisor_strategy": For CHILD_TYPE_SUPERVISOR, its strategy
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Supervisor configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisorConfig {
    /// Supervision strategy
    #[prost(enumeration="SupervisionStrategy", tag="1")]
    pub strategy: i32,
    /// Maximum restart intensity (max restarts in period)
    ///
    /// 1 to 1000 restarts
    #[prost(uint32, tag="2")]
    pub max_restarts: u32,
    /// Time period for max_restarts
    ///
    /// 1 second to 1 hour
    #[prost(message, optional, tag="3")]
    pub within_period: ::core::option::Option<::prost_types::Duration>,
    /// Child specifications
    ///
    /// Max 1000 children
    #[prost(message, repeated, tag="4")]
    pub children: ::prost::alloc::vec::Vec<ChildSpec>,
    /// Supervisor metadata
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Supervisor state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisorState {
    /// Supervisor ID
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    /// Configuration
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<SupervisorConfig>,
    /// Current children
    ///
    /// Max 1000 children
    #[prost(message, repeated, tag="3")]
    pub children: ::prost::alloc::vec::Vec<ChildState>,
    /// Restart history
    ///
    /// Max 10K events
    #[prost(message, repeated, tag="4")]
    pub restart_history: ::prost::alloc::vec::Vec<RestartEvent>,
    /// Is supervisor active
    #[prost(bool, tag="5")]
    pub is_active: bool,
}
/// Child state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildState {
    /// Child specification
    #[prost(message, optional, tag="1")]
    pub spec: ::core::option::Option<ChildSpec>,
    /// Current state
    #[prost(enumeration="ChildStatus", tag="2")]
    pub status: i32,
    /// When child was started
    #[prost(message, optional, tag="3")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Number of restarts
    ///
    /// Max 10K restarts
    #[prost(uint32, tag="4")]
    pub restart_count: u32,
    /// Last restart time
    #[prost(message, optional, tag="5")]
    pub last_restart: ::core::option::Option<::prost_types::Timestamp>,
}
/// Restart event
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartEvent {
    /// Child that was restarted
    #[prost(string, tag="1")]
    pub child_id: ::prost::alloc::string::String,
    /// When restart occurred
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Reason for restart
    ///
    /// Error messages can be long
    #[prost(string, tag="3")]
    pub reason: ::prost::alloc::string::String,
    /// Which strategy was applied
    #[prost(enumeration="SupervisionStrategy", tag="4")]
    pub strategy: i32,
}
/// Supervisor statistics for monitoring and observability
///
/// ## Purpose
/// Provides runtime metrics for supervisor behavior, enabling:
/// - **Production Monitoring**: Track restart rates, failure patterns
/// - **Debugging**: Identify problematic actors or recurring failures
/// - **Capacity Planning**: Understand resource usage and stability
/// - **Alerting**: Detect when restart rates exceed thresholds
///
/// ## Why This Exists
/// In production distributed systems, supervisors are the fault tolerance backbone.
/// Without metrics, operators cannot answer critical questions:
/// - "Is this actor constantly restarting?"
/// - "What are the most common failure reasons?"
/// - "Is the system stable or thrashing?"
/// - "Do we need to adjust max_restarts thresholds?"
///
/// ## Metrics Tracked
///
/// ### Restart Counts
/// - **total_restarts**: All restart attempts (successful + failed)
/// - **successful_restarts**: Restarts that succeeded (actor back online)
/// - **failed_restarts**: Restarts that failed (couldn't bring actor back)
///
/// ### Success Rate Calculation
/// ```
/// success_rate = successful_restarts / total_restarts
/// Example: 95 successful / 100 total = 0.95 (95% success rate)
/// ```
///
/// ### Strategy Adaptations (Adaptive Strategy Only)
/// - **strategy_adaptations**: How many times adaptive strategy changed
/// - Tracks learning behavior of Adaptive supervision strategy
/// - High adaptation count indicates unstable failure patterns
///
/// ### Failure Patterns
/// - **failure_patterns**: Map of error reasons → occurrence count
/// - Enables root cause analysis: "80% of failures are 'database timeout'"
/// - Helps prioritize fixes for most common failures
///
/// ## Usage Examples
///
/// ### Alerting on High Restart Rate
/// ```rust
/// let stats = supervisor.stats().await;
/// if stats.total_restarts > 100 && stats.success_rate() < 0.90 {
///      alert("High restart rate with low success!");
/// }
/// ```
///
/// ### Debugging Failure Patterns
/// ```rust
/// let stats = supervisor.stats().await;
/// for (reason, count) in stats.failure_patterns {
///      if count > 10 {
///          println!("Common failure: {} ({} times)", reason, count);
///      }
/// }
/// ```
///
/// ### Capacity Planning
/// ```rust
/// let stats = supervisor.stats().await;
/// let restart_rate = stats.total_restarts as f64 / uptime_seconds;
/// if restart_rate > 1.0 {  // More than 1 restart/sec
///      scale_cluster();  // Need more capacity
/// }
/// ```
///
/// ## Integration with Metrics Systems
/// These stats can be exported to:
/// - **Prometheus**: `supervisor_restarts_total{supervisor="foo"}`
/// - **StatsD**: `supervisor.foo.restarts.total:100|c`
/// - **CloudWatch**: Custom metrics for AWS deployments
/// - **DataDog**: APM metrics for distributed tracing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisorStats {
    /// Total number of restart attempts (successful + failed)
    ///
    /// Monotonically increasing counter tracking all restart attempts
    /// since supervisor creation. Includes both successful restarts
    /// (actor back online) and failed restarts (couldn't recover).
    #[prost(uint64, tag="1")]
    pub total_restarts: u64,
    /// Number of successful restarts
    ///
    /// Counts restarts where the actor successfully came back online
    /// and resumed processing messages. Always <= total_restarts.
    #[prost(uint64, tag="2")]
    pub successful_restarts: u64,
    /// Number of failed restarts
    ///
    /// Counts restarts that failed (e.g., actor factory error, timeout).
    /// Always <= total_restarts.
    /// Invariant: total_restarts = successful_restarts + failed_restarts
    #[prost(uint64, tag="3")]
    pub failed_restarts: u64,
    /// Number of times adaptive strategy changed (Adaptive strategy only)
    ///
    /// Tracks how many times the Adaptive supervision strategy learned
    /// from failure patterns and switched strategies. Only increments
    /// for Adaptive strategy; always 0 for static strategies.
    ///
    /// Max 10K adaptations
    #[prost(uint32, tag="4")]
    pub strategy_adaptations: u32,
    /// Failure pattern histogram: error reason → count
    ///
    /// Maps failure reasons (error messages) to their occurrence count.
    /// Enables root cause analysis:
    /// - "database_timeout": 50 → Database connection issues
    /// - "out_of_memory": 10 → Resource exhaustion
    /// - "panic": 5 → Code bugs
    ///
    /// Use this to prioritize fixes for most common failure modes.
    #[prost(map="string, uint32", tag="5")]
    pub failure_patterns: ::std::collections::HashMap<::prost::alloc::string::String, u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSupervisorRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<SupervisorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSupervisorResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddChildRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub child_spec: ::core::option::Option<ChildSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddChildResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveChildRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub child_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSupervisorRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSupervisorRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    /// Max 5 minutes
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSupervisorStateRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSupervisorStateResponse {
    #[prost(message, optional, tag="1")]
    pub state: ::core::option::Option<SupervisorState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSupervisorsRequest {
    /// Optional filter
    #[prost(string, tag="1")]
    pub namespace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSupervisorsResponse {
    /// Max 10K supervisors
    #[prost(message, repeated, tag="1")]
    pub supervisors: ::prost::alloc::vec::Vec<SupervisorState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartChildRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub child_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSupervisorStatsRequest {
    #[prost(string, tag="1")]
    pub supervisor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSupervisorStatsResponse {
    #[prost(message, optional, tag="1")]
    pub stats: ::core::option::Option<SupervisorStats>,
}
/// / Supervision error details
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisionError {
    /// Error code
    #[prost(enumeration="SupervisionErrorCode", tag="1")]
    pub code: i32,
    /// Human-readable error message
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Additional context (child_id, supervisor_id, etc.)
    #[prost(map="string, string", tag="3")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Timestamp when error occurred
    #[prost(message, optional, tag="4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Supervision strategy determines how supervisor handles child failures
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SupervisionStrategy {
    SupervisionStrategyUnspecified = 0,
    /// Restart only the failed child
    OneForOne = 1,
    /// Restart all children if one fails
    OneForAll = 2,
    /// Restart failed child and all children started after it
    RestForOne = 3,
    /// Simple one-for-one: all children are identical
    SimpleOneForOne = 4,
}
impl SupervisionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SupervisionStrategy::SupervisionStrategyUnspecified => "SUPERVISION_STRATEGY_UNSPECIFIED",
            SupervisionStrategy::OneForOne => "ONE_FOR_ONE",
            SupervisionStrategy::OneForAll => "ONE_FOR_ALL",
            SupervisionStrategy::RestForOne => "REST_FOR_ONE",
            SupervisionStrategy::SimpleOneForOne => "SIMPLE_ONE_FOR_ONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUPERVISION_STRATEGY_UNSPECIFIED" => Some(Self::SupervisionStrategyUnspecified),
            "ONE_FOR_ONE" => Some(Self::OneForOne),
            "ONE_FOR_ALL" => Some(Self::OneForAll),
            "REST_FOR_ONE" => Some(Self::RestForOne),
            "SIMPLE_ONE_FOR_ONE" => Some(Self::SimpleOneForOne),
            _ => None,
        }
    }
}
/// Restart strategy for individual children
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RestartStrategy {
    RestartStrategyUnspecified = 0,
    /// Always restart child on failure
    Permanent = 1,
    /// Restart only on abnormal termination
    Transient = 2,
    /// Never restart child
    Temporary = 3,
}
impl RestartStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RestartStrategy::RestartStrategyUnspecified => "RESTART_STRATEGY_UNSPECIFIED",
            RestartStrategy::Permanent => "PERMANENT",
            RestartStrategy::Transient => "TRANSIENT",
            RestartStrategy::Temporary => "TEMPORARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESTART_STRATEGY_UNSPECIFIED" => Some(Self::RestartStrategyUnspecified),
            "PERMANENT" => Some(Self::Permanent),
            "TRANSIENT" => Some(Self::Transient),
            "TEMPORARY" => Some(Self::Temporary),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChildType {
    ChildTypeUnspecified = 0,
    ChildTypeActor = 1,
    ChildTypeSupervisor = 2,
}
impl ChildType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChildType::ChildTypeUnspecified => "CHILD_TYPE_UNSPECIFIED",
            ChildType::ChildTypeActor => "CHILD_TYPE_ACTOR",
            ChildType::ChildTypeSupervisor => "CHILD_TYPE_SUPERVISOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHILD_TYPE_UNSPECIFIED" => Some(Self::ChildTypeUnspecified),
            "CHILD_TYPE_ACTOR" => Some(Self::ChildTypeActor),
            "CHILD_TYPE_SUPERVISOR" => Some(Self::ChildTypeSupervisor),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChildStatus {
    ChildStatusUnspecified = 0,
    ChildStatusStarting = 1,
    ChildStatusRunning = 2,
    ChildStatusStopping = 3,
    ChildStatusStopped = 4,
    ChildStatusFailed = 5,
    ChildStatusRestarting = 6,
}
impl ChildStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChildStatus::ChildStatusUnspecified => "CHILD_STATUS_UNSPECIFIED",
            ChildStatus::ChildStatusStarting => "CHILD_STATUS_STARTING",
            ChildStatus::ChildStatusRunning => "CHILD_STATUS_RUNNING",
            ChildStatus::ChildStatusStopping => "CHILD_STATUS_STOPPING",
            ChildStatus::ChildStatusStopped => "CHILD_STATUS_STOPPED",
            ChildStatus::ChildStatusFailed => "CHILD_STATUS_FAILED",
            ChildStatus::ChildStatusRestarting => "CHILD_STATUS_RESTARTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHILD_STATUS_UNSPECIFIED" => Some(Self::ChildStatusUnspecified),
            "CHILD_STATUS_STARTING" => Some(Self::ChildStatusStarting),
            "CHILD_STATUS_RUNNING" => Some(Self::ChildStatusRunning),
            "CHILD_STATUS_STOPPING" => Some(Self::ChildStatusStopping),
            "CHILD_STATUS_STOPPED" => Some(Self::ChildStatusStopped),
            "CHILD_STATUS_FAILED" => Some(Self::ChildStatusFailed),
            "CHILD_STATUS_RESTARTING" => Some(Self::ChildStatusRestarting),
            _ => None,
        }
    }
}
/// Event propagation policy for hierarchical supervision trees
///
/// ## Purpose
/// Defines how events from child supervisors propagate to parent supervisors
/// in supervision trees, enabling configurable monitoring and observability.
///
/// ## Why This Exists
/// In hierarchical supervision trees, parent supervisors need to know about
/// child supervisor events for:
/// - Monitoring child supervisor health
/// - Detecting failure patterns across tree levels
/// - Implementing escalation policies
/// - Providing unified observability
///
/// ## Design Decisions
/// - **FORWARD_ALL**: Default Erlang/OTP behavior - transparent event flow
/// - **FILTER_CRITICAL**: Reduce noise for high-level supervisors
/// - **NO_PROPAGATION**: Isolate branches (child supervisor is autonomous)
///
/// ## Usage
/// ```rust
/// let child_supervisor = Supervisor::new(
///      "child",
///      SupervisionStrategy::OneForOne { max_restarts: 3, within_seconds: 60 }
/// );
///
/// // Parent supervisor receives all child events
/// parent.add_supervisor_child(
///      child_supervisor,
///      EventPropagation::FORWARD_ALL
/// );
/// ```
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventPropagation {
    /// Forward all events from child supervisor to parent
    /// (ChildStarted, ChildStopped, ChildFailed, ChildRestarted, etc.)
    EventPropagationForwardAll = 0,
    /// Only forward critical events (failures, max restarts exceeded)
    /// Filters out routine events (ChildStarted, ChildStopped)
    EventPropagationFilterCritical = 1,
    /// No event propagation - child supervisor is completely autonomous
    /// Parent only knows if child supervisor itself fails
    EventPropagationNone = 2,
}
impl EventPropagation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EventPropagation::EventPropagationForwardAll => "EVENT_PROPAGATION_FORWARD_ALL",
            EventPropagation::EventPropagationFilterCritical => "EVENT_PROPAGATION_FILTER_CRITICAL",
            EventPropagation::EventPropagationNone => "EVENT_PROPAGATION_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_PROPAGATION_FORWARD_ALL" => Some(Self::EventPropagationForwardAll),
            "EVENT_PROPAGATION_FILTER_CRITICAL" => Some(Self::EventPropagationFilterCritical),
            "EVENT_PROPAGATION_NONE" => Some(Self::EventPropagationNone),
            _ => None,
        }
    }
}
// ============================================================================
// Error Types (Proto-First Design)
// ============================================================================

/// / Supervision error types
/// /
/// / ## Design
/// / All supervision errors are defined in proto for:
/// / - Wire compatibility (gRPC error responses)
/// / - Language-agnostic error handling
/// / - Consistent error semantics across implementations
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SupervisionErrorCode {
    SupervisionErrorUnspecified = 0,
    /// Child management errors
    ChildNotFound = 1,
    ChildAlreadyExists = 2,
    ChildStartFailed = 3,
    ChildStopFailed = 4,
    /// Restart errors
    MaxRestartsExceeded = 5,
    RestartFailed = 6,
    /// Strategy errors
    InvalidStrategy = 7,
    InvalidChildSpec = 8,
    /// Supervisor errors
    SupervisorNotFound = 9,
    SupervisorAlreadyExists = 10,
    SupervisorNotActive = 11,
}
impl SupervisionErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SupervisionErrorCode::SupervisionErrorUnspecified => "SUPERVISION_ERROR_UNSPECIFIED",
            SupervisionErrorCode::ChildNotFound => "CHILD_NOT_FOUND",
            SupervisionErrorCode::ChildAlreadyExists => "CHILD_ALREADY_EXISTS",
            SupervisionErrorCode::ChildStartFailed => "CHILD_START_FAILED",
            SupervisionErrorCode::ChildStopFailed => "CHILD_STOP_FAILED",
            SupervisionErrorCode::MaxRestartsExceeded => "MAX_RESTARTS_EXCEEDED",
            SupervisionErrorCode::RestartFailed => "RESTART_FAILED",
            SupervisionErrorCode::InvalidStrategy => "INVALID_STRATEGY",
            SupervisionErrorCode::InvalidChildSpec => "INVALID_CHILD_SPEC",
            SupervisionErrorCode::SupervisorNotFound => "SUPERVISOR_NOT_FOUND",
            SupervisionErrorCode::SupervisorAlreadyExists => "SUPERVISOR_ALREADY_EXISTS",
            SupervisionErrorCode::SupervisorNotActive => "SUPERVISOR_NOT_ACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUPERVISION_ERROR_UNSPECIFIED" => Some(Self::SupervisionErrorUnspecified),
            "CHILD_NOT_FOUND" => Some(Self::ChildNotFound),
            "CHILD_ALREADY_EXISTS" => Some(Self::ChildAlreadyExists),
            "CHILD_START_FAILED" => Some(Self::ChildStartFailed),
            "CHILD_STOP_FAILED" => Some(Self::ChildStopFailed),
            "MAX_RESTARTS_EXCEEDED" => Some(Self::MaxRestartsExceeded),
            "RESTART_FAILED" => Some(Self::RestartFailed),
            "INVALID_STRATEGY" => Some(Self::InvalidStrategy),
            "INVALID_CHILD_SPEC" => Some(Self::InvalidChildSpec),
            "SUPERVISOR_NOT_FOUND" => Some(Self::SupervisorNotFound),
            "SUPERVISOR_ALREADY_EXISTS" => Some(Self::SupervisorAlreadyExists),
            "SUPERVISOR_NOT_ACTIVE" => Some(Self::SupervisorNotActive),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
