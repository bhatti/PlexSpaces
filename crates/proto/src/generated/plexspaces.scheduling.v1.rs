// @generated
// This file is @generated by prost-build.
/// Actor group for task routing (Layer 2)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorGroup {
    /// Group name (unique identifier)
    #[prost(string, tag="1")]
    pub group_name: ::prost::alloc::string::String,
    /// Actor IDs in this group
    #[prost(string, repeated, tag="2")]
    pub actor_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Group metadata (labels, annotations)
    #[prost(map="string, string", tag="3")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Scheduling decision made by background scheduler
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulingDecision {
    /// Request ID
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
    /// Selected node ID (if scheduled)
    #[prost(string, tag="2")]
    pub selected_node_id: ::prost::alloc::string::String,
    /// Selected node gRPC address
    #[prost(string, tag="3")]
    pub selected_node_address: ::prost::alloc::string::String,
    /// Decision timestamp
    #[prost(message, optional, tag="4")]
    pub decided_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Decision reason (for debugging/monitoring)
    #[prost(string, tag="5")]
    pub reason: ::prost::alloc::string::String,
    /// Score/priority of selected node (for comparison)
    #[prost(double, tag="6")]
    pub score: f64,
}
/// Scheduling request stored in state store
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulingRequest {
    /// Request ID (unique)
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
    /// Request details (imported from actor_runtime.proto)
    #[prost(message, optional, tag="2")]
    pub requirements: ::core::option::Option<super::super::actor::v1::ActorResourceRequirements>,
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Status
    #[prost(enumeration="SchedulingStatus", tag="5")]
    pub status: i32,
    /// Result (if scheduled)
    #[prost(string, tag="6")]
    pub selected_node_id: ::prost::alloc::string::String,
    /// Created actor ID
    #[prost(string, tag="7")]
    pub actor_id: ::prost::alloc::string::String,
    /// Error (if failed)
    #[prost(string, tag="8")]
    pub error_message: ::prost::alloc::string::String,
    /// Timestamps
    #[prost(message, optional, tag="9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="10")]
    pub scheduled_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="11")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request to schedule an actor
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleActorRequest {
    /// Actor resource requirements (imported from actor_runtime.proto)
    #[prost(message, optional, tag="1")]
    pub requirements: ::core::option::Option<super::super::actor::v1::ActorResourceRequirements>,
    /// Namespace (optional)
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    /// Tenant ID (optional)
    #[prost(string, tag="3")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Optional: Client-provided request ID (for idempotency)
    /// If not provided, server generates one
    #[prost(string, tag="4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response for schedule actor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleActorResponse {
    /// Request ID for tracking
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
    /// Immediate status (PENDING, SCHEDULED, or FAILED)
    #[prost(enumeration="SchedulingStatus", tag="2")]
    pub status: i32,
    /// If SCHEDULED: selected node ID
    #[prost(string, tag="3")]
    pub node_id: ::prost::alloc::string::String,
    /// If SCHEDULED: node gRPC address
    #[prost(string, tag="4")]
    pub node_address: ::prost::alloc::string::String,
    /// If FAILED: error message
    #[prost(string, tag="5")]
    pub error_message: ::prost::alloc::string::String,
    /// Timestamp
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request to get scheduling status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulingStatusRequest {
    /// Request ID
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response for get scheduling status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchedulingStatusResponse {
    /// Scheduling request
    #[prost(message, optional, tag="1")]
    pub request: ::core::option::Option<SchedulingRequest>,
}
/// Request to get node capacity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeCapacityRequest {
    /// Node ID
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
}
/// Response for get node capacity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeCapacityResponse {
    /// Node capacity (imported from node.proto)
    #[prost(message, optional, tag="1")]
    pub capacity: ::core::option::Option<super::super::node::v1::NodeCapacity>,
}
/// Request to list all node capacities
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeCapacitiesRequest {
    /// Optional: Filter by labels
    #[prost(map="string, string", tag="1")]
    pub label_filters: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Optional: Pagination
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageRequest>,
}
/// Response for list node capacities
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeCapacitiesResponse {
    /// Node capacities
    #[prost(message, repeated, tag="1")]
    pub capacities: ::prost::alloc::vec::Vec<NodeCapacityEntry>,
    /// Pagination
    #[prost(message, optional, tag="2")]
    pub page: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// Node capacity entry (node ID + capacity)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeCapacityEntry {
    /// Node ID
    #[prost(string, tag="1")]
    pub node_id: ::prost::alloc::string::String,
    /// Node capacity (imported from node.proto)
    #[prost(message, optional, tag="2")]
    pub capacity: ::core::option::Option<super::super::node::v1::NodeCapacity>,
}
/// Scheduling status enum
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SchedulingStatus {
    SchedulingStatusUnspecified = 0,
    /// Request accepted, queued for processing
    SchedulingStatusPending = 1,
    /// Successfully scheduled (node selected, actor will be spawned)
    SchedulingStatusScheduled = 2,
    /// Scheduling failed (no matching node, invalid request, etc.)
    SchedulingStatusFailed = 3,
}
impl SchedulingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SchedulingStatus::SchedulingStatusUnspecified => "SCHEDULING_STATUS_UNSPECIFIED",
            SchedulingStatus::SchedulingStatusPending => "SCHEDULING_STATUS_PENDING",
            SchedulingStatus::SchedulingStatusScheduled => "SCHEDULING_STATUS_SCHEDULED",
            SchedulingStatus::SchedulingStatusFailed => "SCHEDULING_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCHEDULING_STATUS_UNSPECIFIED" => Some(Self::SchedulingStatusUnspecified),
            "SCHEDULING_STATUS_PENDING" => Some(Self::SchedulingStatusPending),
            "SCHEDULING_STATUS_SCHEDULED" => Some(Self::SchedulingStatusScheduled),
            "SCHEDULING_STATUS_FAILED" => Some(Self::SchedulingStatusFailed),
            _ => None,
        }
    }
}
include!("plexspaces.scheduling.v1.tonic.rs");
// @@protoc_insertion_point(module)