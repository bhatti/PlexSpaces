// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2025 Shahzad A. Bhatti <bhatti@plexobject.com>
//
// This file is part of PlexSpaces.
//
// PlexSpaces is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 2.1 of the License, or
// (at your option) any later version.
//
// PlexSpaces is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with PlexSpaces. If not, see <https://www.gnu.org/licenses/>.

// PlexSpaces Actor Runtime API
//
// ## Purpose
// Defines THE core actor abstraction for PlexSpaces - the fundamental unit of computation
// that unifies Virtual Actors (Orbit/Orleans), OTP GenServers (Erlang), Durable Workflows
// (Restate), and Mobile Agents (Voyager). Rather than creating 20 different actor types,
// PlexSpaces provides ONE powerful Actor with composable capabilities via Facets.
//
// ## Architecture Context
// This proto file is **foundational to ALL PlexSpaces pillars** - it's the substrate upon
// which everything else is built:
// - **Pillar 1 (TupleSpace)**: Actors use TupleSpace for decoupled coordination
// - **Pillar 2 (Erlang/OTP)**: Actors implement GenServer, GenEvent, Supervisor patterns
// - **Pillar 3 (Durability)**: All actor operations journaled for replay after failures
// - **Pillar 4 (WASM)**: Actors execute as WASM modules for language-agnostic behavior
// - **Pillar 5 (Firecracker)**: Actors run in isolated microVMs for security
//
// ### The Actor Philosophy: Generalized Abstractions
// **Problem**: How to support Virtual Actors, Mobile Agents, OTP GenServers, Workflows
// WITHOUT creating 20 different implementations?
//
// **Solution**: ONE powerful Actor type + composable Facets
// ```
// Virtual Actor = Actor + VirtualActorFacet (Orbit-inspired activation)
// Mobile Agent = Actor + MobilityFacet (Voyager-inspired migration)
// GenServer = Actor + OTPGenServerFacet (Erlang patterns)
// Durable Workflow = Actor + DurableExecutionFacet + WorkflowFacet (Restate patterns)
// Stateless Worker = Actor + StatelessWorkerFacet (Orleans-inspired pools)
// Data-Parallel = Actor + DataParallelFacet (NSDI'22 lattice actors)
// ```
//
// ### Integration with Other PlexSpaces Components
// - **Used by**: SupervisionService (fault tolerance), WorkflowService (orchestration),
//   MobilityService (agent migration), TupleSpaceService (coordination), NodeService (placement)
// - **Depends on**: common.proto (Metadata, Facet, RetryPolicy), facets.proto (capability management)
// - **Provides**: Core abstraction for ALL distributed computation in PlexSpaces
//
// ## Design Decisions
// - **Why actor_id is plain string** (not wrapper message):
//   - Simplifies distributed lookup (no extra layer to unwrap)
//   - Human-readable for debugging (e.g., "namespace/counter-123")
//   - Compatible with various ID schemes (UUID, hierarchical, ULID)
//   - Works across all languages (no proto dependency for IDs)
//   - Format: "{namespace}/{actor_name}" or "{node_id}/{actor_name}"
//
// - **Why separate ActorState enum**:
//   - Enables state machine validation (can't go from TERMINATED to ACTIVE)
//   - Supervision logic uses state for restart decisions
//   - Clear lifecycle tracking for observability
//   - Supports graceful activation/deactivation (Orbit-inspired)
//
// - **Why facets field in Actor message**:
//   - **Core features are static** (lifecycle, supervision, messaging) - always present
//   - **Extensions are dynamic** (mobility, metrics, workflows) - attached via facets
//   - See "Static vs Dynamic Design Principle" in CLAUDE.md
//   - Avoids proto bloat (don't add every possible field to Actor)
//   - Enables user-defined capabilities (custom facets for domain-specific features)
//
// - **Why priority as int32** (not just High/Low):
//   - Allows N-level priorities (100+ levels)
//   - Standard mapping: Signal(100), System(75), High(50), Normal(25), Low(0)
//   - Enables fine-grained control plane vs data plane separation (Quickwit-inspired)
//   - Custom priority schemes possible (e.g., deadline-based priorities)
//
// - **Why TTL on messages**:
//   - Prevents message accumulation in failure scenarios (actor offline for hours)
//   - Enables automatic cleanup of stale messages (e.g., 5-minute-old price quote)
//   - Bounded memory growth in mailboxes
//   - Supports time-sensitive workflows (don't process expired requests)
//
// - **Why resource requirements** (ResourceRequirements message):
//   - Quickwit-inspired resource contracts for intelligent scheduling
//   - Enables bin-packing placement (optimize node utilization)
//   - Prevents OOM by rejecting actors that don't fit
//   - Supports heterogeneous clusters (GPU nodes, high-memory nodes)
//
// - **Why placement hints** (PlacementHint message):
//   - Orleans-inspired placement strategies
//   - Supports affinity (co-locate related actors)
//   - Enables custom placement logic (e.g., data locality)
//   - Balances between random (load) and deterministic (affinity)
//
// - **Why stateless worker config** (StatelessWorkerConfig):
//   - Orleans-inspired worker pools for stateless operations
//   - Scales horizontally without coordination (no single-actor bottleneck)
//   - Load balancing strategies (round-robin, least-loaded, random)
//   - Auto-scaling based on load (min/max instances)
//
// - **Why data-parallel config** (DataParallelConfig):
//   - NSDI'22 lattice actors pattern for coordination-free parallelism
//   - Enables sharding (partition state across actors)
//   - Supports rebalancing when shards added/removed
//   - Use with STATE_MGMT_MODE_LATTICE for CRDT-based state
//
// ## Core Design Principles (Implementation Priorities)
//
// These principles guide ALL implementation decisions in PlexSpaces. They are listed in
// priority order - foundational principles come first, advanced features come later.
//
// ### 1. Remoting First (Erlang/OTP Parity)
// **Why**: Actor-to-actor communication is fundamental to the actor model. Without remoting,
// we cannot properly test distributed supervision, clustering, or any distributed features.
//
// - **Location Transparency**: Same API for local and remote actors
//   - `actor_ref.send(message)` works whether actor is in same process or different node
//   - ActorRef abstracts physical location (like Erlang's `node@actor` addressing)
//   - Example: `send("local-node/actor-123", msg)` vs `send("remote-node/actor-456", msg)`
//
// - **gRPC for All Distribution**: All cross-node communication uses gRPC
//   - ActorService.Send for fire-and-forget messaging
//   - ActorService.Ask for request-reply patterns
//   - ActorService.Stream for bidirectional streaming
//   - See implementation phases in CLAUDE.md (Weeks 1-8)
//
// - **Test-Driven with Byzantine Generals**: Distributed consensus algorithm validates everything
//   - Phase 1: Local actors in single process (4 generals, 1 traitor)
//   - Phase 2: Remote actors across processes/VMs (distributed consensus)
//   - Phase 3: Distributed TupleSpace for coordination
//   - Phase 4: Cross-node supervision and fault tolerance
//
// ### 2. WebAssembly as Universal Runtime
// **CORE PRINCIPLE**: All actors compile to WASM for portability and dynamic deployment.
//
// - **Portable Execution**: Same actor runs on Docker/Kubernetes/Firecracker
//   - Actor code compiled to WASM module (.wasm file)
//   - WASM module executed by wasmtime/wasmer runtime
//   - No platform-specific binaries (works on x86, ARM, etc.)
//
// - **Dynamic Deployment**: Send WASM code to nodes at runtime (like Java classloader)
//   - DeployActorCodeRequest sends WASM bytes over gRPC
//   - Node compiles and caches WASM module
//   - Multiple actors instantiated from same WASM module
//   - Example: Deploy 100 "general" actors from single WASM module
//
// - **Sandboxed Isolation**: WASM provides secure execution boundaries
//   - Memory isolation (actor can't access other actors' memory)
//   - Resource limits (CPU time, memory allocation)
//   - Capability-based security (only allowed host functions)
//   - See Phase 6 in CLAUDE.md (Week 11-12)
//
// ### 3. Service Mesh for Non-Functional Requirements (Istio-Inspired)
// **CORE PRINCIPLE**: Embed Istio-like capabilities for security, reliability, observability.
//
// - **Security**:
//   - mTLS: Mutual TLS for all node-to-node communication
//   - Authentication: Node identity verification via certificates
//   - Authorization: RBAC for actor operations (who can spawn, send, query)
//
// - **Reliability**:
//   - Circuit Breaker: Fail fast on unhealthy nodes (prevent cascading failures)
//   - Retry Policies: Exponential backoff for transient failures
//   - Timeout Policies: Per-operation deadlines (prevent hanging requests)
//   - Load Balancing: Round-robin, least-connections, weighted distribution
//
// - **Observability**:
//   - Distributed Tracing: OpenTelemetry spans track message flow
//   - Metrics: Prometheus format (actor count, message rate, latency percentiles)
//   - Access Logs: Structured JSON logs for all actor operations
//
// - **Deployment Pattern**:
//   - Embedded: Service mesh logic in same process (no sidecar overhead)
//   - Sidecar: Optional Envoy proxy for advanced features (future)
//   - See Phase 8 in CLAUDE.md (Week 15-16)
//
// ### 4. Deployment Flexibility (Docker/Kubernetes/Firecracker)
// **CORE PRINCIPLE**: Actors run anywhere - containers, VMs, or bare metal.
//
// - **Docker/Kubernetes**: Standard container orchestration
//   - Dockerfile for node images
//   - Helm charts for deployment
//   - Service discovery via DNS (k8s services)
//   - See Phase 5 in CLAUDE.md (Week 9-10)
//
// - **Firecracker MicroVMs**: Strong isolation with low overhead
//   - Boot VMs in < 125ms (custom kernel + rootfs)
//   - Run WASM actors inside Firecracker VMs
//   - VM-to-VM networking via TAP devices
//   - See Phase 7 in CLAUDE.md (Week 13-14)
//
// ### 5. Durability AFTER Distributed Foundation (Restate-Inspired)
// **Why**: Journaling only makes sense once remoting and deployment work.
//
// - **Event Sourcing**: All actor operations journaled for replay
// - **Deterministic Replay**: Recover to exact pre-crash state
// - **Side Effect Caching**: External calls cached to avoid duplication
// - **Durable Promises**: Promises that survive actor failures
// - See Phase 9 in CLAUDE.md (Week 17-18)
//
// ### 6. Mobile Agents (Voyager-Inspired)
// **CORE PRINCIPLE**: Actors migrate with state + code + journal.
//
// - **State Migration**: Serialize and transfer actor state
// - **Code Migration**: Transfer WASM module to destination
// - **Journal Migration**: Move execution history for replay
// - **Resume Execution**: Continue from last journal entry after migration
// - See Phase 11 in CLAUDE.md (Week 21-22)
//
// ## Actor Lifecycle Examples
//
// ### Basic Actor Creation
// ```protobuf
// CreateActorRequest {
//   actor_type: "counter"
//   config: {
//     enable_persistence: true
//     checkpoint_interval: { seconds: 60 }
//     supervision_strategy: SUPERVISION_STRATEGY_ONE_FOR_ONE
//   }
// }
// // Result: Actor created in CREATING state, transitions to ACTIVATING -> ACTIVE
// ```
//
// ### Virtual Actor (Orbit-Inspired Auto-Activation)
// ```protobuf
// CreateActorRequest {
//   actor_type: "user-session"
//   config: { /* ... */ }
// }
// // Attach VirtualActorFacet to enable auto-activation
// AttachFacetRequest {
//   actor_id: "user-session-123"
//   facet_type: "virtual_actor"
//   config: {
//     "activation_strategy": "lazy",        // Activate on first message
//     "deactivation_timeout": "5m"          // Deactivate after 5 min idle
//   }
// }
// // Actor auto-activates on first message, auto-deactivates when idle
// ```
//
// ### Stateless Worker Pool (Orleans-Inspired)
// ```protobuf
// CreateActorRequest {
//   actor_type: "image-processor"
//   config: {
//     stateless_worker_config: {
//       max_instances: 100
//       min_instances: 5
//       strategy: LOAD_BALANCING_LEAST_LOADED
//     }
//     placement_hint: {
//       strategy: PLACEMENT_STRATEGY_RESOURCE_BASED
//       requirements: {
//         min_memory_mb: 512
//         min_cpu_cores: 1.0
//       }
//     }
//   }
// }
// // System auto-scales between 5-100 instances based on load
// ```
//
// ### Data-Parallel Actor Group (NSDI'22 Pattern)
// ```protobuf
// CreateActorRequest {
//   actor_type: "counter-shard"
//   config: {
//     data_parallel_config: {
//       group_id: "global-counter"
//       shard_count: 16
//       shard_id: 0  // Create shard 0
//       partition_strategy: PARTITION_STRATEGY_HASH
//       rebalance_policy: REBALANCE_POLICY_LOAD_BASED
//     }
//     state_management_mode: STATE_MGMT_MODE_LATTICE
//     consistency_level: CONSISTENCY_LEVEL_EVENTUAL
//   }
// }
// // Create 16 shards, each handles 1/16th of key space
// // State merges via CRDT (coordination-free)
// ```
//
// ## Message Passing Examples
//
// ### Fire-and-Forget (Async)
// ```protobuf
// SendMessageRequest {
//   message: {
//     id: "msg-001"
//     sender_id: "actor-a"
//     receiver_id: "actor-b"
//     message_type: "increment"
//     payload: [serialized data]
//     priority: 25  // Normal priority
//   }
//   wait_for_response: false
// }
// ```
//
// ### Request-Reply (Sync, Erlang gen_server:call pattern)
// ```protobuf
// SendMessageRequest {
//   message: {
//     id: "msg-002"
//     sender_id: "actor-a"
//     receiver_id: "actor-b"
//     message_type: "get_count"
//     payload: []
//     priority: 50  // High priority
//   }
//   wait_for_response: true
//   timeout: { seconds: 5 }
// }
// // Response: SendMessageResponse { message_id: "msg-002", response: {...} }
// ```
//
// ### Time-Sensitive Message (TTL)
// ```protobuf
// SendMessageRequest {
//   message: {
//     id: "msg-003"
//     receiver_id: "trader"
//     message_type: "price_quote"
//     payload: [quote data]
//     ttl: { seconds: 30 }  // Expire after 30 seconds
//   }
// }
// // Message dropped if not processed within 30s
// ```
//
// ## Actor State Transitions
//
// ### Normal Lifecycle
// ```
// CREATING (spawn)
//    ↓
// ACTIVATING (on_activate hook)
//    ↓
// ACTIVE (processing messages)
//    ↓
// DEACTIVATING (on_deactivate hook)
//    ↓
// INACTIVE (idle but restorable)
//    ↓
// TERMINATED (permanent deletion)
// ```
//
// ### Failure & Recovery
// ```
// ACTIVE (processing message)
//    ↓ [crash]
// FAILED
//    ↓ [supervisor restart]
// ACTIVATING (replay journal)
//    ↓
// ACTIVE (resume execution)
// ```
//
// ### Migration
// ```
// ACTIVE (on node-1)
//    ↓ [migrate request]
// MIGRATING (serialize state + journal)
//    ↓ [transfer to node-2]
// ACTIVATING (on node-2, restore state)
//    ↓
// ACTIVE (on node-2)
// ```

syntax = "proto3";

package plexspaces.actor.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/any.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "plexspaces/v1/common.proto";

option go_package = "github.com/bhatti/plexspaces/gen/go/plexspaces/v1;plexspacesv1";
option java_package = "com.bhatti.plexspaces.actor.v1";
option java_multiple_files = true;

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "PlexSpace Actor Runtime API";
    version: "1.0";
    description: "API for managing durable actors and their lifecycle";
  };
  schemes: HTTPS;
  consumes: "application/json";
  produces: "application/json";
};

// Actor message for inter-actor communication.
//
// ## Purpose
// Represents a single message sent from one actor to another with metadata
// for routing, priority, correlation, and time-to-live.
//
// ## Why This Exists
// - Enables asynchronous actor communication (fundamental to actor model)
// - Supports message priority for control vs data plane separation (Quickwit-inspired)
// - Provides correlation IDs for request-reply patterns (Erlang gen_server:call)
// - TTL prevents message accumulation in failure scenarios
// - Headers enable extensibility (tracing, auth, custom routing)
//
// ## Design Notes
// - sender_id is optional to support anonymous sends
// - priority maps to 5-level system: Signal(100), System(75), High(50), Normal(25), Low(0)
// - payload is opaque bytes, decoded by receiving actor's behavior
// - headers provide extensibility without proto changes
message Message {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Message"
      description: "Message sent between actors"
      required: ["id", "receiver_id", "message_type", "payload"]
    }
  };

  string id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}  // ULID format
  ];
  string sender_id = 2 [(buf.validate.field).string.max_len = 255];  // Optional, but bounded
  string receiver_id = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string message_type = 4 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128}  // call, cast, info, etc.
  ];
  bytes payload = 5 [(google.api.field_behavior) = REQUIRED];
  google.protobuf.Timestamp timestamp = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  int32 priority = 7 [(buf.validate.field).int32 = {gte: 0, lte: 100}];  // 5-level system: 0=Low, 25=Normal, 50=High, 75=System, 100=Signal
  google.protobuf.Duration ttl = 8 [(buf.validate.field).duration.lte.seconds = 86400];  // Max 24 hours
  map<string, string> headers = 9;

  // Optional idempotency key for message deduplication
  //
  // ## Purpose
  // Prevents accidental double-processing of messages within a time window (e.g., 24 hours).
  // If a message with the same idempotency_key is processed within the window, it's skipped.
  //
  // ## Usage
  // - Client generates unique idempotency key (e.g., UUID, request ID)
  // - System tracks processed keys in journal
  // - Duplicate messages within time window return cached response (if available)
  // - Fits durable execution model (Restate-inspired)
  //
  // ## Example
  // ```protobuf
  // Message {
  //   id: "msg-123"
  //   idempotency_key: "payment-request-abc-xyz"
  //   receiver_id: "payment-processor"
  //   payload: [payment data]
  // }
  // // If same idempotency_key processed within 24h, returns cached response
  // ```
  string idempotency_key = 10 [(buf.validate.field).string.max_len = 255];

  // URI path for HTTP-based invocations (optional)
  // Example: "/api/v1/actors/default/counter/metrics"
  // Populated when message originates from HTTP InvokeActor RPC
  string uri_path = 11;

  // HTTP method for HTTP-based invocations (optional)
  // Example: "GET", "POST", "PUT", "DELETE"
  // Populated when message originates from HTTP InvokeActor RPC
  string uri_method = 12;
}

// Actor instance representation.
//
// ## Purpose
// Defines the complete state of a durable actor instance including its
// identity, lifecycle state, configuration, resource usage, and attached capabilities.
//
// ## Why This Exists
// - Actors are the fundamental unit of computation in PlexSpaces (Pillar 2: Erlang/OTP)
// - Supports durable actors that survive restarts (Pillar 3: Restate durability)
// - Enables resource-aware scheduling (Quickwit-inspired resource contracts)
// - Provides facet extensibility (Static vs Dynamic principle)
// - Tracks metrics for monitoring and health checks
//
// ## Design Notes
// - actor_id uses ActorId from common.proto for consistency across services
// - state tracks lifecycle for supervision and recovery logic
// - node_id and vm_id support distributed placement and Firecracker isolation
// - facets enable dynamic capability composition without changing core proto
// - metrics enable health monitoring and auto-scaling decisions
message Actor {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor"
      description: "Durable actor instance"
      required: ["actor_id", "actor_type"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}  // ULID format
  ];
  string actor_type = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128, pattern: "^[a-z][a-z0-9_-]*$"}
  ];
  ActorState state = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  string node_id = 4 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.max_len = 255
  ];
  string vm_id = 5 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.max_len = 255
  ];
  bytes actor_state = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  plexspaces.common.v1.Metadata metadata = 7;
  ActorConfig config = 8;
  ActorMetrics metrics = 9 [(google.api.field_behavior) = OUTPUT_ONLY];

  // FACET EXTENSIBILITY: Attached facets provide additional capabilities
  // Examples: virtual_actor, otp_genserver, otp_supervisor, durable_execution, workflow
  repeated plexspaces.common.v1.Facet facets = 10;

  // MULTI-TENANCY: Isolation context for tenant separation and security
  // Enables hosting multiple customers/organizations on shared infrastructure
  // while maintaining strict resource and security boundaries
  plexspaces.common.v1.IsolationContext isolation = 11;

  // Schema version of actor_state serialization for format evolution
  //
  // ## Purpose
  // Enables safe actor state evolution across deployments and restarts.
  // Actors may be inactive for extended periods (days/weeks/months) and must
  // safely load old state when reactivated with newer actor code.
  //
  // ## Why This Exists
  // - Actor state schemas evolve over time (new fields, removed fields, type changes)
  // - Actors persist state to disk via checkpoints (see journaling.proto)
  // - Actors may migrate between nodes with different code versions
  // - Loading incompatible state causes corruption or panics
  // - Prevents data loss during rolling upgrades
  //
  // ## Version Rules
  // - **Version 0** = unversioned (legacy actors, assume version 1, best-effort deserialization)
  // - **Version >= 1** = explicit schema version tracked with actor state
  // - **Same version** (e.g., both v2) → Load directly, no migration needed
  // - **Older version** (state v1, actor v2) → Attempt migration if migration exists, else reject
  // - **Newer version** (state v3, actor v2) → **REJECT** with error (upgrade actor code first)
  //
  // ## Migration Strategy
  // ```
  // Version 1 → 2: Add new field with default value (backward compatible, no migration)
  // Version 2 → 3: Remove deprecated field (backward compatible, no migration)
  // Version 3 → 4: Change field type (BREAKING - requires explicit migration function)
  // Version 4 → 5: Restructure nested fields (BREAKING - requires migration)
  // ```
  //
  // ## Example Usage
  // ```rust
  // // Actor implementation defines current schema version
  // impl CounterActor {
  //     const SCHEMA_VERSION: u32 = 2;
  //
  //     fn save_state(&self) -> Result<Actor, PersistenceError> {
  //         Ok(Actor {
  //             actor_id: self.id.clone(),
  //             actor_state: serialize(&self.internal_state)?,
  //             actor_state_schema_version: Self::SCHEMA_VERSION,
  //             // ... other fields ...
  //         })
  //     }
  //
  //     fn load_state(actor: &Actor) -> Result<Self, PersistenceError> {
  //         // Version compatibility check
  //         match actor.actor_state_schema_version {
  //             // Same version - direct load
  //             v if v == Self::SCHEMA_VERSION => {
  //                 let state: CounterState = deserialize(&actor.actor_state)?;
  //                 Ok(Self::from_state(state))
  //             }
  //
  //             // Older version - migrate forward
  //             v if v < Self::SCHEMA_VERSION => {
  //                 let migrated = migrate_counter_state(
  //                     &actor.actor_state,
  //                     v,
  //                     Self::SCHEMA_VERSION,
  //                 )?;
  //                 let state: CounterState = deserialize(&migrated)?;
  //                 Ok(Self::from_state(state))
  //             }
  //
  //             // Newer version - reject (cannot load future state)
  //             v => Err(PersistenceError::IncompatibleSchemaVersion {
  //                 actor_version: Self::SCHEMA_VERSION,
  //                 state_version: v,
  //                 message: format!(
  //                     "Actor state v{} is newer than actor code v{}. Upgrade actor first.",
  //                     v, Self::SCHEMA_VERSION
  //                 ),
  //             }),
  //         }
  //     }
  // }
  // ```
  //
  // ## Integration with Checkpointing
  // This field works in conjunction with `Checkpoint.state_schema_version` from journaling.proto:
  // - **Actor.actor_state_schema_version**: Version of in-memory actor state (current)
  // - **Checkpoint.state_schema_version**: Version of checkpointed actor state (persistent)
  //
  // When creating checkpoint:
  // ```rust
  // let checkpoint = Checkpoint {
  //     actor_id: actor.actor_id.clone(),
  //     state_data: actor.actor_state.clone(),
  //     state_schema_version: actor.actor_state_schema_version,  // Copy version
  //     // ...
  // };
  // ```
  //
  // ## See Also
  // - `proto/plexspaces/v1/journaling.proto` - Checkpoint.state_schema_version (lines 241-321)
  // - `docs/SCHEMA_VERSIONING_REVIEW.md` - Complete versioning strategy
  // - Migration registry pattern for centralized v1→v2→v3 transitions
  uint32 actor_state_schema_version = 12;

  // Error message when actor is in FAILED state
  //
  // ## Purpose
  // Provides error details when actor.state == ACTOR_STATE_FAILED.
  // Used for debugging, logging, and supervisor restart decisions.
  //
  // ## Usage
  // - Only populated when state == ACTOR_STATE_FAILED
  // - Empty string when state != ACTOR_STATE_FAILED
  // - Contains error message from actor crash or failure
  string error_message = 13 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Actor lifecycle states.
//
// ## Purpose
// Defines the state machine for actor lifecycle management and supervision.
//
// ## Why This Exists
// - Enables supervision to track actor health and make restart decisions
// - Supports graceful activation/deactivation (Orbit-inspired auto-activation)
// - Allows migration state tracking for mobile agents
// - Provides clear state transitions for debugging and monitoring
//
// ## State Transitions
// ```
// CREATING -> ACTIVATING -> ACTIVE -> DEACTIVATING -> INACTIVE
//                        \-> MIGRATING -> ACTIVE (on new node)
//                        \-> FAILED -> (supervisor restarts)
//                        \-> TERMINATED (permanent stop)
// ```
//
// ## Design Notes
// - UNSPECIFIED should never occur in valid states (indicates error)
// - ACTIVATING/DEACTIVATING enable graceful lifecycle management
// - MIGRATING supports actor mobility between nodes
// - FAILED triggers supervisor restart policies
// - FAILED state includes error message for debugging (see Actor message for error details)
enum ActorState {
  ACTOR_STATE_UNSPECIFIED = 0;
  ACTOR_STATE_CREATING = 1;      // Actor is created but not yet started (replaces "Initializing")
  ACTOR_STATE_ACTIVE = 2;        // Actor is running and processing messages
  ACTOR_STATE_INACTIVE = 3;      // Actor is suspended/not processing (replaces "Suspended")
  ACTOR_STATE_ACTIVATING = 4;    // Actor is activating (loading state, running on_activate)
  ACTOR_STATE_DEACTIVATING = 5;  // Actor is deactivating (saving state, running on_deactivate)
  ACTOR_STATE_MIGRATING = 6;     // Actor is migrating to another node
  ACTOR_STATE_FAILED = 7;        // Actor has crashed (error message in Actor.error_message field)
  ACTOR_STATE_TERMINATED = 8;    // Actor has permanently stopped (replaces "Stopped")
}

// Actor configuration
message ActorConfig {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Config"
      description: "Configuration for actor behavior"
    }
  };

  google.protobuf.Duration mailbox_timeout = 1 [(buf.validate.field).duration.lte.seconds = 3600];  // Max 1 hour timeout
  uint32 max_mailbox_size = 2 [(buf.validate.field).uint32 = {gte: 1, lte: 1000000}];  // 1 to 1M messages
  bool enable_persistence = 3;
  google.protobuf.Duration checkpoint_interval = 4 [(buf.validate.field).duration = {gte: {seconds: 1}, lte: {seconds: 86400}}];  // 1 second to 24 hours
  plexspaces.common.v1.RetryPolicy restart_policy = 5;
  SupervisionStrategy supervision_strategy = 6;
  map<string, google.protobuf.Any> properties = 7;

  // Orleans-inspired placement configuration
  PlacementHint placement_hint = 10;

  // Orleans-inspired stateless worker configuration
  StatelessWorkerConfig stateless_worker_config = 11;

  // Data-parallel actor configuration (if part of actor group)
  DataParallelConfig data_parallel_config = 12;

  // State management mode (traditional vs lattice-based)
  StateMgmtMode state_management_mode = 13;

  // Consistency level for lattice-based actors
  ConsistencyLevel consistency_level = 14;

  // Resource-aware scheduling: Actor resource requirements
  ActorResourceRequirements resource_requirements = 16;

  // Actor groups (for task routing and co-scheduling)
  repeated string actor_groups = 17 [(buf.validate.field).repeated.items.string = {min_len: 1, max_len: 255}];

  // NOTE: Actors are ALWAYS isolated (Erlang/OTP principle)
  //
  // ## Design Decision: No Execution Isolation Modes
  // Unlike Swift (which has both classes and actors), PlexSpaces follows the pure
  // actor model (Erlang/OTP) where:
  // - ✅ Actors are ALWAYS isolated (single-threaded message processing)
  // - ✅ Communication is ALWAYS via message passing (mailbox)
  // - ✅ No shared mutable state between actors
  // - ❌ No "nonisolated" mode - isolation is inherent to actors
  //
  // Swift needed isolated/nonisolated because it has classes (shared state).
  // We don't have that problem - actors ARE the isolation boundary.
  //
  // For concurrent read-only operations, use:
  // - StatelessWorkerConfig (Orleans-inspired worker pools)
  // - DataParallelConfig (CRDT-based coordination-free parallelism)
  //
  // See PROTO_FIRST_AUDIT.md for why execution modes were removed.

  // Schema version of properties map for configuration evolution
  //
  // ## Purpose
  // Enables safe evolution of actor configuration across deployments.
  // The `properties` map (field 7) contains opaque configuration that may
  // change as actor types evolve, requiring versioning for compatibility.
  //
  // ## Why This Exists
  // - Actor configuration schemas evolve (new config options, deprecated settings)
  // - Actors may be created with old config and reactivated with new code
  // - Configuration migration needed during rolling upgrades
  // - Prevents invalid configuration causing actor startup failures
  //
  // ## Version Rules
  // - **Version 0** = unversioned (legacy config, assume version 1)
  // - **Version >= 1** = explicit config schema version
  // - **Same version** → Use config directly
  // - **Older version** → Migrate config forward (e.g., add new defaults, remove deprecated)
  // - **Newer version** → REJECT (upgrade actor code first)
  //
  // ## Example Migration
  // ```rust
  // // Version 1: Simple timeout config
  // properties: {"timeout_ms": 5000}
  //
  // // Version 2: Added retry config (backward compatible)
  // properties: {
  //     "timeout_ms": 5000,
  //     "max_retries": 3,      // NEW: defaults to 3
  //     "retry_backoff_ms": 100 // NEW: defaults to 100ms
  // }
  //
  // // Migration v1→v2: Add defaults for new fields
  // fn migrate_config_v1_to_v2(config: &mut ActorConfig) {
  //     config.properties.entry("max_retries").or_insert(Any::from(3u32));
  //     config.properties.entry("retry_backoff_ms").or_insert(Any::from(100u32));
  //     config.config_schema_version = 2;
  // }
  // ```
  //
  // ## See Also
  // - `Actor.actor_state_schema_version` - For actor state versioning
  // - `docs/SCHEMA_VERSIONING_REVIEW.md` - Complete versioning strategy
  uint32 config_schema_version = 15;
}

// Placement strategy for actor activation (Orleans-inspired)
enum PlacementStrategy {
  PLACEMENT_STRATEGY_UNSPECIFIED = 0;
  PLACEMENT_STRATEGY_RANDOM = 1;          // Random node selection
  PLACEMENT_STRATEGY_PREFER_LOCAL = 2;    // Co-locate with caller
  PLACEMENT_STRATEGY_LOAD_BASED = 3;      // Balance by load
  PLACEMENT_STRATEGY_RESOURCE_BASED = 4;  // Based on resource availability
  PLACEMENT_STRATEGY_AFFINITY = 5;        // Affinity groups
  PLACEMENT_STRATEGY_CUSTOM = 99;         // User-defined
}

// Resource requirements for placement
message ResourceRequirements {
  uint64 min_memory_mb = 1 [(buf.validate.field).uint64.lte = 1048576];  // Max 1TB
  double min_cpu_cores = 2 [(buf.validate.field).double = {gte: 0.1, lte: 128.0}];  // 0.1 to 128 cores
  repeated string required_capabilities = 3 [(buf.validate.field).repeated.items.string = {min_len: 1, max_len: 128}];
  map<string, string> custom_requirements = 4;
}

// Placement hint for actor activation
message PlacementHint {
  PlacementStrategy strategy = 1;
  string preferred_node_id = 2 [(buf.validate.field).string.max_len = 255];
  map<string, string> affinity_labels = 3;
  ResourceRequirements requirements = 4;
}

// Actor resource requirements for resource-aware scheduling
message ActorResourceRequirements {
  // Required resources (CPU, memory, disk, GPU)
  plexspaces.common.v1.ResourceSpec resources = 1;
  
  // Required node labels (Kubernetes-inspired label selector)
  // All labels must match for node to be eligible
  map<string, string> required_labels = 2;
  
  // Placement preferences
  PlacementPreferences placement = 3;
  
  // Actor groups (for task routing and co-scheduling)
  repeated string actor_groups = 4 [(buf.validate.field).repeated.items.string = {min_len: 1, max_len: 255}];
}

// Placement preferences for resource-aware scheduling
message PlacementPreferences {
  // Placement strategy
  PlacementStrategy strategy = 1;
  
  // Preferred node IDs (hint, not requirement)
  repeated string preferred_node_ids = 2 [(buf.validate.field).repeated.items.string = {min_len: 1, max_len: 255}];
  
  // Avoid node IDs (anti-affinity)
  repeated string avoid_node_ids = 3 [(buf.validate.field).repeated.items.string = {min_len: 1, max_len: 255}];
}

// Stateless worker configuration (Orleans-inspired)
message StatelessWorkerConfig {
  // Maximum number of concurrent instances
  uint32 max_instances = 1 [(buf.validate.field).uint32 = {gte: 1, lte: 10000}];

  // Minimum number of instances to keep warm
  uint32 min_instances = 2 [(buf.validate.field).uint32.lte = 10000];

  // Load balancing strategy
  LoadBalancingStrategy strategy = 3;
}

enum LoadBalancingStrategy {
  LOAD_BALANCING_UNSPECIFIED = 0;
  LOAD_BALANCING_ROUND_ROBIN = 1;
  LOAD_BALANCING_LEAST_LOADED = 2;
  LOAD_BALANCING_RANDOM = 3;
}

// Partition strategy for data-parallel actors
enum PartitionStrategy {
  PARTITION_STRATEGY_UNSPECIFIED = 0;
  PARTITION_STRATEGY_HASH = 1;           // Hash-based partitioning (default)
  PARTITION_STRATEGY_RANGE = 2;          // Range-based partitioning
  PARTITION_STRATEGY_CONSISTENT_HASH = 3; // Consistent hashing
  PARTITION_STRATEGY_CUSTOM = 99;        // User-defined partitioner
}

// Rebalancing policy for data-parallel actors
enum RebalancePolicy {
  REBALANCE_POLICY_UNSPECIFIED = 0;
  REBALANCE_POLICY_NONE = 1;        // No automatic rebalancing
  REBALANCE_POLICY_ON_SCALE = 2;    // Rebalance when shards added/removed
  REBALANCE_POLICY_LOAD_BASED = 3;  // Rebalance based on load metrics
}

// Data-parallel actor configuration
message DataParallelConfig {
  // Actor group ID this actor belongs to
  string group_id = 1 [(buf.validate.field).string = {min_len: 1, max_len: 255}];

  // Total number of shards in the group
  uint32 shard_count = 2 [(buf.validate.field).uint32 = {gte: 1, lte: 10000}];

  // This actor's shard ID (0 to shard_count-1)
  uint32 shard_id = 3 [(buf.validate.field).uint32.lte = 10000];

  // Partitioning strategy
  PartitionStrategy partition_strategy = 4;

  // Rebalancing policy
  RebalancePolicy rebalance_policy = 5;
}

// State management mode (lattice-based data-parallel actors)
enum StateMgmtMode {
  STATE_MGMT_MODE_UNSPECIFIED = 0;
  STATE_MGMT_MODE_TRADITIONAL = 1;  // Regular mutable state
  STATE_MGMT_MODE_LATTICE = 2;      // Coordination-free lattice state (CRDT)
}

// Consistency level for lattice-based actors
enum ConsistencyLevel {
  CONSISTENCY_LEVEL_UNSPECIFIED = 0;
  CONSISTENCY_LEVEL_EVENTUAL = 1;      // No ordering guarantees
  CONSISTENCY_LEVEL_CAUSAL = 2;        // Causal consistency (vector clocks)
  CONSISTENCY_LEVEL_READ_COMMITTED = 3; // Read committed isolation
  CONSISTENCY_LEVEL_LINEARIZABLE = 4;   // Strict consistency (coordination required)
}

// Supervision strategies
enum SupervisionStrategy {
  SUPERVISION_STRATEGY_UNSPECIFIED = 0;
  SUPERVISION_STRATEGY_ONE_FOR_ONE = 1;
  SUPERVISION_STRATEGY_ONE_FOR_ALL = 2;
  SUPERVISION_STRATEGY_REST_FOR_ONE = 3;
}

// Actor performance metrics
message ActorMetrics {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Metrics"
      description: "Performance metrics for an actor"
    }
  };

  uint64 messages_processed = 1;
  uint64 messages_failed = 2;
  google.protobuf.Duration average_processing_time = 3 [(buf.validate.field).duration.lte.seconds = 3600];  // Max 1 hour per message
  uint64 restarts = 4;
  google.protobuf.Timestamp last_activity = 5;
  uint64 memory_usage_bytes = 6 [(buf.validate.field).uint64.lte = 1099511627776];  // Max 1TB
  double cpu_usage_percent = 7 [(buf.validate.field).double = {gte: 0.0, lte: 100.0}];
}

// Request to create an actor
//
// ## Design Principle
// CreateActor ALWAYS creates actors locally on the node where the gRPC call is made.
// There is no node_id field - the actor is always created on the node receiving the request.
//
// To spawn an actor on a remote node:
// 1. Call CreateActor on that remote node's ActorService directly, OR
// 2. Use SpawnActor RPC (which also must be called on the target node)
//
// ## Example
// ```rust
// // Create actor locally on node1
// let client1 = ActorServiceClient::connect("http://node1:9001").await?;
// let response = client1.create_actor(CreateActorRequest { actor_type: "worker", ... }).await?;
// // Actor is created on node1
//
// // Create actor on remote node2
// let client2 = ActorServiceClient::connect("http://node2:9002").await?;
// let response = client2.create_actor(CreateActorRequest { actor_type: "worker", ... }).await?;
// // Actor is created on node2
// ```
message CreateActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Create Actor Request"
      description: "Request to create a new actor instance on the local node (where this RPC is called)"
      required: ["actor_type"]
    }
  };

  string actor_type = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128, pattern: "^[a-z][a-z0-9_-]*$"}
  ];
  bytes initial_state = 3;
  ActorConfig config = 4;
  map<string, string> labels = 5;
}

message CreateActorResponse {
  Actor actor = 1;
}

// Request to spawn an actor on a specific remote node (Erlang spawn/4 equivalent)
//
// ## Purpose
// Spawns an actor on a specified remote node using pre-deployed actor type.
// Returns an ActorRef for location-transparent messaging.
//
// ## Erlang Philosophy
// In Erlang:
// ```erlang
// % Local spawn (current node)
// Pid = spawn(Module, Function, Args)
//
// % Remote spawn (specific node)
// Pid = spawn(Node, Module, Function, Args)
// ```
// - Node: Target node (atom, e.g., 'worker@host1')
// - Module: Pre-compiled module on remote node (e.g., 'gen_server')
// - Function: Exported function to run (e.g., 'start_link')
// - Args: Arguments to function (e.g., [initial_state])
// - Returns: Pid that works for local and remote sends (location transparent)
//
// ## PlexSpaces Approach
// ```rust
// // Local spawn (current node)
// let actor = node.spawn_actor("worker", state, config).await?;
//
// // Remote spawn (specific node)
// let actor_ref = node.spawn_remote("node2", "worker", state, config).await?;
// ```
// - target_node_id: Target node (string, e.g., "node2")
// - actor_type: Pre-deployed actor type on remote node (string, e.g., "worker")
// - initial_state: Serialized initial state (bytes)
// - config: Actor configuration
// - Returns: ActorRef in format "actor_id@node_id" for location-transparent messaging
//
// ## Key Assumptions (Erlang-Compatible)
// 1. **Code Pre-Deployed**: The actor_type must already exist on the target node
//    - Like Erlang: Module must be loaded on remote node
//    - Use CreateActor first to deploy actor type, or ensure it's in node's registry
// 2. **Location Transparency**: Returned ActorRef works the same for local and remote sends
//    - Like Erlang: Pid works for both local send (Pid ! Msg) and remote send
//    - ActorRef.tell() / ActorRef.ask() automatically routes to correct node
//
// ## Extensibility for WASM (Future - Week 11-12)
// Phase 6 will add dynamic WASM deployment support via reserved fields:
// ```protobuf
// oneof code_source {
//   string actor_type = 2;        // Pre-deployed type (current)
//   WasmModule wasm_module = 10;  // Deploy WASM on-the-fly (future)
//   string wasm_url = 11;         // Fetch WASM from URL (future)
// }
// ```
// This enables:
// - **Pre-deployed**: spawn_remote("node2", "worker", ...) - code already on node2
// - **Dynamic WASM**: spawn_remote_wasm("node2", wasm_bytes, ...) - deploy code + spawn
// - **URL-based**: spawn_remote_url("node2", "https://cdn/worker.wasm", ...) - fetch + deploy + spawn
//
// ## Use Cases
// 1. **Distributed Testing**: Spawn Byzantine generals on specific nodes
//    ```rust
//    for (i, node) in nodes.iter().enumerate() {
//        node.spawn_remote(&node.id, "general", state, config).await?;
//    }
//    ```
// 2. **Load Distribution**: Explicitly place workers across cluster
//    ```rust
//    let worker_node = pick_least_loaded_node();
//    worker_node.spawn_remote(&worker_node.id, "worker", state, config).await?;
//    ```
// 3. **Data Locality**: Spawn actor near data source
//    ```rust
//    let db_node = find_node_with_shard(shard_id);
//    db_node.spawn_remote(&db_node.id, "processor", state, config).await?;
//    ```
// 4. **Affinity**: Co-locate related actors on same node
//    ```rust
//    let parent_node = get_actor_node(&parent_id);
//    parent_node.spawn_remote(&parent_node.id, "child", state, config).await?;
//    ```
//
// ## Comparison to CreateActor
// | Feature | CreateActor | SpawnActor |
// |---------|-------------|------------------|
// | Node selection | Placement strategy / current node | Explicit target node |
// | Use case | General actor creation | Explicit remote placement |
// | Fallback | Can fall back to other nodes | Fails if target unavailable |
// | Erlang equivalent | spawn/3 (local) | spawn/4 (remote) |
// | Code deployment | Any node can have code | Target node must have code |
//
// ## Implementation Flow
// When node1 calls SpawnRemoteActor targeting node2:
// 1. node1 validates target_node_id exists in registry
// 2. node1 sends gRPC SpawnRemoteActor request to node2
// 3. node2 validates actor_type exists in local registry
// 4. node2 spawns actor locally: Actor::spawn(actor_type, state, config)
// 5. node2 returns ActorRef with format "actor-123@node2"
// 6. node1 caches remote ActorRef for future messaging
// 7. Subsequent tell/ask automatically routes via gRPC to node2
message SpawnActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Spawn Remote Actor Request"
      description: "Spawn actor on the node receiving this gRPC request (target node is implicit from endpoint)"
      required: ["actor_type"]
    }
  };

  // Pre-deployed actor type name (REQUIRED)
  // Must exist in target node's actor registry
  // Examples: "worker", "general", "counter", "session"
  //
  // Future (Week 11-12): Will become part of `oneof code_source` to support WASM:
  // - actor_type: Use pre-deployed type (current)
  // - wasm_module: Deploy WASM bytecode on-the-fly
  // - wasm_url: Fetch WASM from URL
  string actor_type = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128, pattern: "^[a-z][a-z0-9_-]*$"}
  ];

  // Optional: Client-specified actor ID (for virtual actors)
  // If provided: Use this ID (must be unique, format: "{actor_type}/{key}" or "{actor_type}@{key}")
  // If not provided: Server generates ULID
  // Examples: "user/123", "session/abc-xyz", "counter@node1"
  // Industry standard: Client-specified IDs for virtual actors (Orleans pattern)
  string actor_id = 2 [
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  // Optional serialized initial state for actor
  // Format depends on actor type (actor deserializes)
  bytes initial_state = 3;

  // Optional actor configuration
  // If not provided, target node uses default config for actor_type
  ActorConfig config = 4;

  // Optional labels for tagging and filtering
  // Examples: {"env": "prod", "team": "platform", "version": "v2"}
  map<string, string> labels = 5;

  // RESERVED for future WASM support (Week 11-12)
  // When WASM support is added, these fields will be used:
  // - bytes wasm_module = 10;        // WASM bytecode for dynamic deployment
  // - string wasm_url = 11;          // URL to fetch WASM module
  // - string wasm_checksum = 12;     // SHA256 for cache validation
  // - map<string, string> wasm_env = 13; // Environment variables for WASM
  reserved 10 to 20;
}

// Response from SpawnActor
//
// ## Purpose
// Returns reference to newly spawned actor on the node receiving the request.
//
// ## Design Notes
// - actor_ref: String in format "actor_id@target_node_id"
//   - Can be used immediately for tell/ask operations
//   - Location transparent - same API as local actors
//   - Example: "actor-abc123@node2"
// - actor: Full Actor details for inspection
//   - Contains state, config, metrics, etc.
//   - Useful for monitoring and debugging
message SpawnActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Spawn Remote Actor Response"
      description: "Reference to remotely spawned actor"
      required: ["actor_ref"]
    }
  };

  // Reference to spawned actor (format: "actor_id@node_id")
  // Example: "general-1@node2", "worker-abc@prod-7"
  // Use this for messaging: actor_ref.tell(msg), actor_ref.ask(msg)
  string actor_ref = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 512}  // actor_id@node_id format
  ];

  // Full actor details (state, config, metrics)
  // Useful for inspection and monitoring
  Actor actor = 2;
}

// Request to get an actor
message GetActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Get Actor Request"
      description: "Request to retrieve an actor by ID"
      required: ["actor_id"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
}

message GetActorResponse {
  Actor actor = 1;
}

// Request to list actors
message ListActorsRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "List Actors Request"
      description: "Request to list actors with filtering"
    }
  };

  plexspaces.common.v1.PageRequest page_request = 1;
  string actor_type = 2 [(buf.validate.field).string.max_len = 128];
  ActorState state = 3;
  string node_id = 4 [(buf.validate.field).string.max_len = 255];
}

message ListActorsResponse {
  repeated Actor actors = 1;
  plexspaces.common.v1.PageResponse page_response = 2;
}

// Request to send a message
message SendMessageRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Send Message Request" 
      description: "Request to send a message to an actor"
      required: ["message"]
    }
  };

  Message message = 1 [(google.api.field_behavior) = REQUIRED];
  bool wait_for_response = 2;
  google.protobuf.Duration timeout = 3 [(buf.validate.field).duration.lte.seconds = 3600];  // Max 1 hour timeout
}

message SendMessageResponse {
  string message_id = 1 [(buf.validate.field).string = {min_len: 1, max_len: 255}];
  Message response = 2; // Only if wait_for_response = true
}

// Request for streaming messages (high-throughput)
message StreamMessageRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Stream Message Request"
      description: "Request to stream a message to an actor"
      required: ["message"]
    }
  };

  Message message = 1 [(google.api.field_behavior) = REQUIRED];
  // Sequence number for ordering (client-generated)
  uint64 sequence = 2;
}

// Response for streaming messages
message StreamMessageResponse {
  string message_id = 1 [(buf.validate.field).string = {min_len: 1, max_len: 255}];
  // Acknowledgement of sequence number
  uint64 sequence = 2;
  // Status: "delivered", "failed", "queued"
  string status = 3 [(buf.validate.field).string = {min_len: 1, max_len: 32}];
  // Optional error message
  string error = 4 [(buf.validate.field).string.max_len = 1024];
}

// Request to activate/deactivate actor
message SetActorStateRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Set Actor State Request"
      description: "Request to change actor state"
      required: ["actor_id", "target_state"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  ActorState target_state = 2 [(google.api.field_behavior) = REQUIRED];
  bool force = 3;
}

message SetActorStateResponse {
  Actor actor = 1;
}

// Request to migrate actor
message MigrateActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Migrate Actor Request"
      description: "Request to migrate actor to different node"
      required: ["actor_id", "target_node_id"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string target_node_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  bool preserve_state = 3;
}

message MigrateActorResponse {
  Actor actor = 1;
}

// Request to delete actor
message DeleteActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Delete Actor Request"
      description: "Request to delete an actor"
      required: ["actor_id"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  bool force = 2;
}

// NOTE: Facet management (AttachFacet, DetachFacet, etc.) is handled by
// FacetService in facets.proto to avoid duplication.

// ============================================================================
// Actor Lifecycle Events
// ============================================================================

// Actor lifecycle event
//
// ## Purpose
// Represents a state transition in an actor's lifecycle. Used for monitoring,
// observability, and triggering supervision actions.
//
// ## Architecture Context
// - Emitted by Actor implementation when state changes occur
// - Consumed by Node for monitoring callbacks
// - Consumed by observability systems (metrics, tracing, logging)
// - Enables location-transparent monitoring (Erlang-style)
//
// ## Design Decisions
// - Proto-based for distributed type safety across nodes
// - event_type as oneof for type-safe event variants
// - Timestamp for event ordering and time-travel debugging
// - Extensible for future event types without breaking changes
//
// ## Usage
// ```rust
// // Actor emits event
// let event = ActorLifecycleEvent {
//     actor_id: "worker@node1".to_string(),
//     timestamp: Some(Timestamp::now()),
//     event_type: Some(actor_lifecycle_event::EventType::Terminated(
//         ActorTerminated { reason: "normal".to_string() }
//     )),
// };
// node.handle_lifecycle_event(event).await?;
// ```
message ActorLifecycleEvent {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Lifecycle Event"
      description: "Actor state transition event for monitoring and observability"
      required: ["actor_id", "timestamp", "event_type"]
    }
  };

  // Actor that emitted this event
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  // When event occurred
  google.protobuf.Timestamp timestamp = 2 [(google.api.field_behavior) = REQUIRED];

  // Event-specific data (oneof ensures type safety)
  oneof event_type {
    ActorCreated created = 10;
    ActorStarting starting = 11;
    ActorActivated activated = 12;
    ActorDeactivating deactivating = 13;
    ActorDeactivated deactivated = 14;
    ActorTerminated terminated = 15;
    ActorFailed failed = 16;
    ActorMigrating migrating = 17;
  }
}

// Actor created (construction complete, not yet started)
//
// ## Purpose
// Emitted after Actor::new() completes successfully.
//
// ## State Transition
// [none] -> Created
//
// ## Supervisor Action
// None (waiting for activation)
message ActorCreated {
  // Reserved for future metadata
}

// Actor starting (spawning message processing task)
//
// ## Purpose
// Emitted when Actor::start() is called, before tokio::spawn().
//
// ## State Transition
// Created -> Starting
//
// ## Supervisor Action
// None (normal startup)
message ActorStarting {
  // Reserved for future metadata
}

// Actor activated (ready to process messages)
//
// ## Purpose
// Emitted after actor's message loop starts and on_activate() hook completes.
//
// ## State Transition
// Starting -> Activated
//
// ## Supervisor Action
// None (actor running normally)
message ActorActivated {
  // Reserved for future metadata
}

// Actor deactivating (graceful shutdown initiated)
//
// ## Purpose
// Emitted when actor receives shutdown signal or supervisor requests stop.
//
// ## State Transition
// Activated -> Deactivating
//
// ## Supervisor Action
// None (expected shutdown)
message ActorDeactivating {
  // Why deactivation was initiated
  // Examples: "supervisor_shutdown", "manual_stop", "timeout_idle"
  string reason = 1 [(buf.validate.field).string.max_len = 256];
}

// Actor deactivated (shutdown complete, but not destroyed)
//
// ## Purpose
// Emitted after on_deactivate() hook completes. Actor can be reactivated.
//
// ## State Transition
// Deactivating -> Deactivated
//
// ## Supervisor Action
// None (actor cleanly stopped, can be restarted if needed)
message ActorDeactivated {
  // Why deactivation occurred
  string reason = 1 [(buf.validate.field).string.max_len = 256];
}

// Actor terminated (permanently stopped, not restartable)
//
// ## Purpose
// Emitted when actor's task completes normally (loop exits without error).
// Triggers monitoring callbacks (NotifyActorDown).
//
// ## State Transition
// Activated|Deactivating -> Terminated
//
// ## Supervisor Action
// - If restart strategy allows, restart actor
// - Notify all monitors (local + remote via NotifyActorDown RPC)
//
// ## Design Notes
// - reason="normal": Graceful shutdown completed
// - reason="shutdown": Supervisor-initiated shutdown
// - reason="killed": Forcefully terminated
message ActorTerminated {
  // Termination reason
  // "normal": Graceful shutdown
  // "shutdown": Supervisor-initiated
  // "killed": Forcefully terminated
  string reason = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 256}
  ];
}

// Actor failed (crashed, needs supervision action)
//
// ## Purpose
// Emitted when actor's task panics or returns error. Triggers supervision
// restart logic and monitoring callbacks.
//
// ## State Transition
// Activated -> Failed
//
// ## Supervisor Action
// - Apply restart strategy (OneForOne, OneForAll, RestForOne)
// - Notify all monitors with error details
// - Increment failure counter for escalation
//
// ## Design Notes
// - error: Full panic/error message for debugging
// - Supervision tree decides whether to restart based on restart strategy
message ActorFailed {
  // Error/panic message
  // Examples:
  // - "panic: index out of bounds"
  // - "error: timeout waiting for response"
  // - "error: connection refused"
  string error = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 2048}
  ];

  // Optional: Stack trace for debugging
  string stack_trace = 2 [(buf.validate.field).string.max_len = 8192];
}

// Actor migrating (moving to different node)
//
// ## Purpose
// Emitted when mobile agent starts migration to another node.
//
// ## State Transition
// Activated -> Migrating
//
// ## Supervisor Action
// - Update actor location in registry
// - If migration fails, restart on original node
//
// ## Design Notes
// - target_node: Destination node address (e.g., "node2")
// - Future: Add migration_id for tracking migration progress
message ActorMigrating {
  // Target node where actor is migrating
  string target_node = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
}

// ============================================================================
// Actor Monitoring (Erlang-style)
// ============================================================================

// Request to monitor an actor (Erlang-style)
//
// ## Purpose
// Establishes a monitoring link from supervisor to actor. When actor terminates,
// the node hosting the actor will call NotifyActorDown on the supervisor_callback.
//
// ## Erlang Philosophy
// Equivalent to: Ref = erlang:monitor(process, Pid)
// Works the same for local and remote processes (location transparent).
//
// ## Design Notes
// - actor_id: The actor to monitor (can be "actor@node" for remote)
// - supervisor_id: The supervisor that wants notifications (for logging/debugging)
// - supervisor_callback: gRPC address where to send NotifyActorDown
//   (e.g., "http://supervisor-node:9001")
message MonitorActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Monitor Actor Request"
      description: "Request to monitor an actor for termination"
      required: ["actor_id", "supervisor_id", "supervisor_callback"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string supervisor_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string supervisor_callback = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 512}  // gRPC address
  ];
}

// Response to MonitorActor request
//
// ## Purpose
// Returns a monitor reference that can be used to demonitor in future.
//
// ## Erlang Philosophy
// Equivalent to the Ref returned by erlang:monitor(process, Pid).
//
// ## Design Notes
// - monitor_ref: Unique ID for this monitoring link (ULID)
// - Can be used for future demonitor() operation
message MonitorActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Monitor Actor Response"
      description: "Response with monitor reference"
      required: ["monitor_ref"]
    }
  };

  string monitor_ref = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}  // ULID format
  ];
}

// Notification that a monitored actor has terminated
//
// ## Purpose
// Sent by the node hosting the actor to the supervisor when actor terminates.
// This is an internal message, not typically sent by user code.
//
// ## Erlang Philosophy
// Equivalent to receiving: {'DOWN', Ref, process, Pid, Reason}
// Supervisor receives this asynchronously when monitored actor exits.
//
// ## Design Notes
// - actor_id: The actor that terminated
// - supervisor_id: The supervisor that was monitoring (for routing)
// - reason: Why actor terminated:
//   - "normal": Graceful shutdown
//   - "shutdown": Supervisor-initiated shutdown
//   - "killed": Forcefully terminated
//   - Error message: Crash reason (e.g., "panic: index out of bounds")
message ActorDownNotification {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Down Notification"
      description: "Notification that monitored actor terminated"
      required: ["actor_id", "supervisor_id", "reason"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string supervisor_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string reason = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 256}
  ];
}

// ==================== Link Semantics (Erlang Pattern) ====================

/// Monitor type (distinguishes Monitor from Link)
///
/// ## Purpose
/// Distinguishes between one-way monitoring (Monitor) and two-way death propagation (Link).
/// This enables clear API separation and proper handling of each type.
///
/// ## Erlang Philosophy
/// - **MONITOR**: One-way notification (Erlang `monitor/2`)
///   - Supervisor gets notified when actor dies
///   - Supervisor does NOT die when actor dies
///   - Used for observability, health checks
///
/// - **LINK**: Two-way death propagation (Erlang `link/1`)
///   - If actor1 dies, actor2 automatically dies (cascading)
///   - If actor2 dies, actor1 automatically dies (cascading)
///   - Used for tight coupling, supervision trees
///
/// ## Design Notes
/// - Monitors remain separate (existing functionality)
/// - Links enable cascading failures (new functionality)
/// - Supervision uses links internally (cohesive design)
enum MonitorType {
  MONITOR_TYPE_UNSPECIFIED = 0;

  /// One-way monitoring (get notified, don't die)
  MONITOR_TYPE_MONITOR = 1;

  /// Two-way link (die together, cascading failures)
  MONITOR_TYPE_LINK = 2;
}

/// Actor link for two-way death propagation
///
/// ## Purpose
/// Represents a link between two actors. When one actor dies, the linked actor
/// automatically dies (cascading failure). This is the foundation for supervision trees.
///
/// ## Erlang Philosophy
/// Equivalent to Erlang's `link/1` - creates a bidirectional link between processes.
/// If either process dies abnormally, the other dies too.
///
/// ## Design Notes
/// - Links are bidirectional (if A links to B, B is linked to A)
/// - Links propagate death (if A dies, B dies; if B dies, A dies)
/// - Links are used internally by supervision (parent-child relationships)
/// - Links can also be created explicitly via API
///
/// ## Example
/// ```rust
/// // Link two actors
/// node.link("actor-1", "actor-2").await?;
///
/// // If actor-1 dies abnormally, actor-2 automatically dies
/// // If actor-2 dies abnormally, actor-1 automatically dies
/// ```
message ActorLink {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Actor Link"
      description: "Two-way link between actors for cascading failures"
      required: ["actor_id", "linked_actor_id"]
    }
  };

  /// First actor in the link
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  /// Second actor in the link (bidirectional)
  string linked_actor_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  /// Link creation timestamp (for observability)
  google.protobuf.Timestamp created_at = 3;

  /// Metadata (optional, for debugging)
  map<string, string> metadata = 4;
}

/// Link two actors (Erlang link/1 equivalent)
///
/// ## Purpose
/// Creates a bidirectional link between two actors. When one actor dies abnormally,
/// the linked actor automatically dies (cascading failure).
///
/// ## Erlang Philosophy
/// Equivalent to Erlang's `link(Pid)` - creates bidirectional link.
/// If either process dies abnormally, the other dies too.
///
/// ## Design Notes
/// - Links are bidirectional (if A links to B, B is linked to A)
/// - Links only propagate abnormal deaths (not "normal" shutdowns)
/// - Links are used internally by supervision (parent-child relationships)
/// - Links can be created explicitly via this API
///
/// ## Example
/// ```rust
/// // Link two actors
/// node.link("actor-1", "actor-2").await?;
///
/// // If actor-1 dies abnormally, actor-2 automatically dies
/// // If actor-2 dies abnormally, actor-1 automatically dies
/// ```
message LinkActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Link Actor Request"
      description: "Request to link two actors for cascading failures"
      required: ["actor_id", "linked_actor_id"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string linked_actor_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
}

/// Response to LinkActor request
message LinkActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Link Actor Response"
      description: "Response confirming link creation"
    }
  };

  bool success = 1;
}

/// Unlink two actors (Erlang unlink/1 equivalent)
///
/// ## Purpose
/// Removes the bidirectional link between two actors. After unlinking,
/// actors can die independently without cascading failures.
///
/// ## Erlang Philosophy
/// Equivalent to Erlang's `unlink(Pid)` - removes bidirectional link.
message UnlinkActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Unlink Actor Request"
      description: "Request to unlink two actors"
      required: ["actor_id", "linked_actor_id"]
    }
  };

  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
  string linked_actor_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
}

/// Response to UnlinkActor request
message UnlinkActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Unlink Actor Response"
      description: "Response confirming link removal"
    }
  };

  bool success = 1;
}

// Actor system service
service ActorService {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag) = {
    description: "Service for managing durable actors"
  };

  // Create a new actor
  rpc CreateActor(CreateActorRequest) returns (CreateActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Create Actor"
      description: "Create a new durable actor instance"
      tags: "Actors"
    };
  }

  // Spawn an actor on the node receiving this gRPC request
  //
  // ## Purpose
  // Spawns an actor on the node where this RPC is called. The target node is implicit
  // from the gRPC endpoint (no target_node_id field needed).
  //
  // ## Erlang Comparison
  // Erlang: spawn(Node, Module, Function, Args)
  // PlexSpaces: SpawnActor(actor_type, actor_id?, initial_state, config)
  //   - Node is implicit from gRPC connection endpoint
  //
  // ## Design Notes
  // - This RPC is called ON the target node (node2 receives the request)
  // - The caller (node1) sends gRPC request to node2's ActorService
  // - node2 validates actor_type exists locally, then spawns
  // - Returns ActorRef in format "actor_id@node2" for location-transparent messaging
  // - actor_id is optional: if provided (client-specified), use it; if not, server generates ULID
  //
  // ## Security
  // - Target node validates caller has permission to spawn actors
  // - Target node validates actor_type is registered and safe to spawn
  // - Rate limiting applied per caller to prevent spawn bombing
  rpc SpawnActor(SpawnActorRequest) returns (SpawnActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/spawn"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Spawn Actor"
      description: "Spawn actor on the node receiving this request (target node implicit from endpoint). gRPC is already remote, so 'remote' is redundant."
      tags: "Actors"
    };
  }

  // Get an actor by ID
  rpc GetActor(GetActorRequest) returns (GetActorResponse) {
    option (google.api.http) = {
      get: "/api/v1/actors/{actor_id.id}"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get Actor"
      description: "Retrieve an actor by its ID"
      tags: "Actors"
    };
  }

  // List actors with filtering
  rpc ListActors(ListActorsRequest) returns (ListActorsResponse) {
    option (google.api.http) = {
      get: "/api/v1/actors"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "List Actors"
      description: "List actors with optional filtering"
      tags: "Actors"
    };
  }

  // Send message to an actor
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/{message.receiver_id}/messages"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Send Message"
      description: "Send a message to an actor"
      tags: "Messages"
    };
  }

  // Stream messages for high-throughput scenarios (Erlang-inspired)
  // Use this for bulk message passing or event streaming
  rpc StreamMessages(stream StreamMessageRequest) returns (stream StreamMessageResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Stream Messages"
      description: "Bidirectional streaming for high-throughput message passing"
      tags: "Messages"
    };
  }

  // Change actor state
  rpc SetActorState(SetActorStateRequest) returns (SetActorStateResponse) {
    option (google.api.http) = {
      patch: "/api/v1/actors/{actor_id.id}/state"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Set Actor State"
      description: "Change the state of an actor (activate/deactivate/etc.)"
      tags: "Actors"
    };
  }

  // Migrate actor to different node
  rpc MigrateActor(MigrateActorRequest) returns (MigrateActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/{actor_id.id}/migrate"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Migrate Actor"
      description: "Migrate an actor to a different node"
      tags: "Actors"
    };
  }

  // Delete an actor
  rpc DeleteActor(DeleteActorRequest) returns (plexspaces.common.v1.Empty) {
    option (google.api.http) = {
      delete: "/api/v1/actors/{actor_id.id}"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Delete Actor"
      description: "Delete an actor instance"
      tags: "Actors"
    };
  }

  // NOTE: Facet management RPCs (AttachFacet, DetachFacet, ListFacets) are
  // provided by FacetService in facets.proto to avoid duplication

  // Monitor an actor (Erlang-style location transparent monitoring)
  //
  // ## Purpose
  // Establishes a monitoring link from supervisor to actor. When the actor
  // terminates (normally or abnormally), the remote node will notify the
  // supervisor via NotifyActorDown.
  //
  // ## Erlang Philosophy
  // In Erlang, monitor(process, Pid) works the same for local and remote processes.
  // The runtime handles location transparency - same API whether the process is
  // in the same node or a different node.
  //
  // ## Design Notes
  // - supervisor_id: The actor that wants to be notified (usually a supervisor)
  // - supervisor_callback: gRPC address where to send NotifyActorDown
  // - actor_id can be local or remote (format: "actor@node")
  // - Returns monitor_ref for potential demonitor() in future
  rpc MonitorActor(MonitorActorRequest) returns (MonitorActorResponse) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Monitor Actor"
      description: "Establish monitoring link to actor (Erlang-style)"
      tags: "Supervision"
    };
  }

  // Link two actors (Erlang link/1 equivalent)
  //
  // ## Purpose
  // Creates a bidirectional link between two actors. When one actor dies abnormally,
  // the linked actor automatically dies (cascading failure).
  //
  // ## Erlang Philosophy
  // Equivalent to Erlang's `link(Pid)` - creates bidirectional link.
  // If either process dies abnormally, the other dies too.
  //
  // ## Design Notes
  // - Links are bidirectional (if A links to B, B is linked to A)
  // - Links only propagate abnormal deaths (not "normal" shutdowns)
  // - Links are used internally by supervision (parent-child relationships)
  // - Links can be created explicitly via this API
  rpc LinkActor(LinkActorRequest) returns (LinkActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/{actor_id}/links"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Link Actor"
      description: "Create bidirectional link between two actors (Erlang link/1)"
      tags: "Supervision"
    };
  }

  // Unlink two actors (Erlang unlink/1 equivalent)
  //
  // ## Purpose
  // Removes the bidirectional link between two actors. After unlinking,
  // actors can die independently without cascading failures.
  //
  // ## Erlang Philosophy
  // Equivalent to Erlang's `unlink(Pid)` - removes bidirectional link.
  rpc UnlinkActor(UnlinkActorRequest) returns (UnlinkActorResponse) {
    option (google.api.http) = {
      delete: "/api/v1/actors/{actor_id}/links/{linked_actor_id}"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Unlink Actor"
      description: "Remove bidirectional link between two actors (Erlang unlink/1)"
      tags: "Supervision"
    };
  }

  // Internal: Notify supervisor of actor termination
  //
  // ## Purpose
  // Called by the remote node hosting the actor when it terminates. The remote
  // node sends this notification to the supervisor_callback address that was
  // provided in MonitorActor.
  //
  // ## Erlang Philosophy
  // Equivalent to receiving {'DOWN', Ref, process, Pid, Reason} message in Erlang.
  // The supervisor receives this asynchronously when the monitored actor exits.
  //
  // ## Design Notes
  // - This is an internal RPC, not typically called by user code
  // - Supervisor uses this to implement restart strategies
  // - reason: "normal" for graceful shutdown, error message for crashes
  rpc NotifyActorDown(ActorDownNotification) returns (plexspaces.common.v1.Empty) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Notify Actor Down"
      description: "Internal: Notify supervisor that monitored actor terminated"
      tags: "Supervision"
    };
  }

  // Phase 8.5: Virtual Actor Lifecycle RPCs (Orleans-inspired)

  // Activate a virtual actor (load into memory)
  //
  // ## Purpose
  // Activates a virtual actor that exists virtually but is not yet in memory.
  // Virtual actors are always addressable but activated on-demand.
  //
  // ## When Used
  // Only works for actors with VirtualActorFacet attached (opt-in pattern).
  // Regular actors are always active after creation.
  //
  // ## Behavior
  // - Loads actor state from storage (if persisted)
  // - Instantiates actor in memory
  // - Processes pending messages (queued during activation)
  // - Updates VirtualActorLifecycle (last_activated, activation_count)
  rpc ActivateActor(ActivateActorRequest) returns (ActivateActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/{actor_id}/activate"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Activate Virtual Actor"
      description: "Activate a virtual actor (load into memory)"
      tags: "Virtual Actors"
    };
  }

  // Deactivate a virtual actor (remove from memory)
  //
  // ## Purpose
  // Deactivates a virtual actor that has been idle, freeing memory while
  // maintaining addressability.
  //
  // ## When Used
  // Only works for actors with VirtualActorFacet attached.
  // Regular actors cannot be deactivated (must be deleted).
  //
  // ## Behavior
  // - Persists actor state to storage (if persist_on_deactivation enabled)
  // - Removes actor from memory
  // - Updates VirtualActorLifecycle (last_accessed, is_activating = false)
  // - Queues any new messages for later activation
  rpc DeactivateActor(DeactivateActorRequest) returns (plexspaces.common.v1.Empty) {
    option (google.api.http) = {
      post: "/api/v1/actors/{actor_id}/deactivate"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Deactivate Virtual Actor"
      description: "Deactivate a virtual actor (remove from memory)"
      tags: "Virtual Actors"
    };
  }

  // Check if virtual actor exists (without activating)
  //
  // ## Purpose
  // Query whether a virtual actor exists without triggering activation.
  // Useful for existence checks, health monitoring, and discovery.
  //
  // ## Returns
  // - exists: Actor exists (virtual or active)
  // - is_active: Actor is currently active (in memory)
  // - is_virtual: Actor has VirtualActorFacet (is virtual)
  rpc CheckActorExists(CheckActorExistsRequest) returns (CheckActorExistsResponse) {
    option (google.api.http) = {
      get: "/api/v1/actors/{actor_id}/exists"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Check Actor Exists"
      description: "Check if virtual actor exists without activating"
      tags: "Virtual Actors"
    };
  }

  // Get or activate a virtual actor (Orleans-style)
  //
  // ## Purpose
  // Gets existing actor if active, or activates virtual actor if inactive.
  // This is the primary API for virtual actors (Orleans grains pattern).
  //
  // ## Orleans Comparison
  // Orleans: `IGrainFactory.GetGrain<T>(key)` - always returns grain reference
  // PlexSpaces: `GetOrActivateActor(actor_id, actor_type?, initial_state?, config?)` - activates if needed
  //
  // ## Behavior
  // 1. If actor exists and is active → Return existing ActorRef
  // 2. If actor exists but is inactive (virtual) → Activate and return ActorRef
  // 3. If actor doesn't exist → Create new actor (if actor_type provided) and return ActorRef
  //
  // ## Virtual Actor Pattern
  // - Actor ID must be client-specified (e.g., "user/123", "session/abc")
  // - Actor must have VirtualActorFacet attached (enables lazy activation)
  // - First message triggers activation automatically
  //
  // ## Design Notes
  // - actor_id: Client-specified, required (format: "{actor_type}/{key}" or "{actor_type}@{key}")
  // - actor_type: Required if actor doesn't exist (used to create new actor)
  // - initial_state, config: Used if creating new actor
  rpc GetOrActivateActor(GetOrActivateActorRequest) returns (GetOrActivateActorResponse) {
    option (google.api.http) = {
      post: "/api/v1/actors/get-or-activate"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get Or Activate Actor"
      description: "Get existing actor or activate virtual actor (Orleans-style)"
      tags: "Virtual Actors"
    };
  }

  // Invoke an actor via HTTP-like interface (FaaS-style)
  //
  // ## Purpose
  // Provides a FaaS-like interface for invoking actors via HTTP GET/POST requests.
  // This enables actors to be invoked like serverless functions while maintaining
  // the actor model's stateful, message-driven architecture.
  //
  // ## HTTP Method Behavior
  // - **GET**: Converts query parameters to JSON payload, calls actor.ask() (request-reply)
  // - **POST**: Converts request body to payload and headers to headers, calls actor.tell() (fire-and-forget)
  //
  // ## Actor Lookup
  // - Looks up actors by actor_type using ObjectRegistry discover with object_category filter
  // - If multiple actors of same type found, randomly selects one (load balancing)
  // - Returns 404 if no actor of requested type found
  //
  // ## Security
  // - Extracts tenant_id from JWT claims if authentication enabled
  // - Verifies JWT tenant_id matches requested tenant_id in path
  // - Default tenant_id is "default" when no authentication provided
  // - All actors must have tenant_id (default if no auth)
  //
  // ## Path Format
  // `/api/v1/actors/{tenant_id}/{namespace}/{actor_type}`
  // - tenant_id: Tenant identifier (default: "default")
  // - namespace: Namespace identifier (default: "default" if not specified)
  // - actor_type: Type of actor to invoke (used for lookup)
  rpc InvokeActor(InvokeActorRequest) returns (InvokeActorResponse) {
    option (google.api.http) = {
      get: "/api/v1/actors/{tenant_id}/{namespace}/{actor_type}"
      additional_bindings {
        post: "/api/v1/actors/{tenant_id}/{namespace}/{actor_type}"
        body: "*"
      }
      additional_bindings {
        put: "/api/v1/actors/{tenant_id}/{namespace}/{actor_type}"
        body: "*"
      }
      additional_bindings {
        delete: "/api/v1/actors/{tenant_id}/{namespace}/{actor_type}"
      }
      // Additional bindings without tenant_id (defaults to "default")
      additional_bindings {
        get: "/api/v1/actors/{namespace}/{actor_type}"
      }
      additional_bindings {
        post: "/api/v1/actors/{namespace}/{actor_type}"
        body: "*"
      }
      additional_bindings {
        put: "/api/v1/actors/{namespace}/{actor_type}"
        body: "*"
      }
      additional_bindings {
        delete: "/api/v1/actors/{namespace}/{actor_type}"
      }
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Invoke Actor"
      description: "Invoke an actor via HTTP GET/POST/PUT/DELETE (FaaS-style interface)"
      tags: "Actors"
    };
  }
}

// ============================================================================
// Lifecycle Event Channel (JavaNOW-inspired Pub/Sub for Observability)
// ============================================================================

// LifecycleEventChannel service - event streaming for observability
//
// ## Purpose
// Provides pub/sub channel for actor lifecycle events, inspired by JavaNOW's
// EntitySpace event notification and channel/subscriber architecture.
// This is the foundation for metrics, tracing, and monitoring integration.

// Request to activate a virtual actor
message ActivateActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Activate Actor Request"
      description: "Request to activate a virtual actor"
      required: ["actor_id"]
    }
  };

  // Actor ID to activate (must have VirtualActorFacet)
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  // Optional: Force activation even if already active
  bool force = 2;
}

// Response to activate actor request
message ActivateActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Activate Actor Response"
      description: "Response with activated actor"
    }
  };

  // Activated actor instance
  // Note: actor.state contains the actual lifecycle state (ActorState enum)
  Actor actor = 1;

  // Optional activation metadata (timestamps, counts, etc.)
  // This is metadata only - the actual state is in actor.state (ActorState enum)
  // All actors (virtual or not) use the same ActorState enum for consistency
  VirtualActorLifecycle lifecycle = 2;
}

// Request to deactivate a virtual actor
message DeactivateActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Deactivate Actor Request"
      description: "Request to deactivate a virtual actor"
      required: ["actor_id"]
    }
  };

  // Actor ID to deactivate (must have VirtualActorFacet)
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  // Optional: Force deactivation even if actor has pending messages
  bool force = 2;
}

// Request to check if actor exists
message CheckActorExistsRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Check Actor Exists Request"
      description: "Request to check if virtual actor exists"
      required: ["actor_id"]
    }
  };

  // Actor ID to check
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];
}

// Response to check actor exists request
message CheckActorExistsResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Check Actor Exists Response"
      description: "Response indicating if actor exists and is active"
    }
  };

  // Actor exists (virtual or active)
  bool exists = 1;

  // Actor is currently active (in memory)
  bool is_active = 2;

  // Actor has VirtualActorFacet (is virtual)
  bool is_virtual = 3;
}

// Request to get or activate a virtual actor (Orleans-style)
//
// ## Purpose
// Gets existing actor if active, or activates virtual actor if inactive.
// This is the primary API for virtual actors (Orleans grains pattern).
//
// ## Orleans Comparison
// Orleans: `IGrainFactory.GetGrain<T>(key)` - always returns grain reference
// PlexSpaces: `GetOrActivateActor(actor_id, factory)` - activates if needed
//
// ## Behavior
// 1. If actor exists and is active → Return existing ActorRef
// 2. If actor exists but is inactive (virtual) → Activate and return ActorRef
// 3. If actor doesn't exist → Create new actor (if factory provided) and return ActorRef
//
// ## Virtual Actor Pattern
// - Actor ID must be client-specified (e.g., "user/123", "session/abc")
// - Actor must have VirtualActorFacet attached (enables lazy activation)
// - First message triggers activation automatically
message GetOrActivateActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Get Or Activate Actor Request"
      description: "Get existing actor or activate virtual actor (Orleans-style)"
      required: ["actor_id"]
    }
  };

  // Actor ID (client-specified, required)
  // Format: "{actor_type}/{key}" or "{actor_type}@{key}"
  // Examples: "user/123", "session/abc-xyz", "counter@node1"
  string actor_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 255}
  ];

  // Actor type (required if actor doesn't exist)
  // Used to create new actor if actor_id doesn't exist
  string actor_type = 2 [
    (buf.validate.field).string = {min_len: 1, max_len: 128, pattern: "^[a-z][a-z0-9_-]*$"}
  ];

  // Initial state (used if creating new actor)
  bytes initial_state = 3;

  // Actor config (used if creating new actor)
  ActorConfig config = 4;

  // Force activation even if already active
  bool force_activation = 5;
}

// Response to get or activate actor request
message GetOrActivateActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Get Or Activate Actor Response"
      description: "Response with actor reference"
      required: ["actor_ref"]
    }
  };

  // Actor reference (format: "actor_id@node_id")
  string actor_ref = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 512}
  ];

  // Full actor details
  Actor actor = 2;

  // Was actor activated (true) or already active (false)
  bool was_activated = 3;
}

// Request to invoke an actor via HTTP-like interface (FaaS-style)
//
  // ## Purpose
  // Enables FaaS-like invocation of actors via HTTP GET/POST/PUT/DELETE requests.
  // The tenant_id, namespace, and actor_type are extracted from the HTTP path.
//
// ## HTTP Method Handling
// - GET: Query parameters are converted to JSON and stored in payload as string
// - POST: Request body becomes payload, HTTP headers become headers map
message InvokeActorRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Invoke Actor Request"
      description: "Request to invoke an actor via HTTP-like interface"
      required: ["namespace", "actor_type"]
    }
  };

  // Tenant ID (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type} or /api/v1/actors/{namespace}/{actor_type})
  // Default: "default" if not provided in path or if no authentication provided
  // When using path without tenant_id, this field will be empty and should default to "default"
  string tenant_id = 1 [
    (google.api.field_behavior) = OPTIONAL,
    (buf.validate.field).string = {max_len: 128}
  ];

  // Namespace (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type})
  // Default: "default" if not specified
  string namespace = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128}
  ];

  // Actor type (extracted from path: /api/v1/actors/{tenant_id}/{namespace}/{actor_type})
  // Used to lookup actors via ActorRegistry discover_actors_by_type
  string actor_type = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 1, max_len: 128}
  ];

  // HTTP method (GET, POST, PUT, or DELETE)
  // GET/DELETE: Uses ask() (request-reply), POST/PUT: Uses tell() (fire-and-forget)
  string http_method = 4;

  // Request payload
  // For GET/DELETE: JSON string of query parameters
  // For POST/PUT: Request body bytes
  bytes payload = 5;

  // HTTP headers (for POST/PUT requests)
  // Converted from HTTP request headers
  map<string, string> headers = 6;

  // Query parameters (for GET/DELETE requests)
  // Converted to JSON and stored in payload
  map<string, string> query_params = 7;

  // Full HTTP path for the request (optional)
  // Example: "/api/v1/actors/default/default/counter/custom/path"
  // Allows actors to perform custom routing based on the complete URL
  string path = 9;

  // Subpath after the actor_type segment (optional)
  // Example: for "/api/v1/actors/default/default/counter/metrics/latest"
  //          subpath = "metrics/latest"
  // This will be used in future for advanced per-actor routing capabilities.
  string subpath = 10;
}

// Response from invoking an actor
//
// ## Purpose
// Returns the result of actor invocation.
// For GET (ask): Contains the reply message from actor
// For POST (tell): Contains success status (fire-and-forget)
message InvokeActorResponse {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Invoke Actor Response"
      description: "Response from actor invocation"
    }
  };

  // Success status
  bool success = 1;

  // Response payload (for GET/ask requests)
  // Contains the reply message from actor
  bytes payload = 2;

  // Response headers (optional metadata)
  map<string, string> headers = 3;

  // Actor ID that was invoked (format: "actor_id@node_id")
  string actor_id = 4;

  // Error message (if success is false)
  string error_message = 5;
}
//
// ## JavaNOW Heritage
// JavaNOW provided event notification through:
// - **EntitySpace.addListener()**: Subscribe to entity add/remove events
// - **ChannelI**: Interface for event channels
// - **SubscriberI**: Interface for event consumers
// - **MulticasterImpl**: Event distribution to multiple subscribers
//
// ## PlexSpaces Design
// This service elevates JavaNOW's concepts with:
// - **Proto-typed events**: Strongly-typed ActorLifecycleEvent instead of generic objects
// - **gRPC streaming**: Efficient event delivery across distributed nodes
// - **Metrics integration**: Events automatically feed Prometheus, StatsD, OpenTelemetry
// - **Filtering**: Subscribers receive only events matching their criteria
// - **Backpressure handling**: Slow subscribers don't block fast publishers
//
// ## Integration with Observability Backends
// This channel serves as the **event source** for:
// 1. **Prometheus**: Lifecycle events → Counter/Gauge metrics
//    - ActorCreated → `plexspaces_actor_spawn_total`
//    - ActorTerminated → Decrement `plexspaces_actor_active`
//    - ActorFailed → `plexspaces_actor_error_total`
//
// 2. **StatsD**: Lifecycle events → DogStatsD metrics
//    - Same metric conversions as Prometheus
//    - UDP batched for efficiency
//
// 3. **OpenTelemetry**: Lifecycle events → Spans
//    - ActorActivated → Start span
//    - ActorDeactivated → End span
//    - Distributed tracing across actor calls
//
// 4. **Custom Backends**: Users can subscribe and forward to any system
//    - Elasticsearch for log aggregation
//    - Grafana Loki for log streaming
//    - Custom analytics platforms
//
// ## Design Principles
// 1. **Optional**: Subscribing doesn't affect core supervision (Erlang-simple approach)
// 2. **Decoupled**: Publishers (actors/nodes) don't know about subscribers
// 3. **Efficient**: Events multicast to many subscribers without duplication
// 4. **Filtered**: Subscribers express interest patterns (actor ID, event type, etc.)
// 5. **Resilient**: Slow/failing subscribers don't impact actor performance
service LifecycleEventChannel {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag) = {
    description: "Event streaming for actor lifecycle observability"
  };

  // Subscribe to lifecycle events (streaming)
  //
  // ## Purpose
  // Establishes long-lived stream of lifecycle events matching subscriber's filter.
  // Used by observability backends (Prometheus exporter, StatsD forwarder, etc.)
  //
  // ## Usage Example (Prometheus Exporter)
  // ```rust
  // let filter = EventFilter {
  //     event_types: vec![
  //         EventType::ActorCreated,
  //         EventType::ActorTerminated,
  //         EventType::ActorFailed,
  //     ],
  //     ..Default::default()
  // };
  //
  // let mut stream = client.subscribe_lifecycle_events(filter).await?;
  // while let Some(event) = stream.next().await {
  //     match event.event_type {
  //         ActorCreated => metrics::counter!("actor_spawn_total").increment(1),
  //         ActorTerminated => metrics::gauge!("actor_active").decrement(1.0),
  //         ActorFailed => metrics::counter!("actor_error_total").increment(1),
  //         _ => {}
  //     }
  // }
  // ```
  //
  // ## Backpressure Handling
  // - Subscribers specify buffer_size in filter
  // - When buffer full, drop_policy determines behavior:
  //   - DROP_OLDEST: Drop oldest events (default, good for real-time metrics)
  //   - DROP_NEWEST: Drop newest events (good for audit logs)
  //   - BLOCK: Block publisher (use carefully - can slow actors!)
  rpc SubscribeLifecycleEvents(LifecycleEventFilter) returns (stream ActorLifecycleEvent) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Subscribe to Lifecycle Events"
      description: "Stream of actor lifecycle events for observability"
      tags: "Observability"
    };
  }

  // Publish lifecycle event (internal - used by Node implementation)
  //
  // ## Purpose
  // Internal API for Node to publish lifecycle events to all subscribers.
  // Not typically called by user code - Node publishes automatically when
  // actors transition states.
  //
  // ## Design Notes
  // - Fire-and-forget (non-blocking)
  // - Event distribution happens asynchronously
  // - Subscribers receive events via SubscribeLifecycleEvents stream
  rpc PublishLifecycleEvent(ActorLifecycleEvent) returns (plexspaces.common.v1.Empty) {
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Publish Lifecycle Event"
      description: "Internal: Publish lifecycle event to all subscribers"
      tags: "Observability"
    };
  }
}

// Lifecycle event filter for subscribers
//
// ## Purpose
// Defines what events a subscriber wants to receive. Supports filtering by:
// - Event types (Created, Terminated, Failed, etc.)
// - Actor ID patterns (regex)
// - Node ID patterns (regex)
// - Custom tags
//
// ## Examples
// ```
// // Prometheus exporter - only care about actor spawn/terminate for counts
// EventFilter {
//   event_types: [ACTOR_CREATED, ACTOR_TERMINATED, ACTOR_FAILED]
// }
//
// // Tracing system - want all events for specific actor group
// EventFilter {
//   actor_id_pattern: "worker-.*@node1"
//   event_types: [ACTOR_ACTIVATED, ACTOR_DEACTIVATED]
// }
//
// // Monitoring dashboard - all critical events across cluster
// EventFilter {
//   event_types: [ACTOR_FAILED, ACTOR_MIGRATING]
// }
// ```
message LifecycleEventFilter {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Lifecycle Event Filter"
      description: "Filter criteria for lifecycle event subscriptions"
    }
  };

  // Subscription ID (ULID, generated by subscriber)
  // Used for unsubscribe and tracking
  string subscription_id = 1 [(buf.validate.field).string.max_len = 255];

  // Event types to receive (empty = all types)
  // Maps to ActorLifecycleEvent.event_type oneof
  repeated LifecycleEventType event_types = 2;

  // Actor ID pattern (regex, empty = all actors)
  // Example: "worker-.*@node1" matches all workers on node1
  string actor_id_pattern = 3 [(buf.validate.field).string.max_len = 512];

  // Node ID pattern (regex, empty = all nodes)
  // Example: "prod-.*" matches all production nodes
  string node_id_pattern = 4 [(buf.validate.field).string.max_len = 512];

  // Custom tags filter (AND logic - event must have all tags)
  // Example: {"env": "production", "team": "platform"}
  map<string, string> required_tags = 5;

  // Buffer size for slow subscriber (default: 1000 events)
  // When buffer full, drop_policy determines behavior
  uint32 buffer_size = 6 [(buf.validate.field).uint32.lte = 100000];  // Max 100K events

  // Drop policy when buffer full
  DropPolicy drop_policy = 7;
}

// Lifecycle event types for filtering
enum LifecycleEventType {
  LIFECYCLE_EVENT_TYPE_UNSPECIFIED = 0;
  LIFECYCLE_EVENT_TYPE_CREATED = 1;
  LIFECYCLE_EVENT_TYPE_STARTING = 2;
  LIFECYCLE_EVENT_TYPE_ACTIVATED = 3;
  LIFECYCLE_EVENT_TYPE_DEACTIVATING = 4;
  LIFECYCLE_EVENT_TYPE_DEACTIVATED = 5;
  LIFECYCLE_EVENT_TYPE_TERMINATED = 6;
  LIFECYCLE_EVENT_TYPE_FAILED = 7;
  LIFECYCLE_EVENT_TYPE_MIGRATING = 8;
}

// Drop policy for buffer overflow (JavaNOW-inspired backpressure)
enum DropPolicy {
  DROP_POLICY_UNSPECIFIED = 0;
  DROP_POLICY_DROP_OLDEST = 1;  // Drop oldest events, keep newest (good for real-time)
  DROP_POLICY_DROP_NEWEST = 2;  // Drop newest events, keep oldest (good for audit)
  DROP_POLICY_BLOCK = 3;        // Block publisher until buffer drains (use carefully!)
}

// Virtual Actor Lifecycle (Orleans-inspired)
//
// ## Purpose
// Tracks activation/deactivation state for virtual actors (actors that exist virtually,
// activated on-demand). Virtual actors are always addressable but not always in memory.
//
// ## When Used
// Only present when actor has VirtualActorFacet attached (opt-in pattern).
// Regular actors (explicit creation) don't have this lifecycle tracking.
//
// ## Design Decision
// Virtual actor lifecycle is tracked separately from core ActorState to maintain
// simplicity: core actors are explicit, virtual actors are opt-in via facet.
//
// ## Example
// ```protobuf
// Actor {
//   actor_id: "user-123"
//   state: ACTOR_STATE_INACTIVE  // Virtual actor, not in memory
//   facets: [
//     Facet {
//       type: "virtual_actor"
//       config: {
//         "idle_timeout": "5m",
//         "activation_strategy": "lazy"
//       }
//     }
//   ]
// }
// ```
// Virtual Actor Lifecycle Metadata
//
// ## Purpose
// Provides metadata about virtual actor activation/deactivation (timestamps, counts, etc.).
// This is METADATA only - the actual lifecycle state is tracked in Actor.state (ActorState enum).
//
// ## Design Decision
// All actors (virtual or not) use the same ActorState enum for state consistency.
// VirtualActorLifecycle provides additional metadata useful for virtual actors:
// - Activation timestamps (for monitoring/debugging)
// - Activation counts (for metrics)
// - Idle timeout configuration
// - Pending message counts
//
// ## Usage
// - Actor.state: Source of truth for lifecycle state (CREATING, ACTIVE, INACTIVE, etc.)
// - VirtualActorLifecycle: Optional metadata for virtual actors only
message VirtualActorLifecycle {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "Virtual Actor Lifecycle Metadata"
      description: "Activation/deactivation metadata for virtual actors (timestamps, counts, etc.)"
    }
  };

  // Last time actor was activated (loaded into memory)
  google.protobuf.Timestamp last_activated = 1;

  // Last time actor received a message or performed an operation
  google.protobuf.Timestamp last_accessed = 2;

  // Idle timeout before deactivation (from facet config)
  google.protobuf.Duration idle_timeout = 3;

  // Number of times this actor has been activated
  uint32 activation_count = 4;

  // Is currently activating (prevents duplicate activations)
  bool is_activating = 5;

  // Messages queued during activation (processed after activation completes)
  // Note: This is a simplified representation - actual queue is in Node
  uint32 pending_message_count = 6;
}

// Virtual Actor Configuration (for VirtualActorFacet)
//
// ## Purpose
// Configuration for virtual actor behavior (activation strategy, idle timeout, etc.)
//
// ## Usage
// This config is stored in the VirtualActorFacet's config map:
// ```protobuf
// Facet {
//   type: "virtual_actor"
//   config: {
//     "idle_timeout": "5m",
//     "activation_strategy": "lazy"
//   }
// }
// ```
//
// ## Design Decision
// Config is stored as string map in Facet (simplicity, flexibility).
// This message is for documentation and type safety in Rust code.
message VirtualActorConfig {
  // Activation strategy
  ActivationStrategy activation_strategy = 1;

  // Idle timeout before deactivation
  google.protobuf.Duration idle_timeout = 2;

  // Should actor persist state on deactivation?
  bool persist_on_deactivation = 3;
}

// Activation strategy for virtual actors
enum ActivationStrategy {
  ACTIVATION_STRATEGY_UNSPECIFIED = 0;
  ACTIVATION_STRATEGY_LAZY = 1;      // Activate on first message (default)
  ACTIVATION_STRATEGY_EAGER = 2;     // Activate immediately on creation
  ACTIVATION_STRATEGY_PREWARM = 3;   // Pre-activate based on schedule
}

// ============================================================================
// ActorRef Error Types (Proto-First Design)
// ============================================================================

// ActorRef error codes
enum ActorRefErrorCode {
  ACTOR_REF_ERROR_CODE_UNSPECIFIED = 0;
  ACTOR_REF_ERROR_CODE_ACTOR_NOT_FOUND = 1;
  ACTOR_REF_ERROR_CODE_SEND_FAILED = 2;
  ACTOR_REF_ERROR_CODE_MAILBOX_FULL = 3;
  ACTOR_REF_ERROR_CODE_ACTOR_TERMINATED = 4;
  ACTOR_REF_ERROR_CODE_TIMEOUT = 5;
  ACTOR_REF_ERROR_CODE_REMOTE_NOT_IMPLEMENTED = 6;
}

// ActorRef error message
message ActorRefError {
  ActorRefErrorCode code = 1;
  string message = 2;
  string actor_id = 3;  // Optional: actor ID that caused error
}

// ============================================================================
// Resource Types (Proto-First Design)
// ============================================================================

// Resource profile for an actor
// Indicates what type of resources the actor primarily consumes
enum ResourceProfile {
  RESOURCE_PROFILE_UNSPECIFIED = 0;
  RESOURCE_PROFILE_CPU_INTENSIVE = 1;
  RESOURCE_PROFILE_MEMORY_INTENSIVE = 2;
  RESOURCE_PROFILE_IO_INTENSIVE = 3;
  RESOURCE_PROFILE_NETWORK_INTENSIVE = 4;
  RESOURCE_PROFILE_BALANCED = 5;
}

// Resource contract for an actor
// Declares resource requirements and limits upfront
message ResourceContract {
  // Maximum CPU usage as percentage (0.0 - 100.0)
  float max_cpu_percent = 1;
  // Maximum memory usage in bytes
  uint64 max_memory_bytes = 2;
  // Maximum I/O operations per second
  optional uint32 max_io_ops_per_sec = 3;
  // Guaranteed network bandwidth in Mbps
  optional uint32 guaranteed_bandwidth_mbps = 4;
  // Maximum execution time per message
  optional google.protobuf.Duration max_execution_time = 5;
}

// Current resource usage of an actor
message ResourceUsage {
  // Current CPU usage percentage
  float cpu_percent = 1;
  // Current memory usage in bytes
  uint64 memory_bytes = 2;
  // Current I/O operations per second
  uint32 io_ops_per_sec = 3;
  // Current network bandwidth in Mbps
  uint32 network_mbps = 4;
}

// Resource violation error codes
enum ResourceViolationCode {
  RESOURCE_VIOLATION_CODE_UNSPECIFIED = 0;
  RESOURCE_VIOLATION_CODE_CPU_EXCEEDED = 1;
  RESOURCE_VIOLATION_CODE_MEMORY_EXCEEDED = 2;
  RESOURCE_VIOLATION_CODE_IO_EXCEEDED = 3;
  RESOURCE_VIOLATION_CODE_NETWORK_EXCEEDED = 4;
}

// Resource violation error message
message ResourceViolation {
  ResourceViolationCode code = 1;
  string message = 2;
  // Allowed value (e.g., max_cpu_percent)
  optional float allowed_value = 3;
  // Actual value (e.g., current cpu_percent)
  optional float actual_value = 4;
}

// Actor health status
enum ActorHealthStatus {
  ACTOR_HEALTH_STATUS_UNSPECIFIED = 0;
  ACTOR_HEALTH_STATUS_HEALTHY = 1;
  ACTOR_HEALTH_STATUS_DEGRADED = 2;
  ACTOR_HEALTH_STATUS_STUCK = 3;
  ACTOR_HEALTH_STATUS_FAILED = 4;
}

// Actor health message
message ActorHealth {
  ActorHealthStatus status = 1;
  // For STUCK status: how long actor has been stuck
  optional google.protobuf.Duration stuck_since = 2;
  // For FAILED status: reason for failure
  optional string failure_reason = 3;
}

