// @generated
// This file is @generated by prost-build.
/// Event for event sourcing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub event_type: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="5")]
    pub sequence_number: u64,
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map="string, string", tag="7")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag="8")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag="9")]
    pub causation_id: ::prost::alloc::string::String,
}
/// State snapshot
///
/// ## DEPRECATION NOTICE
/// This message is part of the legacy persistence API (prv package).
/// For new implementations, use `Checkpoint` from plexspaces.journaling.v1 instead.
///
/// ## Why Checkpoint is Preferred
/// - Checkpoint uses uint32 state_schema_version (clearer semantics)
/// - Checkpoint has compression support (3-5x smaller)
/// - Checkpoint has comprehensive versioning documentation
/// - Checkpoint is part of the public v1 API (not prv)
///
/// ## Migration Path
/// If you're using Snapshot, consider migrating to Checkpoint:
/// ```rust
/// // Old: Snapshot (prv)
/// let snapshot = Snapshot {
///      actor_id: "actor-123",
///      data: state_bytes,
///      version: "1",  // String version (unclear semantics)
///      // ...
/// };
///
/// // New: Checkpoint (v1)
/// let checkpoint = Checkpoint {
///      actor_id: "actor-123",
///      state_data: state_bytes,
///      state_schema_version: 1,  // uint32 version (clear semantics)
///      compression: CompressionType::Zstd,
///      // ...
/// };
/// ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="3")]
    pub sequence_number: u64,
    #[prost(message, optional, tag="4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Snapshot version (DEPRECATED: semantics unclear)
    ///
    /// ## Purpose
    /// Intended to track snapshot format version, but semantics are ambiguous.
    ///
    /// ## Issues with This Field
    /// - **Unclear semantics**: Is this snapshot version, state version, or API version?
    /// - **String type**: Hard to compare versions (is "v2" > "1.0" > "2"?)
    /// - **No versioning strategy**: No documentation on compatibility rules
    /// - **No migration examples**: Unclear how to handle version mismatches
    ///
    /// ## Recommended Alternative
    /// Use `Checkpoint.state_schema_version` from plexspaces.journaling.v1:
    /// - Clear semantics: Version of serialized state_data format
    /// - uint32 type: Easy to compare (1 < 2 < 3)
    /// - Documented compatibility rules (Same/Older/Newer)
    /// - Migration examples provided
    ///
    /// ## If You Must Use This Field
    /// Recommended interpretation:
    /// - Use semantic versioning format: "1.0.0", "1.1.0", "2.0.0"
    /// - Parse and compare major.minor.patch components
    /// - Reject newer major versions (breaking changes)
    /// - Accept older major versions with migration
    ///
    /// ## See Also
    /// - `proto/plexspaces/v1/journaling.proto` - Checkpoint.state_schema_version (lines 241-321)
    /// - `docs/SCHEMA_VERSIONING_REVIEW.md` - Section 1.4 for details on this field
    #[prost(string, tag="5")]
    pub version: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Message record for journaling
///
/// ## Purpose
/// Records actor messages in the journal for deterministic replay.
///
/// ## Why This Exists
/// - Enables message replay after actor crashes (Restate-inspired)
/// - Supports exactly-once message processing semantics
/// - Provides audit trail of all actor communications
///
/// ## How It's Used
/// - Actor runtime calls RecordMessageReceived before processing
/// - On recovery, messages are replayed in order from journal
/// - Message IDs prevent duplicate processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageRecord {
    /// Unique message identifier (ULID for time-based ordering)
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Serialized message payload (opaque bytes)
    #[prost(bytes="vec", tag="2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Message metadata (headers, correlation IDs, etc.)
    #[prost(map="string, string", tag="3")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Side effect for journaling external interactions
///
/// ## Purpose
/// Records non-deterministic operations for deterministic replay.
///
/// ## Why This Exists
/// - External calls (HTTP, database) are non-deterministic
/// - Timers/clocks/random numbers need to replay with same values
/// - Ensures replay produces identical results
///
/// ## How It's Used
/// - Actor wraps external calls with journal.record_side_effect()
/// - On first execution, side effect is performed and result journaled
/// - On replay, journaled result is returned without re-executing
///
/// ## Design Decisions
/// - Uses oneof for different side effect types (extensible)
/// - Response is optional (some side effects like timers have no response)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SideEffect {
    #[prost(oneof="side_effect::Effect", tags="1, 2, 3, 4, 5, 6")]
    pub effect: ::core::option::Option<side_effect::Effect>,
}
/// Nested message and enum types in `SideEffect`.
pub mod side_effect {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Effect {
        #[prost(message, tag="1")]
        ExternalCall(super::ExternalCall),
        #[prost(message, tag="2")]
        TimerScheduled(super::TimerScheduled),
        #[prost(message, tag="3")]
        TimerFired(super::TimerFired),
        #[prost(message, tag="4")]
        Sleep(super::Sleep),
        #[prost(message, tag="5")]
        RandomGenerated(super::RandomGenerated),
        #[prost(message, tag="6")]
        TimeAccessed(super::TimeAccessed),
    }
}
/// External service call side effect
///
/// ## Purpose
/// Records external HTTP/gRPC/database calls for replay.
///
/// ## Why Needed
/// - Network calls are non-deterministic (latency, failures, data changes)
/// - Must cache response to replay identical behavior
///
/// ## How It Works
/// - First execution: Call service, journal request + response
/// - Replay: Return journaled response without calling service
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalCall {
    /// Service being called (e.g., "payment-api", "user-db")
    #[prost(string, tag="1")]
    pub service: ::prost::alloc::string::String,
    /// Method/endpoint being invoked (e.g., "charge", "get_user")
    #[prost(string, tag="2")]
    pub method: ::prost::alloc::string::String,
    /// Serialized request payload
    #[prost(bytes="vec", tag="3")]
    pub request: ::prost::alloc::vec::Vec<u8>,
    /// Serialized response payload (empty if call failed)
    #[prost(bytes="vec", tag="4")]
    pub response: ::prost::alloc::vec::Vec<u8>,
}
/// Timer scheduled side effect
///
/// ## Purpose
/// Records timer creation for deterministic replay.
///
/// ## Why Needed
/// - Timers are scheduled at specific wall-clock times
/// - Replay must fire timers at same logical points
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerScheduled {
    /// Timer name/identifier
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Duration in milliseconds
    #[prost(uint64, tag="2")]
    pub duration_ms: u64,
}
/// Timer fired side effect
///
/// ## Purpose
/// Records when timer actually fired for replay.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerFired {
    /// Timer name that fired
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
/// Sleep/delay side effect
///
/// ## Purpose
/// Records sleep duration for deterministic replay.
///
/// ## Why Needed
/// - Sleep advances logical time in replay
/// - Ensures timing-dependent logic replays correctly
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sleep {
    /// Sleep duration in milliseconds
    #[prost(uint64, tag="1")]
    pub duration_ms: u64,
}
/// Random value generation side effect
///
/// ## Purpose
/// Records random values for deterministic replay.
///
/// ## Why Needed
/// - Random number generation must replay with same values
/// - Ensures randomized algorithms produce identical results
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomGenerated {
    /// Random bytes generated
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Time access side effect
///
/// ## Purpose
/// Records wall-clock time reads for deterministic replay.
///
/// ## Why Needed
/// - Current time is non-deterministic
/// - Business logic using timestamps must replay with same values
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeAccessed {
    /// Timestamp when current time was accessed
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Promise metadata (Restate-inspired durable promises)
///
/// ## Purpose
/// Metadata for creating durable promises that survive actor crashes.
///
/// ## Why This Exists
/// - Promises enable async coordination between actors
/// - Must survive crashes (unlike in-memory futures)
/// - Supports exactly-once delivery with idempotency keys
///
/// ## How It's Used
/// - Actor creates promise with journal.record_promise_created()
/// - Promise persists across crashes/restarts
/// - Completion triggers dependent actors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromiseMetadata {
    /// Actor ID that created the promise
    #[prost(string, tag="1")]
    pub creator_id: ::prost::alloc::string::String,
    /// Optional timeout in milliseconds (0 = no timeout)
    #[prost(uint64, tag="2")]
    pub timeout_ms: u64,
    /// Optional idempotency key for deduplication
    #[prost(string, tag="3")]
    pub idempotency_key: ::prost::alloc::string::String,
}
/// Promise result (fulfilled, rejected, or timed out)
///
/// ## Purpose
/// Records the outcome of a durable promise.
///
/// ## Why This Exists
/// - Promises can succeed (fulfilled) or fail (rejected/timeout)
/// - Result must be journaled for replay
/// - Dependent actors need to know outcome
///
/// ## How It's Used
/// - Promise resolver calls journal.record_promise_resolved()
/// - Result is persisted and broadcast to waiters
/// - On replay, promise completes with same result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromiseResult {
    #[prost(oneof="promise_result::Result", tags="1, 2, 3")]
    pub result: ::core::option::Option<promise_result::Result>,
}
/// Nested message and enum types in `PromiseResult`.
pub mod promise_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Promise fulfilled with value
        #[prost(bytes, tag="1")]
        Fulfilled(::prost::alloc::vec::Vec<u8>),
        /// Promise rejected with error message
        #[prost(string, tag="2")]
        Rejected(::prost::alloc::string::String),
        /// Promise timed out (true if timed out)
        #[prost(bool, tag="3")]
        Timeout(bool),
    }
}
/// Journal entry combining events and snapshots
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JournalEntry {
    #[prost(oneof="journal_entry::Entry", tags="1, 2")]
    pub entry: ::core::option::Option<journal_entry::Entry>,
}
/// Nested message and enum types in `JournalEntry`.
pub mod journal_entry {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entry {
        #[prost(message, tag="1")]
        Event(super::Event),
        #[prost(message, tag="2")]
        Snapshot(super::Snapshot),
    }
}
/// Request to append events
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventsRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    /// Optimistic concurrency control
    #[prost(uint64, tag="3")]
    pub expected_sequence: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventsResponse {
    #[prost(uint64, repeated, tag="1")]
    pub sequence_numbers: ::prost::alloc::vec::Vec<u64>,
}
/// Request to read events
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadEventsRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub from_sequence: u64,
    #[prost(uint64, tag="3")]
    pub to_sequence: u64,
    #[prost(int32, tag="4")]
    pub max_events: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadEventsResponse {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    #[prost(bool, tag="2")]
    pub has_more: bool,
    #[prost(uint64, tag="3")]
    pub last_sequence: u64,
}
/// Request to save snapshot
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveSnapshotRequest {
    #[prost(message, optional, tag="1")]
    pub snapshot: ::core::option::Option<Snapshot>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveSnapshotResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to load snapshot
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadSnapshotRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadSnapshotResponse {
    #[prost(message, optional, tag="1")]
    pub snapshot: ::core::option::Option<Snapshot>,
}
/// Request to create checkpoint
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCheckpointRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub sequence_number: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCheckpointResponse {
    #[prost(message, optional, tag="1")]
    pub checkpoint_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request to record message received
///
/// ## Purpose
/// Records that an actor received a message (before processing).
///
/// ## Why This Exists
/// - First step in exactly-once message processing
/// - Enables replay to skip already-processed messages
/// - Provides audit trail of all incoming messages
///
/// ## How It's Used
/// - Called by actor runtime before invoking handle_message()
/// - On replay, runtime checks if message was already processed
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMessageReceivedRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub message: ::core::option::Option<MessageRecord>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMessageReceivedResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to record message processed
///
/// ## Purpose
/// Records the outcome of message processing.
///
/// ## Why This Exists
/// - Completes exactly-once processing cycle
/// - Records success/failure for retry logic
/// - Enables time-travel debugging of message handling
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMessageProcessedRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(enumeration="ProcessingResult", tag="3")]
    pub result: i32,
    /// Populated if result is ERROR or RETRY
    #[prost(string, tag="4")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMessageProcessedResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to record state change
///
/// ## Purpose
/// Journals actor state mutations for recovery.
///
/// ## Why This Exists
/// - Enables state reconstruction from journal
/// - Supports incremental state updates between snapshots
/// - Provides state change audit trail
///
/// ## How It's Used
/// - Called after actor state is modified
/// - On recovery, state changes are replayed in sequence
/// - Snapshots periodically created to speed recovery
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordStateChangeRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash or full state for verification
    #[prost(bytes="vec", tag="2")]
    pub old_state: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub new_state: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordStateChangeResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to record side effect
///
/// ## Purpose
/// Journals non-deterministic operations for deterministic replay.
///
/// ## Why This Exists
/// - External calls, timers, random numbers are non-deterministic
/// - Replay must use cached results instead of re-executing
/// - Ensures identical behavior on recovery
///
/// ## How It's Used
/// - Actor wraps non-deterministic operations with this RPC
/// - First execution performs operation and journals result
/// - Replay returns journaled result without re-execution
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordSideEffectRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub effect: ::core::option::Option<SideEffect>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordSideEffectResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to record promise created
///
/// ## Purpose
/// Creates a durable promise that survives actor crashes.
///
/// ## Why This Exists
/// - Promises enable async actor coordination
/// - Must persist across failures (Restate-inspired)
/// - Supports idempotent promise creation
///
/// ## How It's Used
/// - Actor calls this when creating async operation
/// - Promise ID used to track completion
/// - Timeout ensures promises don't hang forever
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordPromiseCreatedRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<PromiseMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordPromiseCreatedResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to record promise resolved
///
/// ## Purpose
/// Records promise completion (fulfilled or rejected).
///
/// ## Why This Exists
/// - Notifies waiting actors of promise outcome
/// - Result is journaled for replay
/// - Enables promise-based workflows
///
/// ## How It's Used
/// - Called when async operation completes
/// - Wakes up actors waiting on promise
/// - On replay, promise completes immediately with cached result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordPromiseResolvedRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub result: ::core::option::Option<PromiseResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordPromiseResolvedResponse {
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
}
/// Request to truncate journal
///
/// ## Purpose
/// Removes old journal entries after snapshot is created.
///
/// ## Why This Exists
/// - Prevents journal from growing unbounded
/// - Snapshots make old entries redundant
/// - Improves recovery performance
///
/// ## How It's Used
/// - Called after successful snapshot creation
/// - Removes entries up to snapshot sequence number
/// - Keeps recent entries for incremental recovery
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateJournalRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub up_to_sequence: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateJournalResponse {
    #[prost(uint64, tag="1")]
    pub entries_removed: u64,
}
/// Processing result for journaled messages
///
/// ## Purpose
/// Records the outcome of message processing for replay decisions.
///
/// ## Why This Exists
/// - Deterministic replay requires knowing if processing succeeded or failed
/// - Retry logic needs to distinguish between retriable and non-retriable errors
/// - Audit trail for debugging failed message processing
///
/// ## How It's Used
/// - Actor runtime records result after handle_message() completes
/// - On replay, successful messages are skipped (idempotent)
/// - Failed messages can be retried or sent to dead letter queue
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingResult {
    ProcessingResultUnspecified = 0,
    /// Message processed successfully (skip on replay)
    ProcessingResultSuccess = 1,
    /// Processing failed with non-retriable error
    ProcessingResultError = 2,
    /// Processing failed but should be retried
    ProcessingResultRetry = 3,
}
impl ProcessingResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProcessingResult::ProcessingResultUnspecified => "PROCESSING_RESULT_UNSPECIFIED",
            ProcessingResult::ProcessingResultSuccess => "PROCESSING_RESULT_SUCCESS",
            ProcessingResult::ProcessingResultError => "PROCESSING_RESULT_ERROR",
            ProcessingResult::ProcessingResultRetry => "PROCESSING_RESULT_RETRY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESSING_RESULT_UNSPECIFIED" => Some(Self::ProcessingResultUnspecified),
            "PROCESSING_RESULT_SUCCESS" => Some(Self::ProcessingResultSuccess),
            "PROCESSING_RESULT_ERROR" => Some(Self::ProcessingResultError),
            "PROCESSING_RESULT_RETRY" => Some(Self::ProcessingResultRetry),
            _ => None,
        }
    }
}
include!("plexspaces.persistence.prv.tonic.rs");
// @@protoc_insertion_point(module)