// @generated
// This file is @generated by prost-build.
/// Facet definition
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetDefinition {
    /// Unique facet type identifier
    #[prost(string, tag="1")]
    pub facet_type: ::prost::alloc::string::String,
    /// Human-readable name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Description of facet functionality
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Version
    #[prost(string, tag="4")]
    pub version: ::prost::alloc::string::String,
    /// Methods this facet intercepts (empty = all methods)
    #[prost(string, repeated, tag="5")]
    pub intercepted_methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Configuration schema (JSON schema)
    #[prost(string, tag="6")]
    pub config_schema: ::prost::alloc::string::String,
    /// Is this facet transient (Voyager-inspired)
    /// If true, facet can be GC'd when idle
    #[prost(bool, tag="7")]
    pub is_transient: bool,
    /// Metadata
    #[prost(map="string, string", tag="8")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Facet attachment
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetAttachment {
    /// Unique attachment ID
    #[prost(string, tag="1")]
    pub attachment_id: ::prost::alloc::string::String,
    /// Actor this facet is attached to
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Facet type
    #[prost(string, tag="3")]
    pub facet_type: ::prost::alloc::string::String,
    /// Priority (higher = earlier in chain)
    #[prost(int32, tag="4")]
    pub priority: i32,
    /// Facet-specific configuration
    #[prost(message, optional, tag="5")]
    pub config: ::core::option::Option<::prost_types::Struct>,
    /// When attached
    #[prost(message, optional, tag="6")]
    pub attached_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last accessed (for transient facets)
    #[prost(message, optional, tag="7")]
    pub last_accessed: ::core::option::Option<::prost_types::Timestamp>,
    /// Is currently active
    #[prost(bool, tag="8")]
    pub is_active: bool,
}
/// Facet lifecycle hook results
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetLifecycleEvent {
    /// Attachment ID
    #[prost(string, tag="1")]
    pub attachment_id: ::prost::alloc::string::String,
    /// Actor ID
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Facet type
    #[prost(string, tag="3")]
    pub facet_type: ::prost::alloc::string::String,
    /// Event type
    #[prost(enumeration="LifecycleEventType", tag="4")]
    pub event_type: i32,
    /// When event occurred
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Success or error
    #[prost(bool, tag="6")]
    pub success: bool,
    /// Error message if failed
    #[prost(string, tag="7")]
    pub error_message: ::prost::alloc::string::String,
}
/// Facet registry entry
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacetRegistryEntry {
    /// Facet definition
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<FacetDefinition>,
    /// Number of active attachments
    #[prost(uint32, tag="2")]
    pub active_attachments: u32,
    /// When registered
    #[prost(message, optional, tag="3")]
    pub registered_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Is this facet available
    #[prost(bool, tag="4")]
    pub is_available: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterFacetRequest {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<FacetDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterFacetResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterFacetRequest {
    #[prost(string, tag="1")]
    pub facet_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachFacetRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub facet_type: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub priority: i32,
    #[prost(message, optional, tag="4")]
    pub config: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachFacetResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub attachment_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachFacetRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub facet_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActorFacetsRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActorFacetsResponse {
    #[prost(message, repeated, tag="1")]
    pub facets: ::prost::alloc::vec::Vec<FacetAttachment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAvailableFacetsRequest {
    /// Optional filter
    #[prost(string, tag="1")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAvailableFacetsResponse {
    #[prost(message, repeated, tag="1")]
    pub facets: ::prost::alloc::vec::Vec<FacetRegistryEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFacetDefinitionRequest {
    #[prost(string, tag="1")]
    pub facet_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFacetDefinitionResponse {
    #[prost(message, optional, tag="1")]
    pub definition: ::core::option::Option<FacetDefinition>,
    #[prost(bool, tag="2")]
    pub found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFacetConfigRequest {
    #[prost(string, tag="1")]
    pub attachment_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnsureFacetRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub facet_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnsureFacetResponse {
    #[prost(bool, tag="1")]
    pub was_attached: bool,
    #[prost(string, tag="2")]
    pub attachment_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LifecycleEventType {
    LifecycleEventTypeUnspecified = 0,
    Attached = 1,
    Detached = 2,
    Activated = 3,
    Deactivated = 4,
    AutoDetached = 5,
}
impl LifecycleEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LifecycleEventType::LifecycleEventTypeUnspecified => "LIFECYCLE_EVENT_TYPE_UNSPECIFIED",
            LifecycleEventType::Attached => "ATTACHED",
            LifecycleEventType::Detached => "DETACHED",
            LifecycleEventType::Activated => "ACTIVATED",
            LifecycleEventType::Deactivated => "DEACTIVATED",
            LifecycleEventType::AutoDetached => "AUTO_DETACHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIFECYCLE_EVENT_TYPE_UNSPECIFIED" => Some(Self::LifecycleEventTypeUnspecified),
            "ATTACHED" => Some(Self::Attached),
            "DETACHED" => Some(Self::Detached),
            "ACTIVATED" => Some(Self::Activated),
            "DEACTIVATED" => Some(Self::Deactivated),
            "AUTO_DETACHED" => Some(Self::AutoDetached),
            _ => None,
        }
    }
}
/// Facet interception point
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterceptionPoint {
    InterceptionPointUnspecified = 0,
    BeforeMethod = 1,
    AfterMethod = 2,
    OnError = 3,
}
impl InterceptionPoint {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InterceptionPoint::InterceptionPointUnspecified => "INTERCEPTION_POINT_UNSPECIFIED",
            InterceptionPoint::BeforeMethod => "BEFORE_METHOD",
            InterceptionPoint::AfterMethod => "AFTER_METHOD",
            InterceptionPoint::OnError => "ON_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERCEPTION_POINT_UNSPECIFIED" => Some(Self::InterceptionPointUnspecified),
            "BEFORE_METHOD" => Some(Self::BeforeMethod),
            "AFTER_METHOD" => Some(Self::AfterMethod),
            "ON_ERROR" => Some(Self::OnError),
            _ => None,
        }
    }
}
/// Built-in facet types (for reference)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuiltInFacetType {
    BuiltInFacetTypeUnspecified = 0,
    /// Mobility facet (Voyager-inspired)
    Mobility = 1,
    /// Event emitter facet
    EventEmitter = 2,
    /// Key-value storage facet
    KeyValue = 3,
    /// Timer facet (Orleans-inspired)
    Timer = 4,
    /// Reminder facet (Orleans-inspired)
    Reminder = 5,
    /// HTTP client facet (wasmCloud-inspired)
    HttpClient = 6,
    /// Blob storage facet (wasmCloud-inspired)
    BlobStorage = 7,
    /// Secrets facet (wasmCloud-inspired)
    Secrets = 8,
    /// Streaming facet (Orleans-inspired)
    Streaming = 9,
    /// Transaction facet (Orleans-inspired)
    Transaction = 10,
    /// Stateless worker facet (Orleans-inspired)
    StatelessWorker = 11,
    /// Virtual actor facet (Orleans-inspired)
    /// Enables automatic activation/deactivation for always-addressable actors
    VirtualActor = 12,
}
impl BuiltInFacetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BuiltInFacetType::BuiltInFacetTypeUnspecified => "BUILT_IN_FACET_TYPE_UNSPECIFIED",
            BuiltInFacetType::Mobility => "MOBILITY",
            BuiltInFacetType::EventEmitter => "EVENT_EMITTER",
            BuiltInFacetType::KeyValue => "KEY_VALUE",
            BuiltInFacetType::Timer => "TIMER",
            BuiltInFacetType::Reminder => "REMINDER",
            BuiltInFacetType::HttpClient => "HTTP_CLIENT",
            BuiltInFacetType::BlobStorage => "BLOB_STORAGE",
            BuiltInFacetType::Secrets => "SECRETS",
            BuiltInFacetType::Streaming => "STREAMING",
            BuiltInFacetType::Transaction => "TRANSACTION",
            BuiltInFacetType::StatelessWorker => "STATELESS_WORKER",
            BuiltInFacetType::VirtualActor => "VIRTUAL_ACTOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUILT_IN_FACET_TYPE_UNSPECIFIED" => Some(Self::BuiltInFacetTypeUnspecified),
            "MOBILITY" => Some(Self::Mobility),
            "EVENT_EMITTER" => Some(Self::EventEmitter),
            "KEY_VALUE" => Some(Self::KeyValue),
            "TIMER" => Some(Self::Timer),
            "REMINDER" => Some(Self::Reminder),
            "HTTP_CLIENT" => Some(Self::HttpClient),
            "BLOB_STORAGE" => Some(Self::BlobStorage),
            "SECRETS" => Some(Self::Secrets),
            "STREAMING" => Some(Self::Streaming),
            "TRANSACTION" => Some(Self::Transaction),
            "STATELESS_WORKER" => Some(Self::StatelessWorker),
            "VIRTUAL_ACTOR" => Some(Self::VirtualActor),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
