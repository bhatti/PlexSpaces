// @generated
// This file is @generated by prost-build.
// ============================================================================
// Core Journal Types (RESTATE-Inspired)
// ============================================================================

/// / Journal entry for durable actor execution
/// /
/// / ## Purpose
/// / Records all operations performed by an actor for deterministic replay.
/// /
/// / ## Why This Exists
/// / - Enables exactly-once execution semantics (Restate-inspired)
/// / - Supports time-travel debugging (replay to any point in history)
/// / - Provides complete audit trail of actor behavior
/// /
/// / ## Entry Types
/// / - **MessageReceived**: Record incoming message before processing
/// / - **MessageProcessed**: Record processing result (success/failure)
/// / - **StateChanged**: Record actor state mutations
/// / - **SideEffectExecuted**: Record external call results (for caching during replay)
/// / - **TimerScheduled**: Record timer creation
/// / - **TimerFired**: Record timer execution
/// / - **PromiseCreated**: Record durable promise creation
/// / - **PromiseResolved**: Record promise resolution
/// /
/// / ## Design Notes
/// / - sequence: Monotonically increasing per actor (for ordering)
/// / - timestamp: Wall-clock time (not used for ordering, only observability)
/// / - actor_id: Partitioning key for storage (all entries for same actor together)
/// / - correlation_id: Link related entries (e.g., message received -> processed)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JournalEntry {
    /// Unique entry ID (ULID for sortability)
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Actor this entry belongs to
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// Sequence number (monotonic, per-actor)
    #[prost(uint64, tag="3")]
    pub sequence: u64,
    /// Timestamp (observability only, not for ordering)
    #[prost(message, optional, tag="4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Correlation ID (link related entries)
    #[prost(string, tag="5")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Entry payload (oneof for type safety)
    #[prost(oneof="journal_entry::Entry", tags="10, 11, 12, 13, 14, 15, 16, 17")]
    pub entry: ::core::option::Option<journal_entry::Entry>,
}
/// Nested message and enum types in `JournalEntry`.
pub mod journal_entry {
    /// Entry payload (oneof for type safety)
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entry {
        #[prost(message, tag="10")]
        MessageReceived(super::MessageReceived),
        #[prost(message, tag="11")]
        MessageProcessed(super::MessageProcessed),
        #[prost(message, tag="12")]
        StateChanged(super::StateChanged),
        #[prost(message, tag="13")]
        SideEffectExecuted(super::SideEffectExecuted),
        #[prost(message, tag="14")]
        TimerScheduled(super::TimerScheduled),
        #[prost(message, tag="15")]
        TimerFired(super::TimerFired),
        #[prost(message, tag="16")]
        PromiseCreated(super::PromiseCreated),
        #[prost(message, tag="17")]
        PromiseResolved(super::PromiseResolved),
    }
}
/// / Message received by actor (before processing)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageReceived {
    #[prost(string, tag="1")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub message_type: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="4")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// / Message processing result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageProcessed {
    #[prost(string, tag="1")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(enumeration="ProcessingResult", tag="2")]
    pub result: i32,
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="4")]
    pub response_payload: ::prost::alloc::vec::Vec<u8>,
}
/// / Actor state mutation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChanged {
    #[prost(bytes="vec", tag="1")]
    pub old_state: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub new_state: ::prost::alloc::vec::Vec<u8>,
    /// e.g., "counter_incremented", "status_updated"
    #[prost(string, tag="3")]
    pub change_type: ::prost::alloc::string::String,
}
/// / Side effect execution (external call, cached during replay)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SideEffectExecuted {
    /// Unique ID for caching
    #[prost(string, tag="1")]
    pub effect_id: ::prost::alloc::string::String,
    #[prost(enumeration="SideEffectType", tag="2")]
    pub effect_type: i32,
    #[prost(bytes="vec", tag="3")]
    pub request: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub response: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="5")]
    pub error: ::prost::alloc::string::String,
}
/// / Timer scheduled
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerScheduled {
    #[prost(string, tag="1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub delay: ::core::option::Option<::prost_types::Duration>,
    #[prost(bytes="vec", tag="3")]
    pub timer_data: ::prost::alloc::vec::Vec<u8>,
}
/// / Timer fired
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerFired {
    #[prost(string, tag="1")]
    pub timer_id: ::prost::alloc::string::String,
}
/// / Promise created (durable promise)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromiseCreated {
    #[prost(string, tag="1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
/// / Promise resolved
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromiseResolved {
    #[prost(string, tag="1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="3")]
    pub error: ::prost::alloc::string::String,
}
/// / Checkpoint for fast recovery
/// /
/// / ## Purpose
/// / Snapshot of actor state at a specific sequence number for fast replay.
/// /
/// / ## Why This Exists
/// / - Performance: Replay from checkpoint instead of full journal (90%+ faster)
/// / - Cleanup: Truncate old journal entries after checkpoint
/// / - Compression: Reduce storage size (3-5x with zstd)
/// /
/// / ## Design Notes
/// / - sequence: Checkpoint at this sequence number (replay starts from here)
/// / - state_data: Serialized actor state (compressed with zstd)
/// / - metadata: Custom key-value data (e.g., actor type, version)
/// / - compression: Algorithm used (affects deserialization)
/// / - state_schema_version: Version of state_data format for evolution
/// /
/// / ## Schema Versioning Strategy
/// / The `state_schema_version` field enables checkpoint format evolution:
/// /
/// / ### Version Compatibility Rules
/// / - **Same Version**: Load checkpoint directly
/// / - **Newer Version**: Reject with error (forward compatibility not guaranteed)
/// / - **Older Version**: Attempt migration or reject based on compatibility matrix
/// /
/// / ### Migration Strategy
/// / ```
/// / Version 1 → 2: Add new field with default value (backward compatible)
/// / Version 2 → 3: Remove deprecated field (backward compatible)
/// / Version 3 → 4: Change field type (BREAKING - requires migration)
/// / ```
/// /
/// / ### Example Usage
/// / ```rust
/// / // Write checkpoint with current schema version
/// / let checkpoint = Checkpoint {
/// /     actor_id: "actor-123".to_string(),
/// /     sequence: 100,
/// /     state_data: serialized_state,
/// /     state_schema_version: 2, // Current actor state schema version
/// /     // ...
/// / };
/// /
/// / // Load checkpoint with version check
/// / if checkpoint.state_schema_version > CURRENT_SCHEMA_VERSION {
/// /     return Err(IncompatibleSchemaVersion { ... });
/// / }
/// / ```
/// /
/// / ## Usage
/// / ```
/// / Create checkpoint every 100 messages:
/// / - Actor processes message #100 → create checkpoint
/// / - Journal entries 1-99 can be truncated
/// / - On replay: load checkpoint #100, replay entries 101+
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    /// Actor this checkpoint belongs to
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Sequence number at checkpoint
    #[prost(uint64, tag="2")]
    pub sequence: u64,
    /// Checkpoint creation timestamp
    #[prost(message, optional, tag="3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Serialized actor state (possibly compressed)
    #[prost(bytes="vec", tag="4")]
    pub state_data: ::prost::alloc::vec::Vec<u8>,
    /// Compression type used
    #[prost(enumeration="CompressionType", tag="5")]
    pub compression: i32,
    /// Custom metadata (actor type, version, etc.)
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Schema version of state_data for checkpoint format evolution
    ///
    /// ## Purpose
    /// Enables safe checkpoint loading across different actor schema versions.
    ///
    /// ## Why This Exists
    /// - Actor state schemas evolve over time (new fields, removed fields, type changes)
    /// - Loading old checkpoint into new actor version must be safe
    /// - Prevents corrupt state from schema mismatches
    ///
    /// ## Version Rules
    /// - Version 0 = unversioned (legacy checkpoints, assume version 1)
    /// - Version >= 1 = explicit schema version
    /// - Reject checkpoints with version > current actor schema version
    ///
    /// ## Example
    /// Actor v1: state_schema_version = 1 (initial schema)
    /// Actor v2: state_schema_version = 2 (added new field with default)
    /// Actor v3: state_schema_version = 3 (breaking change, requires migration)
    #[prost(uint32, tag="7")]
    pub state_schema_version: u32,
}
/// / Durability configuration (used by DurabilityFacet)
/// /
/// / ## Purpose
/// / Configures the DurabilityFacet for optional actor durability.
/// /
/// / ## Why This Exists
/// / - User requirement: "journaling can be its own crate" (100% optional)
/// / - Facet-based design: Durability attached dynamically, not in core
/// / - Flexibility: Different actors can have different durability configs
/// / - Testing: Disable durability for fast tests, enable for integration tests
/// /
/// / ## Design Notes
/// / - checkpoint_interval = 0 disables checkpointing (pure journal replay)
/// / - cache_side_effects = false disables caching (every replay re-executes)
/// / - replay_on_activation = false skips replay (fresh start)
/// / - backend_config is oneof for type safety (cannot mix configs)
/// /
/// / ## Usage
/// / ```rust
/// / let config = DurabilityConfig {
/// /     backend: JournalBackend::Postgres,
/// /     checkpoint_interval: 100,  // Checkpoint every 100 messages
/// /     replay_on_activation: true,  // Replay journal on actor restart
/// /     cache_side_effects: true,  // Cache external calls during replay
/// /     compression: CompressionType::Zstd,
/// /     backend_config: Some(postgres_config),
/// / };
/// / actor.attach_facet(DurabilityFacet::new(config));
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DurabilityConfig {
    /// Backend type
    #[prost(enumeration="JournalBackend", tag="1")]
    pub backend: i32,
    /// Checkpoint interval (every N messages, 0 = disabled)
    #[prost(uint64, tag="2")]
    pub checkpoint_interval: u64,
    /// Checkpoint timeout
    #[prost(message, optional, tag="3")]
    pub checkpoint_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Enable replay on activation
    #[prost(bool, tag="4")]
    pub replay_on_activation: bool,
    /// Cache side effects for replay
    #[prost(bool, tag="5")]
    pub cache_side_effects: bool,
    /// Compression type for checkpoints
    #[prost(enumeration="CompressionType", tag="6")]
    pub compression: i32,
    /// State schema version for checkpoint compatibility checking
    /// Default: 1 (initial schema version)
    /// Increment when actor state format changes (breaking changes)
    #[prost(uint32, tag="7")]
    pub state_schema_version: u32,
    /// Backend-specific config (oneof for type safety)
    #[prost(oneof="durability_config::BackendConfig", tags="10, 11, 12")]
    pub backend_config: ::core::option::Option<durability_config::BackendConfig>,
}
/// Nested message and enum types in `DurabilityConfig`.
pub mod durability_config {
    /// Backend-specific config (oneof for type safety)
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackendConfig {
        #[prost(message, tag="10")]
        Postgres(super::PostgresJournalConfig),
        #[prost(message, tag="11")]
        Redis(super::RedisJournalConfig),
        #[prost(message, tag="12")]
        Sqlite(super::SqliteJournalConfig),
    }
}
/// / PostgreSQL journal configuration
/// /
/// / ## Purpose
/// / Configures PostgreSQL backend for durable journaling.
/// /
/// / ## Why This Exists
/// / User requirements:
/// / - "we need to make sure db schema doesn't require much changes"
/// / - "framework is smart enough to apply migrations"
/// /
/// / ## Design Notes
/// / - auto_migrate: Use sqlx::migrate! for compile-time checked migrations
/// / - batch_size: Buffer N entries before COPY bulk insert (performance)
/// / - flush_interval_ms: Max time to buffer before flush (latency vs throughput)
/// / - pool_size: Connection pool for concurrent actors
/// /
/// / ## Schema Stability Strategy
/// / - JSONB columns for extensible data (add fields without ALTER TABLE)
/// / - Immutable entries (append-only, never UPDATE)
/// / - Migrations only for new tables/indexes, not field additions
/// /
/// / ## Performance
/// / - Batch writes: 1000 entries/batch or 1s flush = 100K+ writes/sec
/// / - Connection pooling: Reuse connections across actors
/// / - COPY protocol: 10x faster than INSERT for bulk data
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgresJournalConfig {
    #[prost(string, tag="1")]
    pub connection_string: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub pool_size: u32,
    /// Default: 1000
    #[prost(uint32, tag="3")]
    pub batch_size: u32,
    /// Default: 1000
    #[prost(uint32, tag="4")]
    pub flush_interval_ms: u32,
    /// Default: true
    #[prost(bool, tag="5")]
    pub auto_migrate: bool,
}
/// / Redis journal configuration
/// /
/// / ## Purpose
/// / Configures Redis backend for distributed journaling.
/// /
/// / ## Why This Exists
/// / - Distributed systems: Multiple nodes share journal state
/// / - Fast reads: Redis in-memory performance
/// / - TTL support: Automatic cleanup of old journal entries
/// / - Cluster mode: Scale across multiple Redis nodes
/// /
/// / ## Design Notes
/// / - cluster_mode: Use Redis Cluster for horizontal scaling
/// / - key_prefix: Namespace journal keys (e.g., "journal:actor:")
/// / - ttl: Auto-expire old entries after duration
/// /
/// / ## Trade-offs
/// / - ✅ Fast: In-memory, low latency
/// / - ✅ Distributed: Multi-node shared state
/// / - ❌ Not ACID: Eventually consistent
/// / - ❌ Data loss risk: In-memory (use persistence if needed)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedisJournalConfig {
    /// Redis nodes
    #[prost(string, repeated, tag="1")]
    pub nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="2")]
    pub cluster_mode: bool,
    #[prost(string, tag="3")]
    pub key_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
/// / SQLite journal configuration
/// /
/// / ## Purpose
/// / Configures SQLite backend for edge deployments.
/// /
/// / ## Why This Exists
/// / - Edge computing: Single-node deployments (IoT, mobile, edge servers)
/// / - Embedded: No separate database process needed
/// / - Zero config: Single file, no setup
/// / - ACID: Full transaction support despite being embedded
/// /
/// / ## Design Notes
/// / - wal_mode: Write-ahead logging for concurrency (recommended: true)
/// / - synchronous: NORMAL (default), FULL (safer), OFF (faster but risky)
/// / - db_path: File path for database (":memory:" for in-memory SQLite)
/// /
/// / ## Performance
/// / - WAL mode: Concurrent reads + single writer
/// / - NORMAL synchronous: Balance safety vs speed
/// / - Batch transactions: Group 100s of entries in single transaction
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqliteJournalConfig {
    #[prost(string, tag="1")]
    pub db_path: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub wal_mode: bool,
    /// NORMAL, FULL, OFF
    #[prost(string, tag="3")]
    pub synchronous: ::prost::alloc::string::String,
}
/// / Checkpoint configuration
/// /
/// / ## Purpose
/// / Configures periodic snapshots for fast replay.
/// /
/// / ## Why This Exists
/// / - Performance: Replay from checkpoint instead of full journal (90%+ faster)
/// / - Cleanup: Truncate old journal entries after checkpoint
/// / - Compression: Reduce checkpoint size (3-5x with zstd)
/// /
/// / ## Design Notes
/// / - interval: Checkpoint every N messages (100-1000 recommended)
/// / - timeout: Abort checkpoint if takes too long
/// / - keep_count: Keep last N checkpoints for safety (2-3 recommended)
/// / - compression: zstd for high compression, snappy for speed
/// /
/// / ## Example
/// / ```
/// / CheckpointConfig {
/// /   interval: 100,  // Checkpoint every 100 messages
/// /   timeout: 10s,   // Abort if takes > 10s
/// /   compression: ZSTD,
/// /   keep_count: 2,  // Keep last 2 checkpoints
/// / }
/// / ```
/// / Actor processes 1000 messages:
/// / - 10 checkpoints created (every 100 messages)
/// / - Only 2 most recent kept (cleanup after checkpoint)
/// / - Replay only needs last checkpoint + 0-99 journal entries
/// /
/// / ## Additional Configuration (Phase 3)
/// / - entry_interval: Checkpoint every N journal entries
/// / - time_interval: Checkpoint every T seconds (whichever comes first)
/// / - auto_truncate: Automatically delete old journal entries after checkpoint
/// / - async_checkpointing: Run checkpointing in background (don't block actor)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointConfig {
    /// / Enable automatic checkpointing
    #[prost(bool, tag="1")]
    pub enabled: bool,
    /// / Checkpoint interval (number of journal entries)
    /// / Replaces: interval (renamed for clarity)
    #[prost(uint64, tag="2")]
    pub entry_interval: u64,
    /// / Time-based checkpoint interval (optional)
    /// / Replaces: timeout (renamed for clarity)
    #[prost(message, optional, tag="3")]
    pub time_interval: ::core::option::Option<::prost_types::Duration>,
    /// / Compression type for checkpoint state data
    #[prost(enumeration="CompressionType", tag="4")]
    pub compression: i32,
    /// / Number of old checkpoints to retain (0 = keep all)
    /// / Replaces: keep_count (renamed for clarity)
    #[prost(uint32, tag="5")]
    pub retention_count: u32,
    /// / Automatically truncate journal entries after checkpoint
    #[prost(bool, tag="6")]
    pub auto_truncate: bool,
    /// / Run checkpoint creation in background (don't block actor)
    #[prost(bool, tag="7")]
    pub async_checkpointing: bool,
    /// / Metadata for debugging
    #[prost(map="string, string", tag="8")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
// Request/Response messages

/// / Append single journal entry request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendRequest {
    #[prost(message, optional, tag="1")]
    pub entry: ::core::option::Option<JournalEntry>,
}
/// / Append single journal entry response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendResponse {
    #[prost(uint64, tag="1")]
    pub sequence: u64,
}
/// / Append batch of journal entries request (atomic operation)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendBatchRequest {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<JournalEntry>,
}
/// / Append batch of journal entries response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendBatchResponse {
    #[prost(uint64, tag="1")]
    pub first_sequence: u64,
    #[prost(uint64, tag="2")]
    pub last_sequence: u64,
    #[prost(uint32, tag="3")]
    pub count: u32,
}
/// / Replay journal entries from sequence request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplayFromRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub from_sequence: u64,
}
/// / Get latest checkpoint for actor request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLatestCheckpointRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
/// / Save checkpoint request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveCheckpointRequest {
    #[prost(message, optional, tag="1")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
/// / Save checkpoint response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveCheckpointResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
}
/// / Truncate journal to sequence request (cleanup after checkpoint)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateToRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub sequence: u64,
}
/// / Truncate journal to sequence response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateToResponse {
    #[prost(uint64, tag="1")]
    pub deleted_count: u64,
}
/// / Get journal statistics request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatsRequest {
    /// Optional: stats for specific actor
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
}
// ==================== Event Sourcing Request/Response Messages ====================

/// / Append event request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventRequest {
    #[prost(message, optional, tag="1")]
    pub event: ::core::option::Option<ActorEvent>,
}
/// / Append event response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEventResponse {
    #[prost(uint64, tag="1")]
    pub sequence: u64,
}
/// / Replay events from sequence request (paginated)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplayEventsFromRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub from_sequence: u64,
    #[prost(message, optional, tag="3")]
    pub page_request: ::core::option::Option<super::super::common::v1::PageRequest>,
}
/// / Replay events from sequence response (paginated)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplayEventsFromResponse {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<ActorEvent>,
    #[prost(message, optional, tag="2")]
    pub page_response: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// / Get actor history request (paginated)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorHistoryRequest {
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub page_request: ::core::option::Option<super::super::common::v1::PageRequest>,
}
/// / Journal statistics
/// /
/// / ## Purpose
/// / Provides observability metrics for journal health and performance.
/// /
/// / ## Why This Exists
/// / - Monitoring: Track journal growth and performance
/// / - Capacity planning: Know when to cleanup or scale storage
/// / - Debugging: Find actors with large journals
/// /
/// / ## Metrics
/// / - total_entries: All journal entries across all actors
/// / - total_checkpoints: All checkpoints across all actors
/// / - storage_bytes: Total disk/memory usage
/// / - entries_by_actor: Per-actor entry counts for debugging
/// / - oldest_entry: Age of oldest entry (cleanup indicator)
/// / - newest_entry: Most recent activity timestamp
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JournalStats {
    #[prost(uint64, tag="1")]
    pub total_entries: u64,
    #[prost(uint64, tag="2")]
    pub total_checkpoints: u64,
    #[prost(uint64, tag="3")]
    pub storage_bytes: u64,
    #[prost(map="string, uint64", tag="4")]
    pub entries_by_actor: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    #[prost(message, optional, tag="5")]
    pub oldest_entry: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub newest_entry: ::core::option::Option<::prost_types::Timestamp>,
}
// ==================== Execution Context (RESTATE-Inspired) ====================

/// / Execution context for deterministic replay
/// /
/// / ## Purpose
/// / Tracks side effects during actor execution to enable deterministic replay.
/// / When replaying from journal, cached results are returned instead of re-executing
/// / side effects (external API calls, random number generation, etc.).
/// /
/// / ## Why This Exists (RESTATE Pattern)
/// / - **Deterministic Replay**: Actors must produce same result given same inputs
/// / - **Side Effect Deduplication**: Don't re-execute HTTP calls, DB writes on replay
/// / - **Idempotency**: Multiple replays produce identical state
/// / - **Time-Travel Debugging**: Step through execution with cached side effects
/// /
/// / ## Architecture Context
/// / Used by DurabilityFacet to wrap actor message processing:
/// / - Normal mode: Execute side effects, cache results
/// / - Replay mode: Return cached results, don't re-execute
/// /
/// / ## Example Flow
/// / ```
/// / Normal Execution:
/// / 1. Actor receives message
/// / 2. ExecutionContext in NORMAL mode
/// / 3. Actor calls external API via context.record_side_effect("api_call", ...)
/// / 4. Context executes API call, caches result in journal
/// / 5. Returns result to actor
/// /
/// / Replay After Crash:
/// / 1. Actor restarts, replays journal
/// / 2. ExecutionContext in REPLAY mode
/// / 3. Actor calls context.record_side_effect("api_call", ...)
/// / 4. Context finds cached result in journal, returns it
/// / 5. API call NOT re-executed (idempotent)
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionContext {
    /// / Actor ID this context belongs to
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// / Current sequence number being executed
    #[prost(uint64, tag="2")]
    pub current_sequence: u64,
    /// / Execution mode (NORMAL or REPLAY)
    #[prost(enumeration="ExecutionMode", tag="3")]
    pub mode: i32,
    /// / Cached side effect results (keyed by side_effect_id)
    /// /
    /// / ## Structure
    /// / Key: side_effect_id (unique per side effect, e.g., "http_get_1", "random_1")
    /// / Value: Serialized result bytes
    /// /
    /// / ## Why Map
    /// / - Fast lookup during replay (O(1))
    /// / - Preserves execution order via keyed IDs
    /// / - Extensible (add any side effect type)
    #[prost(map="string, bytes", tag="4")]
    pub side_effect_cache: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// / Metadata for debugging
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// / Side effect entry (recorded in journal during normal execution)
/// /
/// / ## Purpose
/// / Represents a single side effect execution and its cached result.
/// / Stored in journal as SideEffectExecuted entry.
/// /
/// / ## Why This Exists
/// / - Enables replay without re-executing side effects
/// / - Captures input/output for debugging
/// / - Preserves execution determinism
/// /
/// / ## Example
/// / HTTP GET request:
/// / - side_effect_id: "http_get_1"
/// / - side_effect_type: "http_request"
/// / - input_data: {"url": "<https://api.example.com/user/123",> "method": "GET"}
/// / - output_data: {"status": 200, "body": "{\"name\": \"Alice\"}"}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SideEffectEntry {
    /// / Unique ID for this side effect within the actor's execution
    /// /
    /// / ## Format
    /// / Recommended: "{type}_{sequence}" (e.g., "http_get_1", "db_write_2")
    /// /
    /// / ## Why Unique
    /// / Multiple side effects of same type need distinct IDs for cache lookup
    #[prost(string, tag="1")]
    pub side_effect_id: ::prost::alloc::string::String,
    /// / Side effect type (e.g., "http_request", "db_query", "random", "timestamp")
    #[prost(string, tag="2")]
    pub side_effect_type: ::prost::alloc::string::String,
    /// / Input to the side effect (serialized, format depends on type)
    #[prost(bytes="vec", tag="3")]
    pub input_data: ::prost::alloc::vec::Vec<u8>,
    /// / Output from the side effect (cached result)
    #[prost(bytes="vec", tag="4")]
    pub output_data: ::prost::alloc::vec::Vec<u8>,
    /// / Timestamp when side effect was executed (for debugging)
    #[prost(message, optional, tag="5")]
    pub executed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// / Metadata (HTTP headers, DB connection info, etc.)
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
// ==================== Checkpoint Manager ====================

/// / Checkpoint manager runtime statistics
/// /
/// / ## Purpose
/// / Observability metrics for checkpoint manager performance and health.
/// / Complements CheckpointConfig with runtime metrics.
/// /
/// / ## Why This Exists
/// / - Monitor checkpoint performance in production
/// / - Track storage usage from checkpoints
/// / - Detect checkpoint failures or slowness
/// / - Capacity planning for storage
/// /
/// / ## Metrics
/// / - checkpoints_created: Total checkpoints created (lifetime counter)
/// / - avg_checkpoint_duration: Average time to create checkpoint
/// / - last_checkpoint_size: Size of most recent checkpoint (bytes, compressed)
/// / - entries_truncated: Journal entries deleted after checkpoint (storage savings)
/// / - last_checkpoint_at: Timestamp of most recent checkpoint (for alerting)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointManagerStats {
    #[prost(uint64, tag="1")]
    pub checkpoints_created: u64,
    #[prost(message, optional, tag="2")]
    pub avg_checkpoint_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(uint64, tag="3")]
    pub last_checkpoint_size: u64,
    #[prost(uint64, tag="4")]
    pub entries_truncated: u64,
    #[prost(message, optional, tag="5")]
    pub last_checkpoint_at: ::core::option::Option<::prost_types::Timestamp>,
}
// ==================== Event Sourcing (Temporal-Inspired) ====================

/// / Actor event history for event sourcing (paginated)
/// /
/// / ## Purpose
/// / Paginated event log for an actor, enabling event sourcing and time-travel debugging.
/// / Events represent state changes (not messages), allowing state to be reconstructed
/// / by replaying events.
/// /
/// / ## Why This Exists
/// / - **Event Sourcing**: State derived from events (events are source of truth)
/// / - **Time-Travel Debugging**: Replay to any point in time
/// / - **Audit Trail**: Complete history of state changes
/// / - **Causal Tracking**: Link events to messages that caused them
/// / - **Performance**: Pagination enables efficient retrieval of large event logs
/// /
/// / ## Design Notes
/// / - Events are separate from journal entries (journal = messages, events = state changes)
/// / - Events are immutable (append-only)
/// / - Events can be replayed to reconstruct state at any point
/// / - Shared snapshots with journaling (efficiency)
/// / - **Pagination**: Cursor-based pagination for efficient retrieval (O(1) per page)
/// /
/// / ## Architecture Context
/// / Part of Phase 8.5 Event Sourcing Enhancement. Builds on DurabilityFacet:
/// / - Journaling: Messages → State (state is source of truth)
/// / - Event Sourcing: Events → State (events are source of truth)
/// / - Hybrid: Both messages AND events tracked (enhancement, not replacement)
/// /
/// / ## Example Flow
/// / ```
/// / Message → Journal Entry → Event → Event Log
/// /                          ↓
/// /                    State Snapshot (shared)
/// / ```
/// /
/// / ## Pagination
/// / Use `page_token` from `PageResponse` to fetch next page:
/// / ```rust
/// / let mut page_token = String::new();
/// / loop {
/// /     let history = storage.get_actor_history_paginated(actor_id, page_token, 100).await?;
/// /     // Process events...
/// /     if history.page_response.next_page_token.is_empty() {
/// /         break; // No more pages
/// /     }
/// /     page_token = history.page_response.next_page_token;
/// / }
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorHistory {
    /// / Actor ID this history belongs to
    #[prost(string, tag="1")]
    pub actor_id: ::prost::alloc::string::String,
    /// / Events for this page (ordered by sequence)
    /// / Note: For complete history, use pagination (see PageResponse)
    #[prost(message, repeated, tag="2")]
    pub events: ::prost::alloc::vec::Vec<ActorEvent>,
    /// / Latest sequence number (for fast access)
    #[prost(uint64, tag="3")]
    pub latest_sequence: u64,
    /// / Creation timestamp (when first event was recorded)
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// / Last update timestamp (when last event was recorded)
    #[prost(message, optional, tag="5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// / Metadata (actor type, version, etc.)
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// / Pagination response (if paginated request)
    #[prost(message, optional, tag="7")]
    pub page_response: ::core::option::Option<super::super::common::v1::PageResponse>,
}
/// / Single event in actor history (state change)
/// /
/// / ## Purpose
/// / Represents a single state change event. Events are the source of truth
/// / for event sourcing - state is derived by replaying events.
/// /
/// / ## Why This Exists
/// / - **Event Sourcing Pattern**: State = f(events) instead of storing state directly
/// / - **Time-Travel**: Replay events up to any sequence to get state at that point
/// / - **Audit**: Complete history of what happened (not just current state)
/// / - **Causal Tracking**: Link events to messages/causes
/// /
/// / ## Design Notes
/// / - sequence: Monotonically increasing per actor (for ordering)
/// / - event_type: Type of state change (e.g., "counter_incremented", "user_created")
/// / - event_data: Serialized event payload (format depends on event_type)
/// / - caused_by: Link to journal entry that caused this event (correlation)
/// / - timestamp: Wall-clock time (observability, not for ordering)
/// /
/// / ## Event Types
/// / Common event types:
/// / - `state_changed`: Generic state mutation
/// / - `counter_incremented`: Counter increased by N
/// / - `user_created`: User entity created
/// / - `order_placed`: Order entity created
/// / - `payment_processed`: Payment completed
/// /
/// / ## Example
/// / ```rust
/// / // Counter actor receives Increment message
/// / // Journal entry: MessageReceived { message_id: "msg-1", ... }
/// / // Event: ActorEvent {
/// / //   sequence: 1,
/// / //   event_type: "counter_incremented",
/// / //   event_data: b"{\"amount\": 5}",
/// / //   caused_by: "msg-1",
/// / //   ...
/// / // }
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorEvent {
    /// / Unique event ID (ULID for sortability)
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// / Actor ID this event belongs to
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
    /// / Sequence number (monotonic, per-actor)
    #[prost(uint64, tag="3")]
    pub sequence: u64,
    /// / Event type (e.g., "counter_incremented", "user_created")
    #[prost(string, tag="4")]
    pub event_type: ::prost::alloc::string::String,
    /// / Event payload (serialized, format depends on event_type)
    #[prost(bytes="vec", tag="5")]
    pub event_data: ::prost::alloc::vec::Vec<u8>,
    /// / Timestamp when event occurred
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// / Correlation ID linking to journal entry that caused this event
    /// /
    /// / ## Purpose
    /// / Links events to messages (causal tracking). Enables answering:
    /// / - "Which message caused this event?"
    /// / - "What events were caused by this message?"
    /// /
    /// / ## Example
    /// / Journal entry has correlation_id = "corr-1"
    /// / Event has caused_by = "corr-1"
    /// / → This event was caused by that journal entry
    #[prost(string, tag="7")]
    pub caused_by: ::prost::alloc::string::String,
    /// / Metadata (custom key-value data)
    #[prost(map="string, string", tag="8")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// / Event sourcing configuration (used by EventSourcingFacet)
/// /
/// / ## Purpose
/// / Configures event sourcing behavior for actors with EventSourcingFacet.
/// / Event sourcing is opt-in (via facet) and builds on DurabilityFacet.
/// /
/// / ## Why This Exists
/// / - User requirement: Event sourcing as enhancement to journaling (not replacement)
/// / - Facet-based design: Event sourcing attached dynamically, not in core
/// / - Flexibility: Different actors can have different event sourcing configs
/// / - Performance: Can disable event sourcing for performance-critical actors
/// /
/// / ## Design Notes
/// / - Requires DurabilityFacet (event sourcing builds on journaling)
/// / - event_log_enabled: Enable event log (default: true)
/// / - auto_replay: Automatically replay events on activation (default: true)
/// / - snapshot_interval: Create snapshot every N events (0 = disabled)
/// / - time_travel_enabled: Enable time-travel debugging (default: true)
/// /
/// / ## Usage
/// / ```rust
/// / let config = EventSourcingConfig {
/// /     event_log_enabled: true,
/// /     auto_replay: true,
/// /     snapshot_interval: 100,  // Snapshot every 100 events
/// /     time_travel_enabled: true,
/// /     metadata: Default::default(),
/// / };
/// / actor.attach_facet(EventSourcingFacet::new(config));
/// / ```
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSourcingConfig {
    /// / Enable event log (if false, only journaling, no events)
    #[prost(bool, tag="1")]
    pub event_log_enabled: bool,
    /// / Automatically replay events on actor activation
    #[prost(bool, tag="2")]
    pub auto_replay: bool,
    /// / Snapshot interval (every N events, 0 = disabled)
    /// / Shared with DurabilityFacet checkpointing (efficiency)
    #[prost(uint64, tag="3")]
    pub snapshot_interval: u64,
    /// / Enable time-travel debugging (replay to any sequence)
    #[prost(bool, tag="4")]
    pub time_travel_enabled: bool,
    /// / Metadata for debugging
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// / Default page size for paginated queries (0 = use system default, typically 100)
    #[prost(int32, tag="6")]
    pub default_page_size: i32,
    /// / Maximum page size (enforced limit, default: 1000)
    #[prost(int32, tag="7")]
    pub max_page_size: i32,
}
/// / Processing result enum
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingResult {
    ProcessingResultUnspecified = 0,
    ProcessingResultSuccess = 1,
    ProcessingResultError = 2,
    ProcessingResultRetry = 3,
}
impl ProcessingResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProcessingResult::ProcessingResultUnspecified => "PROCESSING_RESULT_UNSPECIFIED",
            ProcessingResult::ProcessingResultSuccess => "PROCESSING_RESULT_SUCCESS",
            ProcessingResult::ProcessingResultError => "PROCESSING_RESULT_ERROR",
            ProcessingResult::ProcessingResultRetry => "PROCESSING_RESULT_RETRY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESSING_RESULT_UNSPECIFIED" => Some(Self::ProcessingResultUnspecified),
            "PROCESSING_RESULT_SUCCESS" => Some(Self::ProcessingResultSuccess),
            "PROCESSING_RESULT_ERROR" => Some(Self::ProcessingResultError),
            "PROCESSING_RESULT_RETRY" => Some(Self::ProcessingResultRetry),
            _ => None,
        }
    }
}
/// / Side effect type
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SideEffectType {
    SideEffectTypeUnspecified = 0,
    /// HTTP/gRPC call
    SideEffectTypeExternalCall = 1,
    SideEffectTypeDatabaseQuery = 2,
    SideEffectTypeFileIo = 3,
    /// RNG calls (must be cached!)
    SideEffectTypeRandomGeneration = 4,
}
impl SideEffectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SideEffectType::SideEffectTypeUnspecified => "SIDE_EFFECT_TYPE_UNSPECIFIED",
            SideEffectType::SideEffectTypeExternalCall => "SIDE_EFFECT_TYPE_EXTERNAL_CALL",
            SideEffectType::SideEffectTypeDatabaseQuery => "SIDE_EFFECT_TYPE_DATABASE_QUERY",
            SideEffectType::SideEffectTypeFileIo => "SIDE_EFFECT_TYPE_FILE_IO",
            SideEffectType::SideEffectTypeRandomGeneration => "SIDE_EFFECT_TYPE_RANDOM_GENERATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIDE_EFFECT_TYPE_UNSPECIFIED" => Some(Self::SideEffectTypeUnspecified),
            "SIDE_EFFECT_TYPE_EXTERNAL_CALL" => Some(Self::SideEffectTypeExternalCall),
            "SIDE_EFFECT_TYPE_DATABASE_QUERY" => Some(Self::SideEffectTypeDatabaseQuery),
            "SIDE_EFFECT_TYPE_FILE_IO" => Some(Self::SideEffectTypeFileIo),
            "SIDE_EFFECT_TYPE_RANDOM_GENERATION" => Some(Self::SideEffectTypeRandomGeneration),
            _ => None,
        }
    }
}
// ============================================================================
// Configuration Messages (Proto-First)
// ============================================================================

/// / Journal backend provider
/// /
/// / ## Purpose
/// / Defines which storage backend to use for journal persistence.
/// /
/// / ## Why This Exists
/// / - Flexibility: Choose backend based on deployment environment
/// / - Testing: Use Memory backend for unit tests (no external dependencies)
/// / - Production: Use PostgreSQL for durability and ACID guarantees
/// / - Distributed: Use Redis for multi-node journaling
/// / - Edge: Use SQLite for single-node edge deployments
/// /
/// / ## Design Notes
/// / - Memory: In-process HashMap, no persistence (testing only)
/// / - PostgreSQL: ACID transactions, auto-migration via sqlx::migrate!
/// / - Redis: Distributed, eventually consistent, TTL support
/// / - SQLite: Embedded, WAL mode, single-node
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JournalBackend {
    JournalBackendUnspecified = 0,
    /// In-memory (testing)
    JournalBackendMemory = 1,
    /// PostgreSQL (production)
    JournalBackendPostgres = 2,
    /// Redis (distributed)
    JournalBackendRedis = 3,
    /// SQLite (edge)
    JournalBackendSqlite = 4,
}
impl JournalBackend {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            JournalBackend::JournalBackendUnspecified => "JOURNAL_BACKEND_UNSPECIFIED",
            JournalBackend::JournalBackendMemory => "JOURNAL_BACKEND_MEMORY",
            JournalBackend::JournalBackendPostgres => "JOURNAL_BACKEND_POSTGRES",
            JournalBackend::JournalBackendRedis => "JOURNAL_BACKEND_REDIS",
            JournalBackend::JournalBackendSqlite => "JOURNAL_BACKEND_SQLITE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOURNAL_BACKEND_UNSPECIFIED" => Some(Self::JournalBackendUnspecified),
            "JOURNAL_BACKEND_MEMORY" => Some(Self::JournalBackendMemory),
            "JOURNAL_BACKEND_POSTGRES" => Some(Self::JournalBackendPostgres),
            "JOURNAL_BACKEND_REDIS" => Some(Self::JournalBackendRedis),
            "JOURNAL_BACKEND_SQLITE" => Some(Self::JournalBackendSqlite),
            _ => None,
        }
    }
}
/// / Compression type
/// /
/// / ## Purpose
/// / Defines compression algorithm for checkpoints and journal entries.
/// /
/// / ## Why This Exists
/// / - Checkpoints: Large state, compress with zstd (3-5x smaller)
/// / - Journal entries: Many small entries, compress with snappy (fast)
/// / - None: No compression for testing or small payloads
/// /
/// / ## Performance
/// / - ZSTD: 3-5x compression, slower (use for checkpoints)
/// / - Snappy: 1.5-2x compression, very fast (use for journal)
/// / - None: No CPU overhead (use for testing)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionType {
    CompressionTypeUnspecified = 0,
    CompressionTypeNone = 1,
    /// High compression (checkpoints)
    CompressionTypeZstd = 2,
    /// Fast compression (journal)
    CompressionTypeSnappy = 3,
}
impl CompressionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressionType::CompressionTypeUnspecified => "COMPRESSION_TYPE_UNSPECIFIED",
            CompressionType::CompressionTypeNone => "COMPRESSION_TYPE_NONE",
            CompressionType::CompressionTypeZstd => "COMPRESSION_TYPE_ZSTD",
            CompressionType::CompressionTypeSnappy => "COMPRESSION_TYPE_SNAPPY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_TYPE_UNSPECIFIED" => Some(Self::CompressionTypeUnspecified),
            "COMPRESSION_TYPE_NONE" => Some(Self::CompressionTypeNone),
            "COMPRESSION_TYPE_ZSTD" => Some(Self::CompressionTypeZstd),
            "COMPRESSION_TYPE_SNAPPY" => Some(Self::CompressionTypeSnappy),
            _ => None,
        }
    }
}
/// / Execution mode for ExecutionContext
/// /
/// / ## Purpose
/// / Determines whether to execute side effects or return cached results.
/// /
/// / ## States
/// / - NORMAL: Execute side effects, cache results
/// / - REPLAY: Return cached results, don't re-execute
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionMode {
    ExecutionModeUnspecified = 0,
    /// / Normal execution mode: execute side effects and cache results
    ExecutionModeNormal = 1,
    /// / Replay mode: return cached side effect results without re-execution
    ExecutionModeReplay = 2,
}
impl ExecutionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionMode::ExecutionModeUnspecified => "EXECUTION_MODE_UNSPECIFIED",
            ExecutionMode::ExecutionModeNormal => "EXECUTION_MODE_NORMAL",
            ExecutionMode::ExecutionModeReplay => "EXECUTION_MODE_REPLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_MODE_UNSPECIFIED" => Some(Self::ExecutionModeUnspecified),
            "EXECUTION_MODE_NORMAL" => Some(Self::ExecutionModeNormal),
            "EXECUTION_MODE_REPLAY" => Some(Self::ExecutionModeReplay),
            _ => None,
        }
    }
}
include!("plexspaces.journaling.v1.tonic.rs");
// @@protoc_insertion_point(module)